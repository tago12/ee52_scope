
sopc_scope_1st.elf:     file format elf32-littlenios2
sopc_scope_1st.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x001801b8

Program Header:
    LOAD off    0x00001000 vaddr 0x00180000 paddr 0x00180000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00180020 paddr 0x00180020 align 2**12
         filesz 0x00006044 memsz 0x00006044 flags r-x
    LOAD off    0x00008000 vaddr 0x00220000 paddr 0x00186064 align 2**12
         filesz 0x00001840 memsz 0x000028e0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00180000  00180000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000198  00180020  00180020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000556c  001801b8  001801b8  000011b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000940  00185724  00185724  00006724  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001840  00220000  00186064  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000010a0  00221840  001878a4  00009840  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  00009840  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000007a0  00000000  00000000  00009868  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00009fc1  00000000  00000000  0000a008  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000037e1  00000000  00000000  00013fc9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000037e2  00000000  00000000  000177aa  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000010fc  00000000  00000000  0001af8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00001e9a  00000000  00000000  0001c088  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    000025da  00000000  00000000  0001df22  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000010  00000000  00000000  000204fc  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000170  00000000  00000000  00020510  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000003  00000000  00000000  000232a7  2**0
                  CONTENTS, READONLY
 17 .cpu          00000004  00000000  00000000  000232aa  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  000232ae  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  000232af  2**0
                  CONTENTS, READONLY
 20 .stderr_dev   00000004  00000000  00000000  000232b0  2**0
                  CONTENTS, READONLY
 21 .stdin_dev    00000004  00000000  00000000  000232b4  2**0
                  CONTENTS, READONLY
 22 .stdout_dev   00000004  00000000  00000000  000232b8  2**0
                  CONTENTS, READONLY
 23 .sopc_system_name 0000000e  00000000  00000000  000232bc  2**0
                  CONTENTS, READONLY
 24 .quartus_project_dir 00000026  00000000  00000000  000232ca  2**0
                  CONTENTS, READONLY
 25 .sopcinfo     000734c9  00000000  00000000  000232f0  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00180000 l    d  .entry	00000000 .entry
00180020 l    d  .exceptions	00000000 .exceptions
001801b8 l    d  .text	00000000 .text
00185724 l    d  .rodata	00000000 .rodata
00220000 l    d  .rwdata	00000000 .rwdata
00221840 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 C:/Users/tago/Dropbox/OUT/EE52/software/sopc_scope_1st_bsp//obj/HAL/src/crt0.o
001801f0 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00180094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 char57.c
00000000 l    df *ABS*	00000000 keyproc.c
00000000 l    df *ABS*	00000000 lcdout.c
00000000 l    df *ABS*	00000000 mainloop.c
00180810 l     F .text	0000008c key_lookup
00185ad0 l     O .rodata	00000030 process_key.1915
00185aa4 l     O .rodata	00000014 keys.1922
00185ab8 l     O .rodata	00000018 keycodes.1921
00000000 l    df *ABS*	00000000 menu.c
00221840 l     O .bss	00000004 menu_display
00185b38 l     O .rodata	00000070 menu
00221844 l     O .bss	00000004 menu_entry
00180c68 l     F .text	000000ec display_entry
00185bc4 l     O .rodata	0000001c process.1667
00185ba8 l     O .rodata	0000001c process.1672
00000000 l    df *ABS*	00000000 menuact.c
00221848 l     O .bss	00000004 trigger_mode
0022184c l     O .bss	00000004 scale
00221850 l     O .bss	00000004 sweep
00221854 l     O .bss	00000004 level
00221858 l     O .bss	00000004 slope
0022185c l     O .bss	00000004 delay
00185c70 l     O .rodata	00000090 sweep_rates
00185d50 l     O .rodata	0000000c modes.1640
00185d20 l     O .rodata	0000000c scale_stat.1653
001815d4 l     F .text	000000d4 adjust_trg_delay
001818e0 l     F .text	00000198 cvt_num_field
0022180c l     O .rwdata	00000008 slopes.1693
00000000 l    df *ABS*	00000000 testcode.c
00185d5c l     O .rodata	000001e0 waveform.1504
00000000 l    df *ABS*	00000000 tracutil.c
00221860 l     O .bss	00000004 trace_status
00221864 l     O .bss	00000004 sampling
00221868 l     O .bss	00000004 sample_size
0022189c l     O .bss	00000780 old_sample
0022186c l     O .bss	00000004 cur_scale
0022201c l     O .bss	0000012c saved_axis_x
00222148 l     O .bss	00000176 saved_axis_y
002222be l     O .bss	000002a0 saved_menu
0022255e l     O .bss	000000f0 saved_area
00221870 l     O .bss	00000004 saved_pos_x
00221874 l     O .bss	00000004 saved_pos_y
00221878 l     O .bss	00000004 saved_end_x
0022187c l     O .bss	00000004 saved_end_y
00000000 l    df *ABS*	00000000 obj/default/display.o
00182b78 l       .text	00000000 row_loop
00182b88 l       .text	00000000 next_row
00182bc4 l       .text	00000000 trace_check
00182bd0 l       .text	00000000 trace_clear
00182bcc l       .text	00000000 cursor_check
00182bd4 l       .text	00000000 trace_row_loop
00182be0 l       .text	00000000 trace_next_row
00000000 l    df *ABS*	00000000 obj/default/keys.o
00220000 l       .rwdata	00000000 curr_key
00182ce0 l       .text	00000000 keys_handler_push1
00182ce8 l       .text	00000000 keys_handler_push2
00182cf0 l       .text	00000000 keys_handler_rot1r
00182cf8 l       .text	00000000 keys_handler_rot1l
00182d00 l       .text	00000000 keys_handler_rot2r
00182d08 l       .text	00000000 keys_handler_rot2l
00182d10 l       .text	00000000 keys_handler_done
00000000 l    df *ABS*	00000000 obj/default/trigger.o
00220001 l       .rwdata	00000000 sample_pending
00220002 l       .rwdata	00000000 sample
00182d9c l       .text	00000000 set_sample_rate_done
00182d64 l       .text	00000000 div_check
00182d74 l       .text	00000000 div_done
00182d68 l       .text	00000000 div_loop
00182e60 l       .text	00000000 start_sample_done
00182f08 l       .text	00000000 sample_done_done
00182edc l       .text	00000000 get_data
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00183140 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00183800 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00183964 l     F .text	00000038 alt_dev_reg
00220204 l     O .rwdata	00001060 jtag
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00183c38 l     F .text	00000204 altera_avalon_jtag_uart_irq
00183e3c l     F .text	000000a4 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
001845b8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
001846f0 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0018471c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
001848e0 l     F .text	000000e0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
00184a38 l     F .text	00000050 alt_get_errno
00184a88 l     F .text	000000f0 alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 impure.c
0022140c l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
001838ec g     F .text	00000078 alt_main
00222650 g     O .bss	00000100 alt_irq
00181540 g     F .text	00000048 trg_delay_down
00186064 g       *ABS*	00000000 __flash_rwdata_start
00181038 g     F .text	00000068 display_scale
00181cd8 g     F .text	00000028 trace_rearm
00182e64 g       .text	00000000 sample_done
00180de0 g     F .text	00000020 get_trigger_mode
00180d54 g     F .text	00000020 no_menu_action
00182df0 g       .text	00000000 set_delay
0018309c g     F .text	000000a4 __fixsfsi
00000000  w      *UND*	00000000 __errno
00180000 g     F .entry	0000000c __reset
00180020 g       *ABS*	00000000 __flash_exceptions_start
00182c44 g       .text	00000000 keys_init
001801f4 g     F .text	00000024 no_action
00221898 g     O .bss	00000004 errno
00180000 g       *ABS*	00000000 __alt_mem_rom
001802f8 g     F .text	00000030 menu_right
0018126c g     F .text	00000048 set_trg_level
00221888 g     O .bss	00000004 alt_argv
0018089c g     F .text	00000064 init_menu
0022980c g       *ABS*	00000000 _gp
00181c40 g     F .text	00000020 is_sampling
001802c8 g     F .text	00000030 menu_left
0022128c g     O .rwdata	00000180 alt_fd_list
00184f0c g     F .text	00000090 alt_find_dev
0018524c g     F .text	00000140 memcpy
001849c0 g     F .text	00000078 alt_io_redirect
00181304 g     F .text	00000054 trg_level_up
00185724 g       *ABS*	00000000 __DTOR_END__
00180da0 g     F .text	00000040 set_trigger_mode
00182bf4 g       .text	00000000 plot_pixel
0018403c g     F .text	00000218 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
00183260 g     F .text	00000008 __udivsi3
001824ec g     F .text	00000120 restore_trace
00182414 g     F .text	000000d8 set_save_area
00220000 g       *ABS*	00000000 __alt_mem_ram
00182e1c g       .text	00000000 start_sample
00180f70 g     F .text	00000064 scale_down
00221828 g     O .rwdata	00000004 alt_max_fd
00182d40 g       .text	00000000 key_available
00181204 g     F .text	00000068 display_sweep
00181d2c g     F .text	00000404 set_display_scale
0018260c g     F .text	00000048 do_trace
00221838 g     O .rwdata	00000004 _global_impure_ptr
002228e0 g       *ABS*	00000000 __bss_end
00183710 g     F .text	000000f0 alt_iic_isr_register
00184de8 g     F .text	00000104 alt_tick
00181ba4 g     F .text	00000064 init_trace
001836c4 g     F .text	0000004c alt_ic_irq_enabled
00181500 g     F .text	00000040 set_trg_delay
00184d50 g     F .text	00000098 alt_alarm_stop
00180298 g     F .text	00000030 menu_down
00221880 g     O .bss	00000004 alt_irq_active
00181a78 g     F .text	0000012c get_test_sample
001800ec g     F .exceptions	000000cc alt_irq_handler
00221264 g     O .rwdata	00000028 alt_dev_null
00183470 g     F .text	000000c8 __unpack_f
00180328 g     F .text	000000a8 clear_region
00185724 g     O .rodata	00000380 char_patterns
001846d4 g     F .text	0000001c alt_dcache_flush_all
00180abc g     F .text	0000006c previous_entry
00221840 g       *ABS*	00000000 __ram_rwdata_end
00221820 g     O .rwdata	00000008 alt_dev_list
00181c08 g     F .text	00000038 set_mode
00186064 g       *ABS*	00000000 __ram_rodata_end
00183268 g     F .text	00000008 __umodsi3
00180ec8 g     F .text	00000068 display_mode
002228e0 g       *ABS*	00000000 end
00183344 g     F .text	0000012c __pack_f
00180d74 g     F .text	0000002c no_display
00181358 g     F .text	000000a8 display_trg_level
00181180 g     F .text	00000084 sweep_up
001809f0 g     F .text	0000005c reset_menu
00180900 g     F .text	00000038 clear_menu
00183b78 g     F .text	000000c0 altera_avalon_jtag_uart_init
00181588 g     F .text	0000004c trg_delay_up
00185724 g       *ABS*	00000000 __CTOR_LIST__
00240000 g       *ABS*	00000000 __alt_stack_pointer
00183298 g     F .text	000000ac __clzsi2
00184254 g     F .text	00000224 altera_avalon_jtag_uart_write
00185548 g     F .text	000001a0 __call_exitprocs
001801b8 g     F .text	0000003c _start
00221890 g     O .bss	00000004 _alt_tick_rate
00221894 g     O .bss	00000004 _alt_nticks
00181448 g     F .text	00000054 trg_slope_toggle
001839d0 g     F .text	00000044 alt_sys_init
00182ff8 g     F .text	000000a4 __floatsisf
00185418 g     F .text	00000130 __register_exitproc
00000000 g       *ABS*	00000000 __alt_mem_vram
00183ee0 g     F .text	00000068 altera_avalon_jtag_uart_close
00183270 g     F .text	00000028 __mulsi3
00220000 g       *ABS*	00000000 __ram_rwdata_start
00185724 g       *ABS*	00000000 __ram_rodata_start
00183a14 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
001850b0 g     F .text	000000d4 alt_get_fd
00182b60 g       .text	00000000 clear_display
001851d0 g     F .text	0000007c memcmp
00183ad4 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
002228e0 g       *ABS*	00000000 __alt_stack_base
00183b24 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
00182300 g     F .text	00000114 restore_menu_trace
00184f9c g     F .text	00000114 alt_find_file
0018476c g     F .text	000000a0 alt_dev_llist_insert
00181d00 g     F .text	0000002c set_trace_size
001806cc g     F .text	00000098 plot_string
00221840 g       *ABS*	00000000 __bss_start
00180764 g     F .text	000000ac main
0022188c g     O .bss	00000004 alt_envp
00183a74 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00182654 g     F .text	0000050c plot_trace
00182f40 g       .text	00000000 trigger_init
00222750 g     O .bss	00000190 _atexit0
00181100 g     F .text	00000080 sweep_down
0022182c g     O .rwdata	00000004 alt_errno
00180e00 g     F .text	00000064 mode_down
00182d50 g       .text	00000000 set_sample_rate
001831b4 g     F .text	00000050 __divsi3
00182da0 g       .text	00000000 set_trigger
00185724 g       *ABS*	00000000 __CTOR_END__
001809b8 g     F .text	00000038 refresh_menu
00185724 g       *ABS*	00000000 __flash_rodata_start
00185724 g       *ABS*	00000000 __DTOR_LIST__
00180268 g     F .text	00000030 menu_up
00180bc8 g     F .text	000000a0 menu_entry_right
0018399c g     F .text	00000034 alt_irq_init
00184cd0 g     F .text	00000080 alt_release_fd
00185f3c g     O .rodata	00000100 __clz_tab
00185184 g     F .text	00000014 atexit
00181c98 g     F .text	00000040 trace_done
0022183c g     O .rwdata	00000004 _impure_ptr
00221884 g     O .bss	00000004 alt_argc
00181400 g     F .text	00000048 set_trg_slope
001812b4 g     F .text	00000050 trg_level_down
00184868 g     F .text	0000005c _do_dtors
00182d28 g       .text	00000000 getkey
00180530 g     F .text	0000019c plot_char
00180020 g       .exceptions	00000000 alt_irq_entry
00180b28 g     F .text	000000a0 menu_entry_left
00221818 g     O .rwdata	00000008 alt_fs_list
00182130 g     F .text	000001d0 clear_saved_areas
001803d0 g     F .text	000000b0 plot_hline
00180020 g       *ABS*	00000000 __ram_exceptions_start
00180f30 g     F .text	00000040 set_scale
00183538 g     F .text	00000050 alt_ic_isr_register
00221840 g       *ABS*	00000000 _edata
002228e0 g       *ABS*	00000000 _end
00180e64 g     F .text	00000064 mode_up
001801b8 g       *ABS*	00000000 __ram_exceptions_end
00183f48 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
00183624 g     F .text	000000a0 alt_ic_irq_disable
00184eec g     F .text	00000020 altera_nios2_qsys_irq_init
00185198 g     F .text	00000038 exit
001816a8 g     F .text	00000238 display_trg_delay
00183204 g     F .text	0000005c __modsi3
00240000 g       *ABS*	00000000 __alt_data_end
00180020 g     F .exceptions	00000000 alt_exception
0018149c g     F .text	00000064 display_trg_slope
00182b9c g       .text	00000000 clear_trace_old
00182c9c g       .text	00000000 keys_handler
001856e8 g     F .text	0000003c _exit
00184478 g     F .text	00000140 alt_alarm_start
0018538c g     F .text	0000008c strlen
00184b78 g     F .text	00000158 open
00182f0c g       .text	00000000 sample_handler
001848c4 g     F .text	0000001c alt_icache_flush_all
00221814 g     O .rwdata	00000004 alt_priority_mask
00183588 g     F .text	0000009c alt_ic_irq_enable
00180480 g     F .text	000000b0 plot_vline
00180938 g     F .text	00000080 display_menu
00221830 g     O .rwdata	00000008 alt_alarm_list
0018480c g     F .text	0000005c _do_ctors
00180a4c g     F .text	00000070 next_entry
00184608 g     F .text	000000cc close
00181c60 g     F .text	00000038 trace_rdy
00182c1c g       .text	00000000 pixel_color
0018386c g     F .text	00000080 alt_load
001810a0 g     F .text	00000060 set_sweep
00180fd4 g     F .text	00000064 scale_up
00180218 g     F .text	00000050 menu_key
00000000  w      *UND*	00000000 free



Disassembly of section .entry:

00180000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  180000:	00400634 	movhi	at,24
    ori r1, r1, %lo(_start)
  180004:	08406e14 	ori	at,at,440
    jmp r1
  180008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

00180020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  180020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  180024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  180028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  18002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  180030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  180034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  180038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  18003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  180040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  180044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  180048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  18004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  180050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  180054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  180058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  18005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  180060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  180064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  180068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  18006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  180070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  180074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  180078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  18007c:	10000326 	beq	r2,zero,18008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  180080:	20000226 	beq	r4,zero,18008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  180084:	01800ec0 	call	1800ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  180088:	00000306 	br	180098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  18008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  180090:	e8bfff17 	ldw	r2,-4(ea)

00180094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  180094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  180098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  18009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1800a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1800a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1800a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1800ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1800b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1800b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1800b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1800bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1800c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1800c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1800c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1800cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1800d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1800d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1800d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1800dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1800e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1800e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1800e8:	ef80083a 	eret

001800ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1800ec:	defff904 	addi	sp,sp,-28
  1800f0:	dfc00615 	stw	ra,24(sp)
  1800f4:	df000515 	stw	fp,20(sp)
  1800f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  1800fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  180100:	0005313a 	rdctl	r2,ipending
  180104:	e0bffe15 	stw	r2,-8(fp)

  return active;
  180108:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  18010c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  180110:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  180114:	00800044 	movi	r2,1
  180118:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  18011c:	e0fffb17 	ldw	r3,-20(fp)
  180120:	e0bffc17 	ldw	r2,-16(fp)
  180124:	1884703a 	and	r2,r3,r2
  180128:	10001726 	beq	r2,zero,180188 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  18012c:	00c008b4 	movhi	r3,34
  180130:	18c99404 	addi	r3,r3,9808
  180134:	e0bffd17 	ldw	r2,-12(fp)
  180138:	100490fa 	slli	r2,r2,3
  18013c:	1885883a 	add	r2,r3,r2
  180140:	10c00017 	ldw	r3,0(r2)
  180144:	010008b4 	movhi	r4,34
  180148:	21099404 	addi	r4,r4,9808
  18014c:	e0bffd17 	ldw	r2,-12(fp)
  180150:	100490fa 	slli	r2,r2,3
  180154:	2085883a 	add	r2,r4,r2
  180158:	10800104 	addi	r2,r2,4
  18015c:	10800017 	ldw	r2,0(r2)
  180160:	1009883a 	mov	r4,r2
  180164:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  180168:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  18016c:	0005313a 	rdctl	r2,ipending
  180170:	e0bfff15 	stw	r2,-4(fp)

  return active;
  180174:	e0bfff17 	ldw	r2,-4(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
  180178:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  18017c:	e0bffb17 	ldw	r2,-20(fp)
  180180:	103fe31e 	bne	r2,zero,180110 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  180184:	00000706 	br	1801a4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  180188:	e0bffc17 	ldw	r2,-16(fp)
  18018c:	1085883a 	add	r2,r2,r2
  180190:	e0bffc15 	stw	r2,-16(fp)
      i++;
  180194:	e0bffd17 	ldw	r2,-12(fp)
  180198:	10800044 	addi	r2,r2,1
  18019c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  1801a0:	003fde06 	br	18011c <alt_irq_handler+0x30>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
  1801a4:	e037883a 	mov	sp,fp
  1801a8:	dfc00117 	ldw	ra,4(sp)
  1801ac:	df000017 	ldw	fp,0(sp)
  1801b0:	dec00204 	addi	sp,sp,8
  1801b4:	f800283a 	ret

Disassembly of section .text:

001801b8 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  1801b8:	06c00934 	movhi	sp,36
    ori sp, sp, %lo(__alt_stack_pointer)
  1801bc:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
  1801c0:	068008b4 	movhi	gp,34
    ori gp, gp, %lo(_gp)
  1801c4:	d6a60314 	ori	gp,gp,38924
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  1801c8:	008008b4 	movhi	r2,34
    ori r2, r2, %lo(__bss_start)
  1801cc:	10861014 	ori	r2,r2,6208

    movhi r3, %hi(__bss_end)
  1801d0:	00c008b4 	movhi	r3,34
    ori r3, r3, %lo(__bss_end)
  1801d4:	18ca3814 	ori	r3,r3,10464

    beq r2, r3, 1f
  1801d8:	10c00326 	beq	r2,r3,1801e8 <_start+0x30>

0:
    stw zero, (r2)
  1801dc:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  1801e0:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  1801e4:	10fffd36 	bltu	r2,r3,1801dc <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  1801e8:	018386c0 	call	18386c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  1801ec:	01838ec0 	call	1838ec <alt_main>

001801f0 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  1801f0:	003fff06 	br	1801f0 <alt_after_alt_main>

001801f4 <no_action>:
   Last Modified:    Mar. 8, 1994

*/

enum status  no_action(enum status cur_state)
{
  1801f4:	defffe04 	addi	sp,sp,-8
  1801f8:	df000115 	stw	fp,4(sp)
  1801fc:	df000104 	addi	fp,sp,4
  180200:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* return the current state */
    return  cur_state;
  180204:	e0bfff17 	ldw	r2,-4(fp)

}
  180208:	e037883a 	mov	sp,fp
  18020c:	df000017 	ldw	fp,0(sp)
  180210:	dec00104 	addi	sp,sp,4
  180214:	f800283a 	ret

00180218 <menu_key>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_key(enum status cur_state)
{
  180218:	defffd04 	addi	sp,sp,-12
  18021c:	dfc00215 	stw	ra,8(sp)
  180220:	df000115 	stw	fp,4(sp)
  180224:	df000104 	addi	fp,sp,4
  180228:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* check if need to turn the menu on or off */
    if (cur_state == MENU_ON)
  18022c:	e0bfff17 	ldw	r2,-4(fp)
  180230:	1000021e 	bne	r2,zero,18023c <menu_key+0x24>
        /* currently the menu is on, turn it off */
	clear_menu();
  180234:	01809000 	call	180900 <clear_menu>
  180238:	00000106 	br	180240 <menu_key+0x28>
    else
        /* currently the menu is off, turn it on */
	display_menu();
  18023c:	01809380 	call	180938 <display_menu>


    /* all done, return the "opposite" of the current state */
    if (cur_state == MENU_ON)
  180240:	e0bfff17 	ldw	r2,-4(fp)
  180244:	1000021e 	bne	r2,zero,180250 <menu_key+0x38>
        /* state was MENU_ON, change it to MENU_OFF */
        return  MENU_OFF;
  180248:	00800044 	movi	r2,1
  18024c:	00000106 	br	180254 <menu_key+0x3c>
    else
        /* state was MENU_OFF, change it to MENU_ON */
        return  MENU_ON;
  180250:	0005883a 	mov	r2,zero

}
  180254:	e037883a 	mov	sp,fp
  180258:	dfc00117 	ldw	ra,4(sp)
  18025c:	df000017 	ldw	fp,0(sp)
  180260:	dec00204 	addi	sp,sp,8
  180264:	f800283a 	ret

00180268 <menu_up>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_up(enum status cur_state)
{
  180268:	defffd04 	addi	sp,sp,-12
  18026c:	dfc00215 	stw	ra,8(sp)
  180270:	df000115 	stw	fp,4(sp)
  180274:	df000104 	addi	fp,sp,4
  180278:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* go to the previous menu entry */
    previous_entry();
  18027c:	0180abc0 	call	180abc <previous_entry>


    /* return the current state */
    return  cur_state;
  180280:	e0bfff17 	ldw	r2,-4(fp)

}
  180284:	e037883a 	mov	sp,fp
  180288:	dfc00117 	ldw	ra,4(sp)
  18028c:	df000017 	ldw	fp,0(sp)
  180290:	dec00204 	addi	sp,sp,8
  180294:	f800283a 	ret

00180298 <menu_down>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_down(enum status cur_state)
{
  180298:	defffd04 	addi	sp,sp,-12
  18029c:	dfc00215 	stw	ra,8(sp)
  1802a0:	df000115 	stw	fp,4(sp)
  1802a4:	df000104 	addi	fp,sp,4
  1802a8:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* go to the next menu entry */
    next_entry();
  1802ac:	0180a4c0 	call	180a4c <next_entry>


    /* return the current state */
    return  cur_state;
  1802b0:	e0bfff17 	ldw	r2,-4(fp)

}
  1802b4:	e037883a 	mov	sp,fp
  1802b8:	dfc00117 	ldw	ra,4(sp)
  1802bc:	df000017 	ldw	fp,0(sp)
  1802c0:	dec00204 	addi	sp,sp,8
  1802c4:	f800283a 	ret

001802c8 <menu_left>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_left(enum status cur_state)
{
  1802c8:	defffd04 	addi	sp,sp,-12
  1802cc:	dfc00215 	stw	ra,8(sp)
  1802d0:	df000115 	stw	fp,4(sp)
  1802d4:	df000104 	addi	fp,sp,4
  1802d8:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* invoke the <Left> key function for the current menu entry */
    menu_entry_left();
  1802dc:	0180b280 	call	180b28 <menu_entry_left>


    /* return the current state */
    return  cur_state;
  1802e0:	e0bfff17 	ldw	r2,-4(fp)

}
  1802e4:	e037883a 	mov	sp,fp
  1802e8:	dfc00117 	ldw	ra,4(sp)
  1802ec:	df000017 	ldw	fp,0(sp)
  1802f0:	dec00204 	addi	sp,sp,8
  1802f4:	f800283a 	ret

001802f8 <menu_right>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_right(enum status cur_state)
{
  1802f8:	defffd04 	addi	sp,sp,-12
  1802fc:	dfc00215 	stw	ra,8(sp)
  180300:	df000115 	stw	fp,4(sp)
  180304:	df000104 	addi	fp,sp,4
  180308:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* invoke the <Right> key function for the current menu entry */
    menu_entry_right();
  18030c:	0180bc80 	call	180bc8 <menu_entry_right>


    /* return the current state */
    return  cur_state;
  180310:	e0bfff17 	ldw	r2,-4(fp)

}
  180314:	e037883a 	mov	sp,fp
  180318:	dfc00117 	ldw	ra,4(sp)
  18031c:	df000017 	ldw	fp,0(sp)
  180320:	dec00204 	addi	sp,sp,8
  180324:	f800283a 	ret

00180328 <clear_region>:
   Last Modified:    June 03, 2014

*/

void  clear_region(int x_ul, int y_ul, int x_size, int y_size)
{
  180328:	defff804 	addi	sp,sp,-32
  18032c:	dfc00715 	stw	ra,28(sp)
  180330:	df000615 	stw	fp,24(sp)
  180334:	df000604 	addi	fp,sp,24
  180338:	e13ffc15 	stw	r4,-16(fp)
  18033c:	e17ffd15 	stw	r5,-12(fp)
  180340:	e1bffe15 	stw	r6,-8(fp)
  180344:	e1ffff15 	stw	r7,-4(fp)
    int  y;		/* y coordinate to clear */



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
  180348:	e0bffc17 	ldw	r2,-16(fp)
  18034c:	e0bffa15 	stw	r2,-24(fp)
  180350:	00001406 	br	1803a4 <clear_region+0x7c>
        for (y = y_ul; y < (y_ul + y_size); y++)  {
  180354:	e0bffd17 	ldw	r2,-12(fp)
  180358:	e0bffb15 	stw	r2,-20(fp)
  18035c:	00000906 	br	180384 <clear_region+0x5c>

	    /* clear this pixel */
	    plot_pixel(x, y, PIXEL_CLEAR);
  180360:	e0fffa17 	ldw	r3,-24(fp)
  180364:	e0bffb17 	ldw	r2,-20(fp)
  180368:	1809883a 	mov	r4,r3
  18036c:	100b883a 	mov	r5,r2
  180370:	000d883a 	mov	r6,zero
  180374:	0182bf40 	call	182bf4 <plot_pixel>



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
        for (y = y_ul; y < (y_ul + y_size); y++)  {
  180378:	e0bffb17 	ldw	r2,-20(fp)
  18037c:	10800044 	addi	r2,r2,1
  180380:	e0bffb15 	stw	r2,-20(fp)
  180384:	e0fffd17 	ldw	r3,-12(fp)
  180388:	e0bfff17 	ldw	r2,-4(fp)
  18038c:	1885883a 	add	r2,r3,r2
  180390:	e0fffb17 	ldw	r3,-20(fp)
  180394:	18bff216 	blt	r3,r2,180360 <clear_region+0x38>
    int  y;		/* y coordinate to clear */



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
  180398:	e0bffa17 	ldw	r2,-24(fp)
  18039c:	10800044 	addi	r2,r2,1
  1803a0:	e0bffa15 	stw	r2,-24(fp)
  1803a4:	e0fffc17 	ldw	r3,-16(fp)
  1803a8:	e0bffe17 	ldw	r2,-8(fp)
  1803ac:	1885883a 	add	r2,r3,r2
  1803b0:	e0fffa17 	ldw	r3,-24(fp)
  1803b4:	18bfe716 	blt	r3,r2,180354 <clear_region+0x2c>
        }
    }


    /* done clearing the display region - return */
    return;
  1803b8:	0001883a 	nop

}
  1803bc:	e037883a 	mov	sp,fp
  1803c0:	dfc00117 	ldw	ra,4(sp)
  1803c4:	df000017 	ldw	fp,0(sp)
  1803c8:	dec00204 	addi	sp,sp,8
  1803cc:	f800283a 	ret

001803d0 <plot_hline>:
   Last Modified:    June 03, 2014

*/

void  plot_hline(int start_x, int start_y, int length)
{
  1803d0:	defff804 	addi	sp,sp,-32
  1803d4:	dfc00715 	stw	ra,28(sp)
  1803d8:	df000615 	stw	fp,24(sp)
  1803dc:	df000604 	addi	fp,sp,24
  1803e0:	e13ffd15 	stw	r4,-12(fp)
  1803e4:	e17ffe15 	stw	r5,-8(fp)
  1803e8:	e1bfff15 	stw	r6,-4(fp)
    int  end_x;		/* ending x position to plot */



    /* check if a line to the "right" or "left" */
    if (length > 0)  {
  1803ec:	e0bfff17 	ldw	r2,-4(fp)
  1803f0:	0080070e 	bge	zero,r2,180410 <plot_hline+0x40>

        /* line to the "right" - start at start_x, end at start_x + length */
	init_x = start_x;
  1803f4:	e0bffd17 	ldw	r2,-12(fp)
  1803f8:	e0bffb15 	stw	r2,-20(fp)
	end_x = start_x + length;
  1803fc:	e0fffd17 	ldw	r3,-12(fp)
  180400:	e0bfff17 	ldw	r2,-4(fp)
  180404:	1885883a 	add	r2,r3,r2
  180408:	e0bffc15 	stw	r2,-16(fp)
  18040c:	00000606 	br	180428 <plot_hline+0x58>
    }
    else  {

        /* line to the "left" - start at start_x + length, end at start_x */
	init_x = start_x + length;
  180410:	e0fffd17 	ldw	r3,-12(fp)
  180414:	e0bfff17 	ldw	r2,-4(fp)
  180418:	1885883a 	add	r2,r3,r2
  18041c:	e0bffb15 	stw	r2,-20(fp)
	end_x = start_x;
  180420:	e0bffd17 	ldw	r2,-12(fp)
  180424:	e0bffc15 	stw	r2,-16(fp)
    }


    /* loop, outputting points for the line (always draw to the "right") */
    for (x = init_x; x < end_x; x++)
  180428:	e0bffb17 	ldw	r2,-20(fp)
  18042c:	e0bffa15 	stw	r2,-24(fp)
  180430:	00000a06 	br	18045c <plot_hline+0x8c>
        /* plot a point of the line */
	plot_pixel(x, start_y, PIXEL_LINE);
  180434:	e0fffa17 	ldw	r3,-24(fp)
  180438:	e0bffe17 	ldw	r2,-8(fp)
  18043c:	1809883a 	mov	r4,r3
  180440:	100b883a 	mov	r5,r2
  180444:	018006f4 	movhi	r6,27
  180448:	318e0c04 	addi	r6,r6,14384
  18044c:	0182bf40 	call	182bf4 <plot_pixel>
	end_x = start_x;
    }


    /* loop, outputting points for the line (always draw to the "right") */
    for (x = init_x; x < end_x; x++)
  180450:	e0bffa17 	ldw	r2,-24(fp)
  180454:	10800044 	addi	r2,r2,1
  180458:	e0bffa15 	stw	r2,-24(fp)
  18045c:	e0fffa17 	ldw	r3,-24(fp)
  180460:	e0bffc17 	ldw	r2,-16(fp)
  180464:	18bff316 	blt	r3,r2,180434 <plot_hline+0x64>
        /* plot a point of the line */
	plot_pixel(x, start_y, PIXEL_LINE);


    /* done plotting the line - return */
    return;
  180468:	0001883a 	nop

}
  18046c:	e037883a 	mov	sp,fp
  180470:	dfc00117 	ldw	ra,4(sp)
  180474:	df000017 	ldw	fp,0(sp)
  180478:	dec00204 	addi	sp,sp,8
  18047c:	f800283a 	ret

00180480 <plot_vline>:
   Last Modified:    June 03, 2014

*/

void  plot_vline(int start_x, int start_y, int length)
{
  180480:	defff804 	addi	sp,sp,-32
  180484:	dfc00715 	stw	ra,28(sp)
  180488:	df000615 	stw	fp,24(sp)
  18048c:	df000604 	addi	fp,sp,24
  180490:	e13ffd15 	stw	r4,-12(fp)
  180494:	e17ffe15 	stw	r5,-8(fp)
  180498:	e1bfff15 	stw	r6,-4(fp)
    int  end_y;		/* ending y position to plot */



    /* check if an "up" or "down" line */
    if (length > 0)  {
  18049c:	e0bfff17 	ldw	r2,-4(fp)
  1804a0:	0080070e 	bge	zero,r2,1804c0 <plot_vline+0x40>

        /* line going "down" - start at start_y, end at start_y + length */
	init_y = start_y;
  1804a4:	e0bffe17 	ldw	r2,-8(fp)
  1804a8:	e0bffb15 	stw	r2,-20(fp)
	end_y = start_y + length;
  1804ac:	e0fffe17 	ldw	r3,-8(fp)
  1804b0:	e0bfff17 	ldw	r2,-4(fp)
  1804b4:	1885883a 	add	r2,r3,r2
  1804b8:	e0bffc15 	stw	r2,-16(fp)
  1804bc:	00000606 	br	1804d8 <plot_vline+0x58>
    }
    else  {

        /* line going "up" - start at start_y + length, end at start_y */
	init_y = start_y + length;
  1804c0:	e0fffe17 	ldw	r3,-8(fp)
  1804c4:	e0bfff17 	ldw	r2,-4(fp)
  1804c8:	1885883a 	add	r2,r3,r2
  1804cc:	e0bffb15 	stw	r2,-20(fp)
	end_y = start_y;
  1804d0:	e0bffe17 	ldw	r2,-8(fp)
  1804d4:	e0bffc15 	stw	r2,-16(fp)
    }


    /* loop, outputting points for the line (always draw "down") */
    for (y = init_y; y < end_y; y++)
  1804d8:	e0bffb17 	ldw	r2,-20(fp)
  1804dc:	e0bffa15 	stw	r2,-24(fp)
  1804e0:	00000a06 	br	18050c <plot_vline+0x8c>
        /* plot a point of the line */
	plot_pixel(start_x, y, PIXEL_LINE);
  1804e4:	e0fffd17 	ldw	r3,-12(fp)
  1804e8:	e0bffa17 	ldw	r2,-24(fp)
  1804ec:	1809883a 	mov	r4,r3
  1804f0:	100b883a 	mov	r5,r2
  1804f4:	018006f4 	movhi	r6,27
  1804f8:	318e0c04 	addi	r6,r6,14384
  1804fc:	0182bf40 	call	182bf4 <plot_pixel>
	end_y = start_y;
    }


    /* loop, outputting points for the line (always draw "down") */
    for (y = init_y; y < end_y; y++)
  180500:	e0bffa17 	ldw	r2,-24(fp)
  180504:	10800044 	addi	r2,r2,1
  180508:	e0bffa15 	stw	r2,-24(fp)
  18050c:	e0fffa17 	ldw	r3,-24(fp)
  180510:	e0bffc17 	ldw	r2,-16(fp)
  180514:	18bff316 	blt	r3,r2,1804e4 <plot_vline+0x64>
        /* plot a point of the line */
	plot_pixel(start_x, y, PIXEL_LINE);


    /* done plotting the line - return */
    return;
  180518:	0001883a 	nop

}
  18051c:	e037883a 	mov	sp,fp
  180520:	dfc00117 	ldw	ra,4(sp)
  180524:	df000017 	ldw	fp,0(sp)
  180528:	dec00204 	addi	sp,sp,8
  18052c:	f800283a 	ret

00180530 <plot_char>:
   Last Modified:    June 03, 2014

*/

void  plot_char(int pos_x, int pos_y, char c, enum char_style style)
{
  180530:	defff404 	addi	sp,sp,-48
  180534:	dfc00b15 	stw	ra,44(sp)
  180538:	df000a15 	stw	fp,40(sp)
  18053c:	df000a04 	addi	fp,sp,40
  180540:	e13ffc15 	stw	r4,-16(fp)
  180544:	e17ffd15 	stw	r5,-12(fp)
  180548:	3005883a 	mov	r2,r6
  18054c:	e1ffff15 	stw	r7,-4(fp)
  180550:	e0bffe05 	stb	r2,-8(fp)
    int  row;           /* character row loop index */

    int  x;		/* x pixel position for the character */
    int  y;		/* y pixel position for the character */

    int color = PIXEL_TEXT_N; /* pixel drawing color */
  180554:	008006f4 	movhi	r2,27
  180558:	108e0c04 	addi	r2,r2,14384
  18055c:	e0bffa15 	stw	r2,-24(fp)



    /* setup the pixel positions for the character */
    x = pos_x * HORIZ_SIZE;
  180560:	e13ffc17 	ldw	r4,-16(fp)
  180564:	01400184 	movi	r5,6
  180568:	01832700 	call	183270 <__mulsi3>
  18056c:	e0bffb15 	stw	r2,-20(fp)
    y = pos_y * VERT_SIZE;
  180570:	e0bffd17 	ldw	r2,-12(fp)
  180574:	100490fa 	slli	r2,r2,3
  180578:	e0bff915 	stw	r2,-28(fp)


    /* loop outputting the bits to the screen */
    for (row = 0; row < VERT_SIZE; row++)  {
  18057c:	e03ff815 	stw	zero,-32(fp)
  180580:	00004906 	br	1806a8 <plot_char+0x178>

        /* get the character bits for this row from the character table */
	if (row == (VERT_SIZE - 1))
  180584:	e0bff817 	ldw	r2,-32(fp)
  180588:	108001d8 	cmpnei	r2,r2,7
  18058c:	1000021e 	bne	r2,zero,180598 <plot_char+0x68>
	    /* last row - blank it */
	    bits = 0;
  180590:	e03ff615 	stw	zero,-40(fp)
  180594:	00000d06 	br	1805cc <plot_char+0x9c>
	else
	    /* in middle of character, get the row from the bit patterns */
            bits = char_patterns[(c * (VERT_SIZE - 1)) + row];
  180598:	e0bffe07 	ldb	r2,-8(fp)
  18059c:	1009883a 	mov	r4,r2
  1805a0:	014001c4 	movi	r5,7
  1805a4:	01832700 	call	183270 <__mulsi3>
  1805a8:	1007883a 	mov	r3,r2
  1805ac:	e0bff817 	ldw	r2,-32(fp)
  1805b0:	1885883a 	add	r2,r3,r2
  1805b4:	00c00634 	movhi	r3,24
  1805b8:	18d5c904 	addi	r3,r3,22308
  1805bc:	1885883a 	add	r2,r3,r2
  1805c0:	10800003 	ldbu	r2,0(r2)
  1805c4:	10803fcc 	andi	r2,r2,255
  1805c8:	e0bff615 	stw	r2,-40(fp)

	/* take care of "normal/reverse video" */
	if (style == REVERSE)
  1805cc:	e0bfff17 	ldw	r2,-4(fp)
  1805d0:	10800058 	cmpnei	r2,r2,1
  1805d4:	1000031e 	bne	r2,zero,1805e4 <plot_char+0xb4>
	    /* invert the bits for "reverse video" */
	    bits = ~bits;
  1805d8:	e0bff617 	ldw	r2,-40(fp)
  1805dc:	0084303a 	nor	r2,zero,r2
  1805e0:	e0bff615 	stw	r2,-40(fp)
  if (style == HIGHLIGHTED)
  1805e4:	e0bfff17 	ldw	r2,-4(fp)
  1805e8:	10800098 	cmpnei	r2,r2,2
  1805ec:	1000031e 	bne	r2,zero,1805fc <plot_char+0xcc>
      color = PIXEL_TEXT_H;
  1805f0:	00804034 	movhi	r2,256
  1805f4:	10bfffc4 	addi	r2,r2,-1
  1805f8:	e0bffa15 	stw	r2,-24(fp)

        /* get the bits "in position" (high bit is output first */
	bits <<= (8 - HORIZ_SIZE);
  1805fc:	e0bff617 	ldw	r2,-40(fp)
  180600:	1085883a 	add	r2,r2,r2
  180604:	1085883a 	add	r2,r2,r2
  180608:	e0bff615 	stw	r2,-40(fp)


	/* now output the row of the character, pixel by pixel */
	for (col = 0; col < HORIZ_SIZE; col++)  {
  18060c:	e03ff715 	stw	zero,-36(fp)
  180610:	00001c06 	br	180684 <plot_char+0x154>

            /* output this pixel in the appropriate color */
	    if ((bits & 0x80) == 0)
  180614:	e0bff617 	ldw	r2,-40(fp)
  180618:	1080200c 	andi	r2,r2,128
  18061c:	10000a1e 	bne	r2,zero,180648 <plot_char+0x118>
	        /* blank pixel - output in PIXEL_CLEAR */
		plot_pixel(x + col, y, PIXEL_CLEAR);
  180620:	e0fffb17 	ldw	r3,-20(fp)
  180624:	e0bff717 	ldw	r2,-36(fp)
  180628:	1885883a 	add	r2,r3,r2
  18062c:	1007883a 	mov	r3,r2
  180630:	e0bff917 	ldw	r2,-28(fp)
  180634:	1809883a 	mov	r4,r3
  180638:	100b883a 	mov	r5,r2
  18063c:	000d883a 	mov	r6,zero
  180640:	0182bf40 	call	182bf4 <plot_pixel>
  180644:	00000906 	br	18066c <plot_char+0x13c>
	    else
	        /* black pixel - output in PIXEL_TEXT */
		plot_pixel(x + col, y, color);
  180648:	e0fffb17 	ldw	r3,-20(fp)
  18064c:	e0bff717 	ldw	r2,-36(fp)
  180650:	1885883a 	add	r2,r3,r2
  180654:	1007883a 	mov	r3,r2
  180658:	e0bff917 	ldw	r2,-28(fp)
  18065c:	1809883a 	mov	r4,r3
  180660:	100b883a 	mov	r5,r2
  180664:	e1bffa17 	ldw	r6,-24(fp)
  180668:	0182bf40 	call	182bf4 <plot_pixel>

	    /* shift the next bit into position */
	    bits <<= 1;
  18066c:	e0bff617 	ldw	r2,-40(fp)
  180670:	1085883a 	add	r2,r2,r2
  180674:	e0bff615 	stw	r2,-40(fp)
        /* get the bits "in position" (high bit is output first */
	bits <<= (8 - HORIZ_SIZE);


	/* now output the row of the character, pixel by pixel */
	for (col = 0; col < HORIZ_SIZE; col++)  {
  180678:	e0bff717 	ldw	r2,-36(fp)
  18067c:	10800044 	addi	r2,r2,1
  180680:	e0bff715 	stw	r2,-36(fp)
  180684:	e0bff717 	ldw	r2,-36(fp)
  180688:	10800190 	cmplti	r2,r2,6
  18068c:	103fe11e 	bne	r2,zero,180614 <plot_char+0xe4>
	    bits <<= 1;
        }


	/* next row - update the y position */
	y++;
  180690:	e0bff917 	ldw	r2,-28(fp)
  180694:	10800044 	addi	r2,r2,1
  180698:	e0bff915 	stw	r2,-28(fp)
    x = pos_x * HORIZ_SIZE;
    y = pos_y * VERT_SIZE;


    /* loop outputting the bits to the screen */
    for (row = 0; row < VERT_SIZE; row++)  {
  18069c:	e0bff817 	ldw	r2,-32(fp)
  1806a0:	10800044 	addi	r2,r2,1
  1806a4:	e0bff815 	stw	r2,-32(fp)
  1806a8:	e0bff817 	ldw	r2,-32(fp)
  1806ac:	10800210 	cmplti	r2,r2,8
  1806b0:	103fb41e 	bne	r2,zero,180584 <plot_char+0x54>
	y++;
    }


    /* all done, return */
    return;
  1806b4:	0001883a 	nop

}
  1806b8:	e037883a 	mov	sp,fp
  1806bc:	dfc00117 	ldw	ra,4(sp)
  1806c0:	df000017 	ldw	fp,0(sp)
  1806c4:	dec00204 	addi	sp,sp,8
  1806c8:	f800283a 	ret

001806cc <plot_string>:
   Last Modified:    Mar. 17, 1997

*/

void  plot_string(int pos_x, int pos_y, const char *s, enum char_style style)
{
  1806cc:	defffa04 	addi	sp,sp,-24
  1806d0:	dfc00515 	stw	ra,20(sp)
  1806d4:	df000415 	stw	fp,16(sp)
  1806d8:	df000404 	addi	fp,sp,16
  1806dc:	e13ffc15 	stw	r4,-16(fp)
  1806e0:	e17ffd15 	stw	r5,-12(fp)
  1806e4:	e1bffe15 	stw	r6,-8(fp)
  1806e8:	e1ffff15 	stw	r7,-4(fp)
      /* none */



    /* loop, outputting characters from string s */
    while (*s != '\0')
  1806ec:	00001106 	br	180734 <plot_string+0x68>

        /* output this character and move to the next character and screen position */
	plot_char(pos_x++, pos_y, *s++, style);
  1806f0:	e0fffc17 	ldw	r3,-16(fp)
  1806f4:	e0bffc17 	ldw	r2,-16(fp)
  1806f8:	10800044 	addi	r2,r2,1
  1806fc:	e0bffc15 	stw	r2,-16(fp)
  180700:	e0bffe17 	ldw	r2,-8(fp)
  180704:	10800003 	ldbu	r2,0(r2)
  180708:	10803fcc 	andi	r2,r2,255
  18070c:	1080201c 	xori	r2,r2,128
  180710:	10bfe004 	addi	r2,r2,-128
  180714:	e13ffe17 	ldw	r4,-8(fp)
  180718:	21000044 	addi	r4,r4,1
  18071c:	e13ffe15 	stw	r4,-8(fp)
  180720:	1809883a 	mov	r4,r3
  180724:	e17ffd17 	ldw	r5,-12(fp)
  180728:	100d883a 	mov	r6,r2
  18072c:	e1ffff17 	ldw	r7,-4(fp)
  180730:	01805300 	call	180530 <plot_char>
      /* none */



    /* loop, outputting characters from string s */
    while (*s != '\0')
  180734:	e0bffe17 	ldw	r2,-8(fp)
  180738:	10800003 	ldbu	r2,0(r2)
  18073c:	10803fcc 	andi	r2,r2,255
  180740:	1080201c 	xori	r2,r2,128
  180744:	10bfe004 	addi	r2,r2,-128
  180748:	103fe91e 	bne	r2,zero,1806f0 <plot_string+0x24>
        /* output this character and move to the next character and screen position */
	plot_char(pos_x++, pos_y, *s++, style);


    /* all done, return */
    return;
  18074c:	0001883a 	nop

}
  180750:	e037883a 	mov	sp,fp
  180754:	dfc00117 	ldw	ra,4(sp)
  180758:	df000017 	ldw	fp,0(sp)
  18075c:	dec00204 	addi	sp,sp,8
  180760:	f800283a 	ret

00180764 <main>:
   Last Modified:    June 11, 2014

*/

int  main()
{
  180764:	defffb04 	addi	sp,sp,-20
  180768:	dfc00415 	stw	ra,16(sp)
  18076c:	df000315 	stw	fp,12(sp)
  180770:	df000304 	addi	fp,sp,12
    /* initialize keys, triggering */
	  keys_init();
  180774:	0182c440 	call	182c44 <keys_init>
	  trigger_init();
  180778:	0182f400 	call	182f40 <trigger_init>
    
    /* variables */
    enum keycode        key;		    /* an input key */

    enum status
    state = MENU_ON;    /* current program state */
  18077c:	e03ffd15 	stw	zero,-12(fp)
        {  no_action,   no_action   } }; /* illegal key */



    /* first initialize everything */
    clear_display();		/* clear the display */
  180780:	0182b600 	call	182b60 <clear_display>

    init_trace();		/* initialize the trace routines */
  180784:	0181ba40 	call	181ba4 <init_trace>
    init_menu();		/* initialize the menu system */
  180788:	018089c0 	call	18089c <init_menu>
  18078c:	00000106 	br	180794 <main+0x30>
	    key = key_lookup();

	    /* execute processing routine for that key */
	    state = process_key[key][state](state);
	}
    }
  180790:	0001883a 	nop

    /* infinite loop processing input */
    while(TRUE)  {

        /* check if ready to do a trace */
	if (trace_rdy())
  180794:	0181c600 	call	181c60 <trace_rdy>
  180798:	10000126 	beq	r2,zero,1807a0 <main+0x3c>
	    /* ready for a trace - do it */
	    do_trace();
  18079c:	018260c0 	call	18260c <do_trace>


	/* check if have a trace to display */
	if (is_sampling() && ((sample = sample_done()) != NULL))  {
  1807a0:	0181c400 	call	181c40 <is_sampling>
  1807a4:	10000726 	beq	r2,zero,1807c4 <main+0x60>
  1807a8:	0182e640 	call	182e64 <sample_done>
  1807ac:	e0bffe15 	stw	r2,-8(fp)
  1807b0:	e0bffe17 	ldw	r2,-8(fp)
  1807b4:	10000326 	beq	r2,zero,1807c4 <main+0x60>

	    /* have a trace - output it */
	    plot_trace(sample);
  1807b8:	e13ffe17 	ldw	r4,-8(fp)
  1807bc:	01826540 	call	182654 <plot_trace>

	    /* sleep for some time to reduce blinking of display */
	    /*usleep(DRAW_INTERVAL);

	    /* done processing this trace */
	    trace_done();
  1807c0:	0181c980 	call	181c98 <trace_done>
	}


	/* now check for keypad input */
	if (key_available())  {
  1807c4:	0182d400 	call	182d40 <key_available>
  1807c8:	10803fcc 	andi	r2,r2,255
  1807cc:	103ff026 	beq	r2,zero,180790 <main+0x2c>

	    /* have keypad input - get the key */
	    key = key_lookup();
  1807d0:	01808100 	call	180810 <key_lookup>
  1807d4:	e0bfff15 	stw	r2,-4(fp)

	    /* execute processing routine for that key */
	    state = process_key[key][state](state);
  1807d8:	00c00634 	movhi	r3,24
  1807dc:	18d6b404 	addi	r3,r3,23248
  1807e0:	e0bfff17 	ldw	r2,-4(fp)
  1807e4:	1089883a 	add	r4,r2,r2
  1807e8:	e0bffd17 	ldw	r2,-12(fp)
  1807ec:	2085883a 	add	r2,r4,r2
  1807f0:	1085883a 	add	r2,r2,r2
  1807f4:	1085883a 	add	r2,r2,r2
  1807f8:	1885883a 	add	r2,r3,r2
  1807fc:	10800017 	ldw	r2,0(r2)
  180800:	e13ffd17 	ldw	r4,-12(fp)
  180804:	103ee83a 	callr	r2
  180808:	e0bffd15 	stw	r2,-12(fp)
	}
    }
  18080c:	003fe006 	br	180790 <main+0x2c>

00180810 <key_lookup>:
   Last Modified:    Mar. 17, 1997

*/

static  enum keycode  key_lookup()
{
  180810:	defffc04 	addi	sp,sp,-16
  180814:	dfc00315 	stw	ra,12(sp)
  180818:	df000215 	stw	fp,8(sp)
  18081c:	df000204 	addi	fp,sp,8
    int  i;           	/* general loop index */



    /* get a key */
    key = getkey();
  180820:	0182d280 	call	182d28 <getkey>
  180824:	e0bfff15 	stw	r2,-4(fp)


    /* lookup key in keys array */
    for (i = 0; ((i < (sizeof(keys)/sizeof(int))) && (key != keys[i])); i++);
  180828:	e03ffe15 	stw	zero,-8(fp)
  18082c:	00000306 	br	18083c <key_lookup+0x2c>
  180830:	e0bffe17 	ldw	r2,-8(fp)
  180834:	10800044 	addi	r2,r2,1
  180838:	e0bffe15 	stw	r2,-8(fp)
  18083c:	e0bffe17 	ldw	r2,-8(fp)
  180840:	10800168 	cmpgeui	r2,r2,5
  180844:	1000091e 	bne	r2,zero,18086c <key_lookup+0x5c>
  180848:	00c00634 	movhi	r3,24
  18084c:	18d6a904 	addi	r3,r3,23204
  180850:	e0bffe17 	ldw	r2,-8(fp)
  180854:	1085883a 	add	r2,r2,r2
  180858:	1085883a 	add	r2,r2,r2
  18085c:	1885883a 	add	r2,r3,r2
  180860:	10c00017 	ldw	r3,0(r2)
  180864:	e0bfff17 	ldw	r2,-4(fp)
  180868:	18bff11e 	bne	r3,r2,180830 <key_lookup+0x20>


    /* return the appropriate key type */
    return  keycodes[i];
  18086c:	00c00634 	movhi	r3,24
  180870:	18d6ae04 	addi	r3,r3,23224
  180874:	e0bffe17 	ldw	r2,-8(fp)
  180878:	1085883a 	add	r2,r2,r2
  18087c:	1085883a 	add	r2,r2,r2
  180880:	1885883a 	add	r2,r3,r2
  180884:	10800017 	ldw	r2,0(r2)

}
  180888:	e037883a 	mov	sp,fp
  18088c:	dfc00117 	ldw	ra,4(sp)
  180890:	df000017 	ldw	fp,0(sp)
  180894:	dec00204 	addi	sp,sp,8
  180898:	f800283a 	ret

0018089c <init_menu>:
   Last Modified:    Mar. 17, 1997

*/

void  init_menu(void)
{
  18089c:	defffe04 	addi	sp,sp,-8
  1808a0:	dfc00115 	stw	ra,4(sp)
  1808a4:	df000015 	stw	fp,0(sp)
  1808a8:	d839883a 	mov	fp,sp
      /* none */



    /* set the menu parameters */
    menu_entry = 0;		/* first menu entry */
  1808ac:	d0200e15 	stw	zero,-32712(gp)
    menu_display = FALSE;	/* menu is not currently displayed (but it will be shortly) */
  1808b0:	d0200d15 	stw	zero,-32716(gp)


    /* set the scope (option) parameters */
    set_trigger_mode(NORMAL_TRIGGER);	/* normal triggering */
  1808b4:	0009883a 	mov	r4,zero
  1808b8:	0180da00 	call	180da0 <set_trigger_mode>
    set_scale(SCALE_AXES);		/* scale is axes */
  1808bc:	01000044 	movi	r4,1
  1808c0:	0180f300 	call	180f30 <set_scale>
    set_sweep(0);			/* first sweep rate */
  1808c4:	0009883a 	mov	r4,zero
  1808c8:	01810a00 	call	1810a0 <set_sweep>
    set_trg_level((MIN_TRG_LEVEL_SET + MAX_TRG_LEVEL_SET) / 2);	/* middle trigger level */
  1808cc:	01000fc4 	movi	r4,63
  1808d0:	018126c0 	call	18126c <set_trg_level>
    set_trg_slope(SLOPE_POSITIVE);	/* positive slope */
  1808d4:	0009883a 	mov	r4,zero
  1808d8:	01814000 	call	181400 <set_trg_slope>
    set_trg_delay(MIN_DELAY);		/* minimum delay */
  1808dc:	0009883a 	mov	r4,zero
  1808e0:	01815000 	call	181500 <set_trg_delay>


    /* now display the menu */
    display_menu();
  1808e4:	01809380 	call	180938 <display_menu>


    /* done initializing, return */
    return;
  1808e8:	0001883a 	nop

}
  1808ec:	e037883a 	mov	sp,fp
  1808f0:	dfc00117 	ldw	ra,4(sp)
  1808f4:	df000017 	ldw	fp,0(sp)
  1808f8:	dec00204 	addi	sp,sp,8
  1808fc:	f800283a 	ret

00180900 <clear_menu>:
   Last Modified:    Mar. 13, 1994

*/

void  clear_menu(void)
{
  180900:	defffe04 	addi	sp,sp,-8
  180904:	dfc00115 	stw	ra,4(sp)
  180908:	df000015 	stw	fp,0(sp)
  18090c:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
  180910:	d0a00d17 	ldw	r2,-32716(gp)
  180914:	10000126 	beq	r2,zero,18091c <clear_menu+0x1c>

        /* menu is being displayed - turn it off and restore the trace in that area */
	restore_menu_trace();
  180918:	01823000 	call	182300 <restore_menu_trace>
    }


    /* no longer displaying the menu */
    menu_display = FALSE;
  18091c:	d0200d15 	stw	zero,-32716(gp)


    /* all done, return */
    return;
  180920:	0001883a 	nop

}
  180924:	e037883a 	mov	sp,fp
  180928:	dfc00117 	ldw	ra,4(sp)
  18092c:	df000017 	ldw	fp,0(sp)
  180930:	dec00204 	addi	sp,sp,8
  180934:	f800283a 	ret

00180938 <display_menu>:
   Last Modified:    Mar. 13, 1994

*/

void  display_menu(void)
{
  180938:	defffd04 	addi	sp,sp,-12
  18093c:	dfc00215 	stw	ra,8(sp)
  180940:	df000115 	stw	fp,4(sp)
  180944:	df000104 	addi	fp,sp,4
    int  i;		/* loop index */



    /* check if the menu is currently being displayed */
    if (!menu_display)  {
  180948:	d0a00d17 	ldw	r2,-32716(gp)
  18094c:	1000121e 	bne	r2,zero,180998 <display_menu+0x60>

        /* menu is not being displayed - turn it on */
	/* display it entry by entry */
	for (i = 0; i < NO_MENU_ENTRIES; i++)  {
  180950:	e03fff15 	stw	zero,-4(fp)
  180954:	00000d06 	br	18098c <display_menu+0x54>

	    /* display this entry - check if it should be highlighted */
	    if (i == menu_entry)
  180958:	d0a00e17 	ldw	r2,-32712(gp)
  18095c:	e0ffff17 	ldw	r3,-4(fp)
  180960:	1880041e 	bne	r3,r2,180974 <display_menu+0x3c>
	        /* currently selected entry - highlight it */
	        display_entry(i, TRUE);
  180964:	e13fff17 	ldw	r4,-4(fp)
  180968:	01400044 	movi	r5,1
  18096c:	0180c680 	call	180c68 <display_entry>
  180970:	00000306 	br	180980 <display_menu+0x48>
	    else
	        /* not the currently selected entry - "normal video" */
	        display_entry(i, FALSE);
  180974:	e13fff17 	ldw	r4,-4(fp)
  180978:	000b883a 	mov	r5,zero
  18097c:	0180c680 	call	180c68 <display_entry>
    /* check if the menu is currently being displayed */
    if (!menu_display)  {

        /* menu is not being displayed - turn it on */
	/* display it entry by entry */
	for (i = 0; i < NO_MENU_ENTRIES; i++)  {
  180980:	e0bfff17 	ldw	r2,-4(fp)
  180984:	10800044 	addi	r2,r2,1
  180988:	e0bfff15 	stw	r2,-4(fp)
  18098c:	e0bfff17 	ldw	r2,-4(fp)
  180990:	108001f0 	cmpltui	r2,r2,7
  180994:	103ff01e 	bne	r2,zero,180958 <display_menu+0x20>
        }
    }


    /* now are displaying the menu */
    menu_display = TRUE;
  180998:	00800044 	movi	r2,1
  18099c:	d0a00d15 	stw	r2,-32716(gp)


    /* all done, return */
    return;
  1809a0:	0001883a 	nop

}
  1809a4:	e037883a 	mov	sp,fp
  1809a8:	dfc00117 	ldw	ra,4(sp)
  1809ac:	df000017 	ldw	fp,0(sp)
  1809b0:	dec00204 	addi	sp,sp,8
  1809b4:	f800283a 	ret

001809b8 <refresh_menu>:
   Last Modified:    Mar. 8, 1994

*/

void  refresh_menu(void)
{
  1809b8:	defffe04 	addi	sp,sp,-8
  1809bc:	dfc00115 	stw	ra,4(sp)
  1809c0:	df000015 	stw	fp,0(sp)
  1809c4:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
  1809c8:	d0a00d17 	ldw	r2,-32716(gp)
  1809cc:	10000226 	beq	r2,zero,1809d8 <refresh_menu+0x20>

    	/* menu is currently being displayed - need to refresh it */
	/* do this by turning off the display, then forcing it back on */
	menu_display = FALSE;
  1809d0:	d0200d15 	stw	zero,-32716(gp)
	display_menu();
  1809d4:	01809380 	call	180938 <display_menu>
    }


    /* refreshed the menu if it was displayed, now return */
    return;
  1809d8:	0001883a 	nop

}
  1809dc:	e037883a 	mov	sp,fp
  1809e0:	dfc00117 	ldw	ra,4(sp)
  1809e4:	df000017 	ldw	fp,0(sp)
  1809e8:	dec00204 	addi	sp,sp,8
  1809ec:	f800283a 	ret

001809f0 <reset_menu>:
   Last Modified:    Mar. 17, 1997

*/

void  reset_menu(void)
{
  1809f0:	defffe04 	addi	sp,sp,-8
  1809f4:	dfc00115 	stw	ra,4(sp)
  1809f8:	df000015 	stw	fp,0(sp)
  1809fc:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
  180a00:	d0a00d17 	ldw	r2,-32716(gp)
  180a04:	10000426 	beq	r2,zero,180a18 <reset_menu+0x28>

        /* menu is being displayed */
	/* remove highlight from currently selected entry */
	display_entry(menu_entry, FALSE);
  180a08:	d0a00e17 	ldw	r2,-32712(gp)
  180a0c:	1009883a 	mov	r4,r2
  180a10:	000b883a 	mov	r5,zero
  180a14:	0180c680 	call	180c68 <display_entry>
    }


    /* reset the currently selected entry */
    menu_entry = 0;
  180a18:	d0200e15 	stw	zero,-32712(gp)


    /* finally, highlight the first entry if the menu is being displayed */
    if (menu_display)
  180a1c:	d0a00d17 	ldw	r2,-32716(gp)
  180a20:	10000426 	beq	r2,zero,180a34 <reset_menu+0x44>
	display_entry(menu_entry, TRUE);
  180a24:	d0a00e17 	ldw	r2,-32712(gp)
  180a28:	1009883a 	mov	r4,r2
  180a2c:	01400044 	movi	r5,1
  180a30:	0180c680 	call	180c68 <display_entry>



    /* all done, return */
    return;
  180a34:	0001883a 	nop

}
  180a38:	e037883a 	mov	sp,fp
  180a3c:	dfc00117 	ldw	ra,4(sp)
  180a40:	df000017 	ldw	fp,0(sp)
  180a44:	dec00204 	addi	sp,sp,8
  180a48:	f800283a 	ret

00180a4c <next_entry>:
   Last Modified:    Mar. 13, 1994

*/

void  next_entry(void)
{
  180a4c:	defffe04 	addi	sp,sp,-8
  180a50:	dfc00115 	stw	ra,4(sp)
  180a54:	df000015 	stw	fp,0(sp)
  180a58:	d839883a 	mov	fp,sp
      /* none */



    /* only update if not at end of the menu */
    if (menu_entry < (NO_MENU_ENTRIES - 1))  {
  180a5c:	d0a00e17 	ldw	r2,-32712(gp)
  180a60:	108001a8 	cmpgeui	r2,r2,6
  180a64:	10000f1e 	bne	r2,zero,180aa4 <next_entry+0x58>

        /* not at the end of the menu */

	/* turn off current entry if displaying */
	if (menu_display)
  180a68:	d0a00d17 	ldw	r2,-32716(gp)
  180a6c:	10000426 	beq	r2,zero,180a80 <next_entry+0x34>
            /* displaying menu - turn off currently selected entry */
	    display_entry(menu_entry, FALSE);
  180a70:	d0a00e17 	ldw	r2,-32712(gp)
  180a74:	1009883a 	mov	r4,r2
  180a78:	000b883a 	mov	r5,zero
  180a7c:	0180c680 	call	180c68 <display_entry>

	/* update the menu entry to the next one */
	menu_entry++;
  180a80:	d0a00e17 	ldw	r2,-32712(gp)
  180a84:	10800044 	addi	r2,r2,1
  180a88:	d0a00e15 	stw	r2,-32712(gp)

	/* now highlight this entry if displaying the menu */
	if (menu_display)
  180a8c:	d0a00d17 	ldw	r2,-32716(gp)
  180a90:	10000426 	beq	r2,zero,180aa4 <next_entry+0x58>
            /* displaying menu - highlight newly selected entry */
	    display_entry(menu_entry, TRUE);
  180a94:	d0a00e17 	ldw	r2,-32712(gp)
  180a98:	1009883a 	mov	r4,r2
  180a9c:	01400044 	movi	r5,1
  180aa0:	0180c680 	call	180c68 <display_entry>
    }


    /* all done, return */
    return;
  180aa4:	0001883a 	nop

}
  180aa8:	e037883a 	mov	sp,fp
  180aac:	dfc00117 	ldw	ra,4(sp)
  180ab0:	df000017 	ldw	fp,0(sp)
  180ab4:	dec00204 	addi	sp,sp,8
  180ab8:	f800283a 	ret

00180abc <previous_entry>:
   Last Modified:    Mar. 13, 1994

*/

void  previous_entry(void)
{
  180abc:	defffe04 	addi	sp,sp,-8
  180ac0:	dfc00115 	stw	ra,4(sp)
  180ac4:	df000015 	stw	fp,0(sp)
  180ac8:	d839883a 	mov	fp,sp
      /* none */



    /* only update if not at the start of the menu */
    if (menu_entry > 0)  {
  180acc:	d0a00e17 	ldw	r2,-32712(gp)
  180ad0:	00800f0e 	bge	zero,r2,180b10 <previous_entry+0x54>

        /* not at the start of the menu */

	/* turn off current entry if displaying */
	if (menu_display)
  180ad4:	d0a00d17 	ldw	r2,-32716(gp)
  180ad8:	10000426 	beq	r2,zero,180aec <previous_entry+0x30>
            /* displaying menu - turn off currently selected entry */
	    display_entry(menu_entry, FALSE);
  180adc:	d0a00e17 	ldw	r2,-32712(gp)
  180ae0:	1009883a 	mov	r4,r2
  180ae4:	000b883a 	mov	r5,zero
  180ae8:	0180c680 	call	180c68 <display_entry>

	/* update the menu entry to the previous one */
	menu_entry--;
  180aec:	d0a00e17 	ldw	r2,-32712(gp)
  180af0:	10bfffc4 	addi	r2,r2,-1
  180af4:	d0a00e15 	stw	r2,-32712(gp)

	/* now highlight this entry if displaying the menu */
	if (menu_display)
  180af8:	d0a00d17 	ldw	r2,-32716(gp)
  180afc:	10000426 	beq	r2,zero,180b10 <previous_entry+0x54>
            /* displaying menu - highlight newly selected entry */
	    display_entry(menu_entry, TRUE);
  180b00:	d0a00e17 	ldw	r2,-32712(gp)
  180b04:	1009883a 	mov	r4,r2
  180b08:	01400044 	movi	r5,1
  180b0c:	0180c680 	call	180c68 <display_entry>

    }


    /* all done, return */
    return;
  180b10:	0001883a 	nop

}
  180b14:	e037883a 	mov	sp,fp
  180b18:	dfc00117 	ldw	ra,4(sp)
  180b1c:	df000017 	ldw	fp,0(sp)
  180b20:	dec00204 	addi	sp,sp,8
  180b24:	f800283a 	ret

00180b28 <menu_entry_left>:
   Last Modified:    May 9, 2006

*/

void  menu_entry_left(void)
{
  180b28:	defffe04 	addi	sp,sp,-8
  180b2c:	dfc00115 	stw	ra,4(sp)
  180b30:	df000015 	stw	fp,0(sp)
  180b34:	d839883a 	mov	fp,sp
       /*  Level           Slope             Delay                        */



    /* invoke the appropriate <Left> key function */
    process[menu_entry]();
  180b38:	d0a00e17 	ldw	r2,-32712(gp)
  180b3c:	00c00634 	movhi	r3,24
  180b40:	18d6f104 	addi	r3,r3,23492
  180b44:	1085883a 	add	r2,r2,r2
  180b48:	1085883a 	add	r2,r2,r2
  180b4c:	1885883a 	add	r2,r3,r2
  180b50:	10800017 	ldw	r2,0(r2)
  180b54:	103ee83a 	callr	r2

    /* if displaying menu entries, display the new value */
    /* note: since it is being changed - know this option is selected */
    if (menu_display)  {
  180b58:	d0a00d17 	ldw	r2,-32716(gp)
  180b5c:	10001426 	beq	r2,zero,180bb0 <menu_entry_left+0x88>
        menu[menu_entry].display((MENU_X + menu[menu_entry].opt_off),
  180b60:	d0a00e17 	ldw	r2,-32712(gp)
  180b64:	00c00634 	movhi	r3,24
  180b68:	18d6ce04 	addi	r3,r3,23352
  180b6c:	1004913a 	slli	r2,r2,4
  180b70:	1885883a 	add	r2,r3,r2
  180b74:	10800304 	addi	r2,r2,12
  180b78:	11c00017 	ldw	r7,0(r2)
  180b7c:	d0a00e17 	ldw	r2,-32712(gp)
  180b80:	00c00634 	movhi	r3,24
  180b84:	18d6ce04 	addi	r3,r3,23352
  180b88:	1004913a 	slli	r2,r2,4
  180b8c:	1885883a 	add	r2,r3,r2
  180b90:	10800204 	addi	r2,r2,8
  180b94:	10800017 	ldw	r2,0(r2)
  180b98:	10c00fc4 	addi	r3,r2,63
  180b9c:	d0a00e17 	ldw	r2,-32712(gp)
  180ba0:	1809883a 	mov	r4,r3
  180ba4:	100b883a 	mov	r5,r2
  180ba8:	01800084 	movi	r6,2
  180bac:	383ee83a 	callr	r7
    			         (MENU_Y + menu_entry), OPTION_SELECTED);
    }


    /* all done, return */
    return;
  180bb0:	0001883a 	nop

}
  180bb4:	e037883a 	mov	sp,fp
  180bb8:	dfc00117 	ldw	ra,4(sp)
  180bbc:	df000017 	ldw	fp,0(sp)
  180bc0:	dec00204 	addi	sp,sp,8
  180bc4:	f800283a 	ret

00180bc8 <menu_entry_right>:
   Last Modified:    May 9, 2006

*/

void  menu_entry_right(void)
{
  180bc8:	defffe04 	addi	sp,sp,-8
  180bcc:	dfc00115 	stw	ra,4(sp)
  180bd0:	df000015 	stw	fp,0(sp)
  180bd4:	d839883a 	mov	fp,sp
       /*  Level         Slope             Delay                        */



    /* invoke the appropriate <Right> key function */
    process[menu_entry]();
  180bd8:	d0a00e17 	ldw	r2,-32712(gp)
  180bdc:	00c00634 	movhi	r3,24
  180be0:	18d6ea04 	addi	r3,r3,23464
  180be4:	1085883a 	add	r2,r2,r2
  180be8:	1085883a 	add	r2,r2,r2
  180bec:	1885883a 	add	r2,r3,r2
  180bf0:	10800017 	ldw	r2,0(r2)
  180bf4:	103ee83a 	callr	r2

    /* if displaying menu entries, display the new value */
    /* note: since it is being changed - know this option is selected */
    if (menu_display)  {
  180bf8:	d0a00d17 	ldw	r2,-32716(gp)
  180bfc:	10001426 	beq	r2,zero,180c50 <menu_entry_right+0x88>
        menu[menu_entry].display((MENU_X + menu[menu_entry].opt_off),
  180c00:	d0a00e17 	ldw	r2,-32712(gp)
  180c04:	00c00634 	movhi	r3,24
  180c08:	18d6ce04 	addi	r3,r3,23352
  180c0c:	1004913a 	slli	r2,r2,4
  180c10:	1885883a 	add	r2,r3,r2
  180c14:	10800304 	addi	r2,r2,12
  180c18:	11c00017 	ldw	r7,0(r2)
  180c1c:	d0a00e17 	ldw	r2,-32712(gp)
  180c20:	00c00634 	movhi	r3,24
  180c24:	18d6ce04 	addi	r3,r3,23352
  180c28:	1004913a 	slli	r2,r2,4
  180c2c:	1885883a 	add	r2,r3,r2
  180c30:	10800204 	addi	r2,r2,8
  180c34:	10800017 	ldw	r2,0(r2)
  180c38:	10c00fc4 	addi	r3,r2,63
  180c3c:	d0a00e17 	ldw	r2,-32712(gp)
  180c40:	1809883a 	mov	r4,r3
  180c44:	100b883a 	mov	r5,r2
  180c48:	01800084 	movi	r6,2
  180c4c:	383ee83a 	callr	r7
    			         (MENU_Y + menu_entry), OPTION_SELECTED);
    }


    /* all done, return */
    return;
  180c50:	0001883a 	nop

}
  180c54:	e037883a 	mov	sp,fp
  180c58:	dfc00117 	ldw	ra,4(sp)
  180c5c:	df000017 	ldw	fp,0(sp)
  180c60:	dec00204 	addi	sp,sp,8
  180c64:	f800283a 	ret

00180c68 <display_entry>:
   Last Modified:    Aug. 13, 2004

*/

static void  display_entry(int entry, int selected)
{
  180c68:	defffc04 	addi	sp,sp,-16
  180c6c:	dfc00315 	stw	ra,12(sp)
  180c70:	df000215 	stw	fp,8(sp)
  180c74:	df000204 	addi	fp,sp,8
  180c78:	e13ffe15 	stw	r4,-8(fp)
  180c7c:	e17fff15 	stw	r5,-4(fp)
      /* none */



    /* output the menu entry with the appropriate color */
    plot_string((MENU_X + menu[entry].h_off), (MENU_Y + entry), menu[entry].s,
  180c80:	00c00634 	movhi	r3,24
  180c84:	18d6ce04 	addi	r3,r3,23352
  180c88:	e0bffe17 	ldw	r2,-8(fp)
  180c8c:	1004913a 	slli	r2,r2,4
  180c90:	1885883a 	add	r2,r3,r2
  180c94:	10800104 	addi	r2,r2,4
  180c98:	10800017 	ldw	r2,0(r2)
  180c9c:	11000fc4 	addi	r4,r2,63
  180ca0:	00c00634 	movhi	r3,24
  180ca4:	18d6ce04 	addi	r3,r3,23352
  180ca8:	e0bffe17 	ldw	r2,-8(fp)
  180cac:	1004913a 	slli	r2,r2,4
  180cb0:	1885883a 	add	r2,r3,r2
  180cb4:	10c00017 	ldw	r3,0(r2)
  180cb8:	e0bfff17 	ldw	r2,-4(fp)
  180cbc:	10000226 	beq	r2,zero,180cc8 <display_entry+0x60>
  180cc0:	00800084 	movi	r2,2
  180cc4:	00000106 	br	180ccc <display_entry+0x64>
  180cc8:	0005883a 	mov	r2,zero
  180ccc:	e17ffe17 	ldw	r5,-8(fp)
  180cd0:	180d883a 	mov	r6,r3
  180cd4:	100f883a 	mov	r7,r2
  180cd8:	01806cc0 	call	1806cc <plot_string>
    		(selected ? SELECTED : NORMAL));
    /* also output the menu option with the appropriate color */
    menu[entry].display((MENU_X + menu[entry].opt_off), (MENU_Y + entry),
  180cdc:	00c00634 	movhi	r3,24
  180ce0:	18d6ce04 	addi	r3,r3,23352
  180ce4:	e0bffe17 	ldw	r2,-8(fp)
  180ce8:	1004913a 	slli	r2,r2,4
  180cec:	1885883a 	add	r2,r3,r2
  180cf0:	10800304 	addi	r2,r2,12
  180cf4:	11c00017 	ldw	r7,0(r2)
  180cf8:	00c00634 	movhi	r3,24
  180cfc:	18d6ce04 	addi	r3,r3,23352
  180d00:	e0bffe17 	ldw	r2,-8(fp)
  180d04:	1004913a 	slli	r2,r2,4
  180d08:	1885883a 	add	r2,r3,r2
  180d0c:	10800204 	addi	r2,r2,8
  180d10:	10800017 	ldw	r2,0(r2)
  180d14:	10c00fc4 	addi	r3,r2,63
  180d18:	e0bfff17 	ldw	r2,-4(fp)
  180d1c:	10000226 	beq	r2,zero,180d28 <display_entry+0xc0>
  180d20:	00800084 	movi	r2,2
  180d24:	00000106 	br	180d2c <display_entry+0xc4>
  180d28:	0005883a 	mov	r2,zero
  180d2c:	1809883a 	mov	r4,r3
  180d30:	e17ffe17 	ldw	r5,-8(fp)
  180d34:	100d883a 	mov	r6,r2
  180d38:	383ee83a 	callr	r7
    			(selected ? OPTION_SELECTED : OPTION_NORMAL));


    /* all done outputting this menu entry - return */
    return;
  180d3c:	0001883a 	nop

}
  180d40:	e037883a 	mov	sp,fp
  180d44:	dfc00117 	ldw	ra,4(sp)
  180d48:	df000017 	ldw	fp,0(sp)
  180d4c:	dec00204 	addi	sp,sp,8
  180d50:	f800283a 	ret

00180d54 <no_menu_action>:
   Last Modified:    Mar. 8, 1994

*/

void  no_menu_action()
{
  180d54:	deffff04 	addi	sp,sp,-4
  180d58:	df000015 	stw	fp,0(sp)
  180d5c:	d839883a 	mov	fp,sp
      /* none */



    /* nothing to do - return */
    return;
  180d60:	0001883a 	nop

}
  180d64:	e037883a 	mov	sp,fp
  180d68:	df000017 	ldw	fp,0(sp)
  180d6c:	dec00104 	addi	sp,sp,4
  180d70:	f800283a 	ret

00180d74 <no_display>:
   Last Modified:    Mar. 8, 1994

*/

void  no_display(int x_pos, int y_pos, int style)
{
  180d74:	defffc04 	addi	sp,sp,-16
  180d78:	df000315 	stw	fp,12(sp)
  180d7c:	df000304 	addi	fp,sp,12
  180d80:	e13ffd15 	stw	r4,-12(fp)
  180d84:	e17ffe15 	stw	r5,-8(fp)
  180d88:	e1bfff15 	stw	r6,-4(fp)
      /* none */



    /* nothing to do - return */
    return;
  180d8c:	0001883a 	nop

}
  180d90:	e037883a 	mov	sp,fp
  180d94:	df000017 	ldw	fp,0(sp)
  180d98:	dec00104 	addi	sp,sp,4
  180d9c:	f800283a 	ret

00180da0 <set_trigger_mode>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trigger_mode(enum trigger_type m)
{
  180da0:	defffd04 	addi	sp,sp,-12
  180da4:	dfc00215 	stw	ra,8(sp)
  180da8:	df000115 	stw	fp,4(sp)
  180dac:	df000104 	addi	fp,sp,4
  180db0:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger mode */
    trigger_mode = m;
  180db4:	e0bfff17 	ldw	r2,-4(fp)
  180db8:	d0a00f15 	stw	r2,-32708(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  180dbc:	d0a00f17 	ldw	r2,-32708(gp)
  180dc0:	1009883a 	mov	r4,r2
  180dc4:	0181c080 	call	181c08 <set_mode>


    /* all done setting the trigger mode - return */
    return;
  180dc8:	0001883a 	nop

}
  180dcc:	e037883a 	mov	sp,fp
  180dd0:	dfc00117 	ldw	ra,4(sp)
  180dd4:	df000017 	ldw	fp,0(sp)
  180dd8:	dec00204 	addi	sp,sp,8
  180ddc:	f800283a 	ret

00180de0 <get_trigger_mode>:
   Last Modified:    May 9, 2006

*/

enum trigger_type  get_trigger_mode()
{
  180de0:	deffff04 	addi	sp,sp,-4
  180de4:	df000015 	stw	fp,0(sp)
  180de8:	d839883a 	mov	fp,sp
      /* none */



    /* return the current trigger mode */
    return  trigger_mode;
  180dec:	d0a00f17 	ldw	r2,-32708(gp)

}
  180df0:	e037883a 	mov	sp,fp
  180df4:	df000017 	ldw	fp,0(sp)
  180df8:	dec00104 	addi	sp,sp,4
  180dfc:	f800283a 	ret

00180e00 <mode_down>:
   Last Modified:    May 9, 2006

*/

void  mode_down()
{
  180e00:	defffe04 	addi	sp,sp,-8
  180e04:	dfc00115 	stw	ra,4(sp)
  180e08:	df000015 	stw	fp,0(sp)
  180e0c:	d839883a 	mov	fp,sp
      /* none */



    /* move to the "next" triggering mode */
    if (trigger_mode == NORMAL_TRIGGER)
  180e10:	d0a00f17 	ldw	r2,-32708(gp)
  180e14:	1000031e 	bne	r2,zero,180e24 <mode_down+0x24>
        trigger_mode = AUTO_TRIGGER;
  180e18:	00800044 	movi	r2,1
  180e1c:	d0a00f15 	stw	r2,-32708(gp)
  180e20:	00000706 	br	180e40 <mode_down+0x40>
    else if (trigger_mode == AUTO_TRIGGER)
  180e24:	d0a00f17 	ldw	r2,-32708(gp)
  180e28:	10800058 	cmpnei	r2,r2,1
  180e2c:	1000031e 	bne	r2,zero,180e3c <mode_down+0x3c>
        trigger_mode = ONESHOT_TRIGGER;
  180e30:	00800084 	movi	r2,2
  180e34:	d0a00f15 	stw	r2,-32708(gp)
  180e38:	00000106 	br	180e40 <mode_down+0x40>
    else
        trigger_mode = NORMAL_TRIGGER;
  180e3c:	d0200f15 	stw	zero,-32708(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  180e40:	d0a00f17 	ldw	r2,-32708(gp)
  180e44:	1009883a 	mov	r4,r2
  180e48:	0181c080 	call	181c08 <set_mode>


    /* all done with the trigger mode - return */
    return;
  180e4c:	0001883a 	nop

}
  180e50:	e037883a 	mov	sp,fp
  180e54:	dfc00117 	ldw	ra,4(sp)
  180e58:	df000017 	ldw	fp,0(sp)
  180e5c:	dec00204 	addi	sp,sp,8
  180e60:	f800283a 	ret

00180e64 <mode_up>:
   Last Modified:    May 9, 2006

*/

void  mode_up()
{
  180e64:	defffe04 	addi	sp,sp,-8
  180e68:	dfc00115 	stw	ra,4(sp)
  180e6c:	df000015 	stw	fp,0(sp)
  180e70:	d839883a 	mov	fp,sp
      /* none */



    /* move to the "previous" triggering mode */
    if (trigger_mode == NORMAL_TRIGGER)
  180e74:	d0a00f17 	ldw	r2,-32708(gp)
  180e78:	1000031e 	bne	r2,zero,180e88 <mode_up+0x24>
        trigger_mode = ONESHOT_TRIGGER;
  180e7c:	00800084 	movi	r2,2
  180e80:	d0a00f15 	stw	r2,-32708(gp)
  180e84:	00000706 	br	180ea4 <mode_up+0x40>
    else if (trigger_mode == AUTO_TRIGGER)
  180e88:	d0a00f17 	ldw	r2,-32708(gp)
  180e8c:	10800058 	cmpnei	r2,r2,1
  180e90:	1000021e 	bne	r2,zero,180e9c <mode_up+0x38>
        trigger_mode = NORMAL_TRIGGER;
  180e94:	d0200f15 	stw	zero,-32708(gp)
  180e98:	00000206 	br	180ea4 <mode_up+0x40>
    else
        trigger_mode = AUTO_TRIGGER;
  180e9c:	00800044 	movi	r2,1
  180ea0:	d0a00f15 	stw	r2,-32708(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  180ea4:	d0a00f17 	ldw	r2,-32708(gp)
  180ea8:	1009883a 	mov	r4,r2
  180eac:	0181c080 	call	181c08 <set_mode>


    /* all done with the trigger mode - return */
    return;
  180eb0:	0001883a 	nop

}
  180eb4:	e037883a 	mov	sp,fp
  180eb8:	dfc00117 	ldw	ra,4(sp)
  180ebc:	df000017 	ldw	fp,0(sp)
  180ec0:	dec00204 	addi	sp,sp,8
  180ec4:	f800283a 	ret

00180ec8 <display_mode>:
   Last Modified:    May 9, 2006

*/

void  display_mode(int x_pos, int y_pos, int style)
{
  180ec8:	defffb04 	addi	sp,sp,-20
  180ecc:	dfc00415 	stw	ra,16(sp)
  180ed0:	df000315 	stw	fp,12(sp)
  180ed4:	df000304 	addi	fp,sp,12
  180ed8:	e13ffd15 	stw	r4,-12(fp)
  180edc:	e17ffe15 	stw	r5,-8(fp)
  180ee0:	e1bfff15 	stw	r6,-4(fp)
                                             " One-Shot "  };



    /* display the trigger mode */
    plot_string(x_pos, y_pos, modes[trigger_mode], style);
  180ee4:	d0a00f17 	ldw	r2,-32708(gp)
  180ee8:	00c00634 	movhi	r3,24
  180eec:	18d75404 	addi	r3,r3,23888
  180ef0:	1085883a 	add	r2,r2,r2
  180ef4:	1085883a 	add	r2,r2,r2
  180ef8:	1885883a 	add	r2,r3,r2
  180efc:	10c00017 	ldw	r3,0(r2)
  180f00:	e0bfff17 	ldw	r2,-4(fp)
  180f04:	e13ffd17 	ldw	r4,-12(fp)
  180f08:	e17ffe17 	ldw	r5,-8(fp)
  180f0c:	180d883a 	mov	r6,r3
  180f10:	100f883a 	mov	r7,r2
  180f14:	01806cc0 	call	1806cc <plot_string>


    /* all done displaying the trigger mode - return */
    return;
  180f18:	0001883a 	nop

}
  180f1c:	e037883a 	mov	sp,fp
  180f20:	dfc00117 	ldw	ra,4(sp)
  180f24:	df000017 	ldw	fp,0(sp)
  180f28:	dec00204 	addi	sp,sp,8
  180f2c:	f800283a 	ret

00180f30 <set_scale>:
   Last Modified:    Mar. 13, 1994

*/

void  set_scale(enum scale_type s)
{
  180f30:	defffd04 	addi	sp,sp,-12
  180f34:	dfc00215 	stw	ra,8(sp)
  180f38:	df000115 	stw	fp,4(sp)
  180f3c:	df000104 	addi	fp,sp,4
  180f40:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the scale type */
    scale = s;
  180f44:	e0bfff17 	ldw	r2,-4(fp)
  180f48:	d0a01015 	stw	r2,-32704(gp)

    /* output the scale appropriately */
    set_display_scale(scale);
  180f4c:	d0a01017 	ldw	r2,-32704(gp)
  180f50:	1009883a 	mov	r4,r2
  180f54:	0181d2c0 	call	181d2c <set_display_scale>


    /* all done setting the scale type - return */
    return;
  180f58:	0001883a 	nop

}
  180f5c:	e037883a 	mov	sp,fp
  180f60:	dfc00117 	ldw	ra,4(sp)
  180f64:	df000017 	ldw	fp,0(sp)
  180f68:	dec00204 	addi	sp,sp,8
  180f6c:	f800283a 	ret

00180f70 <scale_down>:
   Last Modified:    May 9, 2006

*/

void  scale_down()
{
  180f70:	defffe04 	addi	sp,sp,-8
  180f74:	dfc00115 	stw	ra,4(sp)
  180f78:	df000015 	stw	fp,0(sp)
  180f7c:	d839883a 	mov	fp,sp
      /* none */



    /* change to the "next" scale type */
    if (scale == SCALE_NONE)
  180f80:	d0a01017 	ldw	r2,-32704(gp)
  180f84:	1000031e 	bne	r2,zero,180f94 <scale_down+0x24>
        scale = SCALE_AXES;
  180f88:	00800044 	movi	r2,1
  180f8c:	d0a01015 	stw	r2,-32704(gp)
  180f90:	00000706 	br	180fb0 <scale_down+0x40>
    else if (scale == SCALE_AXES)
  180f94:	d0a01017 	ldw	r2,-32704(gp)
  180f98:	10800058 	cmpnei	r2,r2,1
  180f9c:	1000031e 	bne	r2,zero,180fac <scale_down+0x3c>
        scale = SCALE_GRID;
  180fa0:	00800084 	movi	r2,2
  180fa4:	d0a01015 	stw	r2,-32704(gp)
  180fa8:	00000106 	br	180fb0 <scale_down+0x40>
    else
        scale = SCALE_NONE;
  180fac:	d0201015 	stw	zero,-32704(gp)

    /* set the scale type */
    set_display_scale(scale);
  180fb0:	d0a01017 	ldw	r2,-32704(gp)
  180fb4:	1009883a 	mov	r4,r2
  180fb8:	0181d2c0 	call	181d2c <set_display_scale>


    /* all done with toggling the scale type - return */
    return;
  180fbc:	0001883a 	nop

}
  180fc0:	e037883a 	mov	sp,fp
  180fc4:	dfc00117 	ldw	ra,4(sp)
  180fc8:	df000017 	ldw	fp,0(sp)
  180fcc:	dec00204 	addi	sp,sp,8
  180fd0:	f800283a 	ret

00180fd4 <scale_up>:
   Last Modified:    May 9, 2006

*/

void  scale_up()
{
  180fd4:	defffe04 	addi	sp,sp,-8
  180fd8:	dfc00115 	stw	ra,4(sp)
  180fdc:	df000015 	stw	fp,0(sp)
  180fe0:	d839883a 	mov	fp,sp
      /* none */



    /* change to the "previous" scale type */
    if (scale == SCALE_NONE)
  180fe4:	d0a01017 	ldw	r2,-32704(gp)
  180fe8:	1000031e 	bne	r2,zero,180ff8 <scale_up+0x24>
        scale = SCALE_GRID;
  180fec:	00800084 	movi	r2,2
  180ff0:	d0a01015 	stw	r2,-32704(gp)
  180ff4:	00000706 	br	181014 <scale_up+0x40>
    else if (scale == SCALE_AXES)
  180ff8:	d0a01017 	ldw	r2,-32704(gp)
  180ffc:	10800058 	cmpnei	r2,r2,1
  181000:	1000021e 	bne	r2,zero,18100c <scale_up+0x38>
        scale = SCALE_NONE;
  181004:	d0201015 	stw	zero,-32704(gp)
  181008:	00000206 	br	181014 <scale_up+0x40>
    else
        scale = SCALE_AXES;
  18100c:	00800044 	movi	r2,1
  181010:	d0a01015 	stw	r2,-32704(gp)

    /* set the scale type */
    set_display_scale(scale);
  181014:	d0a01017 	ldw	r2,-32704(gp)
  181018:	1009883a 	mov	r4,r2
  18101c:	0181d2c0 	call	181d2c <set_display_scale>


    /* all done with toggling the scale type - return */
    return;
  181020:	0001883a 	nop

}
  181024:	e037883a 	mov	sp,fp
  181028:	dfc00117 	ldw	ra,4(sp)
  18102c:	df000017 	ldw	fp,0(sp)
  181030:	dec00204 	addi	sp,sp,8
  181034:	f800283a 	ret

00181038 <display_scale>:
   Last Modified:    Mar. 13, 1994

*/

void  display_scale(int x_pos, int y_pos, int style)
{
  181038:	defffb04 	addi	sp,sp,-20
  18103c:	dfc00415 	stw	ra,16(sp)
  181040:	df000315 	stw	fp,12(sp)
  181044:	df000304 	addi	fp,sp,12
  181048:	e13ffd15 	stw	r4,-12(fp)
  18104c:	e17ffe15 	stw	r5,-8(fp)
  181050:	e1bfff15 	stw	r6,-4(fp)
                                                  " Grid"  };



    /* display the scale status */
    plot_string(x_pos, y_pos, scale_stat[scale], style);
  181054:	d0a01017 	ldw	r2,-32704(gp)
  181058:	00c00634 	movhi	r3,24
  18105c:	18d74804 	addi	r3,r3,23840
  181060:	1085883a 	add	r2,r2,r2
  181064:	1085883a 	add	r2,r2,r2
  181068:	1885883a 	add	r2,r3,r2
  18106c:	10c00017 	ldw	r3,0(r2)
  181070:	e0bfff17 	ldw	r2,-4(fp)
  181074:	e13ffd17 	ldw	r4,-12(fp)
  181078:	e17ffe17 	ldw	r5,-8(fp)
  18107c:	180d883a 	mov	r6,r3
  181080:	100f883a 	mov	r7,r2
  181084:	01806cc0 	call	1806cc <plot_string>


    /* all done displaying the scale status - return */
    return;
  181088:	0001883a 	nop

}
  18108c:	e037883a 	mov	sp,fp
  181090:	dfc00117 	ldw	ra,4(sp)
  181094:	df000017 	ldw	fp,0(sp)
  181098:	dec00204 	addi	sp,sp,8
  18109c:	f800283a 	ret

001810a0 <set_sweep>:
   Last Modified:    Mar. 8, 1994

*/

void  set_sweep(int s)
{
  1810a0:	defffc04 	addi	sp,sp,-16
  1810a4:	dfc00315 	stw	ra,12(sp)
  1810a8:	df000215 	stw	fp,8(sp)
  1810ac:	df000204 	addi	fp,sp,8
  1810b0:	e13fff15 	stw	r4,-4(fp)
    int  sample_size;		/* sample size for this sweep rate */



    /* set the new sweep rate */
    sweep = s;
  1810b4:	e0bfff17 	ldw	r2,-4(fp)
  1810b8:	d0a01115 	stw	r2,-32700(gp)

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  1810bc:	d0a01117 	ldw	r2,-32700(gp)
  1810c0:	00c00634 	movhi	r3,24
  1810c4:	18d71c04 	addi	r3,r3,23664
  1810c8:	100490fa 	slli	r2,r2,3
  1810cc:	1885883a 	add	r2,r3,r2
  1810d0:	10800017 	ldw	r2,0(r2)
  1810d4:	1009883a 	mov	r4,r2
  1810d8:	0182d500 	call	182d50 <set_sample_rate>
  1810dc:	e0bffe15 	stw	r2,-8(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  1810e0:	e13ffe17 	ldw	r4,-8(fp)
  1810e4:	0181d000 	call	181d00 <set_trace_size>


    /* all done initializing the sweep rate - return */
    return;
  1810e8:	0001883a 	nop

}
  1810ec:	e037883a 	mov	sp,fp
  1810f0:	dfc00117 	ldw	ra,4(sp)
  1810f4:	df000017 	ldw	fp,0(sp)
  1810f8:	dec00204 	addi	sp,sp,8
  1810fc:	f800283a 	ret

00181100 <sweep_down>:
   Last Modified:    Mar. 8, 1994

*/

void  sweep_down()
{
  181100:	defffd04 	addi	sp,sp,-12
  181104:	dfc00215 	stw	ra,8(sp)
  181108:	df000115 	stw	fp,4(sp)
  18110c:	df000104 	addi	fp,sp,4
    int  sample_size;		/* sample size for the new sweep rate */



    /* decrease the sweep rate, if not already the minimum */
    if (sweep > 0)  {
  181110:	d0a01117 	ldw	r2,-32700(gp)
  181114:	0080090e 	bge	zero,r2,18113c <sweep_down+0x3c>
        /* not at minimum, adjust delay for new sweep */
	adjust_trg_delay(sweep, (sweep - 1));
  181118:	d0e01117 	ldw	r3,-32700(gp)
  18111c:	d0a01117 	ldw	r2,-32700(gp)
  181120:	10bfffc4 	addi	r2,r2,-1
  181124:	1809883a 	mov	r4,r3
  181128:	100b883a 	mov	r5,r2
  18112c:	01815d40 	call	1815d4 <adjust_trg_delay>
	/* now set new sweep rate */
        sweep--;
  181130:	d0a01117 	ldw	r2,-32700(gp)
  181134:	10bfffc4 	addi	r2,r2,-1
  181138:	d0a01115 	stw	r2,-32700(gp)
    }

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  18113c:	d0a01117 	ldw	r2,-32700(gp)
  181140:	00c00634 	movhi	r3,24
  181144:	18d71c04 	addi	r3,r3,23664
  181148:	100490fa 	slli	r2,r2,3
  18114c:	1885883a 	add	r2,r3,r2
  181150:	10800017 	ldw	r2,0(r2)
  181154:	1009883a 	mov	r4,r2
  181158:	0182d500 	call	182d50 <set_sample_rate>
  18115c:	e0bfff15 	stw	r2,-4(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  181160:	e13fff17 	ldw	r4,-4(fp)
  181164:	0181d000 	call	181d00 <set_trace_size>


    /* all done with lowering the sweep rate - return */
    return;
  181168:	0001883a 	nop

}
  18116c:	e037883a 	mov	sp,fp
  181170:	dfc00117 	ldw	ra,4(sp)
  181174:	df000017 	ldw	fp,0(sp)
  181178:	dec00204 	addi	sp,sp,8
  18117c:	f800283a 	ret

00181180 <sweep_up>:
   Last Modified:    Mar. 8, 1994

*/

void  sweep_up()
{
  181180:	defffd04 	addi	sp,sp,-12
  181184:	dfc00215 	stw	ra,8(sp)
  181188:	df000115 	stw	fp,4(sp)
  18118c:	df000104 	addi	fp,sp,4
    int  sample_size;		/* sample size for the new sweep rate */



    /* increase the sweep rate, if not already the maximum */
    if (sweep < (NO_SWEEP_RATES - 1))  {
  181190:	d0a01117 	ldw	r2,-32700(gp)
  181194:	10800468 	cmpgeui	r2,r2,17
  181198:	1000091e 	bne	r2,zero,1811c0 <sweep_up+0x40>
        /* not at maximum, adjust delay for new sweep */
	adjust_trg_delay(sweep, (sweep + 1));
  18119c:	d0e01117 	ldw	r3,-32700(gp)
  1811a0:	d0a01117 	ldw	r2,-32700(gp)
  1811a4:	10800044 	addi	r2,r2,1
  1811a8:	1809883a 	mov	r4,r3
  1811ac:	100b883a 	mov	r5,r2
  1811b0:	01815d40 	call	1815d4 <adjust_trg_delay>
	/* now set new sweep rate */
        sweep++;
  1811b4:	d0a01117 	ldw	r2,-32700(gp)
  1811b8:	10800044 	addi	r2,r2,1
  1811bc:	d0a01115 	stw	r2,-32700(gp)
    }

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  1811c0:	d0a01117 	ldw	r2,-32700(gp)
  1811c4:	00c00634 	movhi	r3,24
  1811c8:	18d71c04 	addi	r3,r3,23664
  1811cc:	100490fa 	slli	r2,r2,3
  1811d0:	1885883a 	add	r2,r3,r2
  1811d4:	10800017 	ldw	r2,0(r2)
  1811d8:	1009883a 	mov	r4,r2
  1811dc:	0182d500 	call	182d50 <set_sample_rate>
  1811e0:	e0bfff15 	stw	r2,-4(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  1811e4:	e13fff17 	ldw	r4,-4(fp)
  1811e8:	0181d000 	call	181d00 <set_trace_size>


    /* all done with raising the sweep rate - return */
    return;
  1811ec:	0001883a 	nop

}
  1811f0:	e037883a 	mov	sp,fp
  1811f4:	dfc00117 	ldw	ra,4(sp)
  1811f8:	df000017 	ldw	fp,0(sp)
  1811fc:	dec00204 	addi	sp,sp,8
  181200:	f800283a 	ret

00181204 <display_sweep>:
   Last Modified:    Mar. 8, 1994

*/

void  display_sweep(int x_pos, int y_pos, int style)
{
  181204:	defffb04 	addi	sp,sp,-20
  181208:	dfc00415 	stw	ra,16(sp)
  18120c:	df000315 	stw	fp,12(sp)
  181210:	df000304 	addi	fp,sp,12
  181214:	e13ffd15 	stw	r4,-12(fp)
  181218:	e17ffe15 	stw	r5,-8(fp)
  18121c:	e1bfff15 	stw	r6,-4(fp)
      /* none */



    /* display the sweep rate */
    plot_string(x_pos, y_pos, sweep_rates[sweep].s, style);
  181220:	d0a01117 	ldw	r2,-32700(gp)
  181224:	00c00634 	movhi	r3,24
  181228:	18d71c04 	addi	r3,r3,23664
  18122c:	100490fa 	slli	r2,r2,3
  181230:	1885883a 	add	r2,r3,r2
  181234:	10800104 	addi	r2,r2,4
  181238:	10c00017 	ldw	r3,0(r2)
  18123c:	e0bfff17 	ldw	r2,-4(fp)
  181240:	e13ffd17 	ldw	r4,-12(fp)
  181244:	e17ffe17 	ldw	r5,-8(fp)
  181248:	180d883a 	mov	r6,r3
  18124c:	100f883a 	mov	r7,r2
  181250:	01806cc0 	call	1806cc <plot_string>


    /* all done displaying the sweep rate - return */
    return;
  181254:	0001883a 	nop

}
  181258:	e037883a 	mov	sp,fp
  18125c:	dfc00117 	ldw	ra,4(sp)
  181260:	df000017 	ldw	fp,0(sp)
  181264:	dec00204 	addi	sp,sp,8
  181268:	f800283a 	ret

0018126c <set_trg_level>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_level(int l)
{
  18126c:	defffd04 	addi	sp,sp,-12
  181270:	dfc00215 	stw	ra,8(sp)
  181274:	df000115 	stw	fp,4(sp)
  181278:	df000104 	addi	fp,sp,4
  18127c:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger level */
    level = l;
  181280:	e0bfff17 	ldw	r2,-4(fp)
  181284:	d0a01215 	stw	r2,-32696(gp)

    /* set the trigger level in hardware too */
    set_trigger(level, slope);
  181288:	d0e01217 	ldw	r3,-32696(gp)
  18128c:	d0a01317 	ldw	r2,-32692(gp)
  181290:	1809883a 	mov	r4,r3
  181294:	100b883a 	mov	r5,r2
  181298:	0182da00 	call	182da0 <set_trigger>


    /* all done initializing the trigger level - return */
    return;
  18129c:	0001883a 	nop

}
  1812a0:	e037883a 	mov	sp,fp
  1812a4:	dfc00117 	ldw	ra,4(sp)
  1812a8:	df000017 	ldw	fp,0(sp)
  1812ac:	dec00204 	addi	sp,sp,8
  1812b0:	f800283a 	ret

001812b4 <trg_level_down>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_level_down()
{
  1812b4:	defffe04 	addi	sp,sp,-8
  1812b8:	dfc00115 	stw	ra,4(sp)
  1812bc:	df000015 	stw	fp,0(sp)
  1812c0:	d839883a 	mov	fp,sp
      /* none */



    /* decrease the trigger level, if not already the minimum */
    if (level > MIN_TRG_LEVEL_SET)
  1812c4:	d0a01217 	ldw	r2,-32696(gp)
  1812c8:	0080030e 	bge	zero,r2,1812d8 <trg_level_down+0x24>
        level--;
  1812cc:	d0a01217 	ldw	r2,-32696(gp)
  1812d0:	10bfffc4 	addi	r2,r2,-1
  1812d4:	d0a01215 	stw	r2,-32696(gp)

    /* set the trigger level for the hardware */
    set_trigger(level, slope);
  1812d8:	d0e01217 	ldw	r3,-32696(gp)
  1812dc:	d0a01317 	ldw	r2,-32692(gp)
  1812e0:	1809883a 	mov	r4,r3
  1812e4:	100b883a 	mov	r5,r2
  1812e8:	0182da00 	call	182da0 <set_trigger>


    /* all done with lowering the trigger level - return */
    return;
  1812ec:	0001883a 	nop

}
  1812f0:	e037883a 	mov	sp,fp
  1812f4:	dfc00117 	ldw	ra,4(sp)
  1812f8:	df000017 	ldw	fp,0(sp)
  1812fc:	dec00204 	addi	sp,sp,8
  181300:	f800283a 	ret

00181304 <trg_level_up>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_level_up()
{
  181304:	defffe04 	addi	sp,sp,-8
  181308:	dfc00115 	stw	ra,4(sp)
  18130c:	df000015 	stw	fp,0(sp)
  181310:	d839883a 	mov	fp,sp
      /* none */



    /* increase the trigger level, if not already the maximum */
    if (level < MAX_TRG_LEVEL_SET)
  181314:	d0a01217 	ldw	r2,-32696(gp)
  181318:	10801fc8 	cmpgei	r2,r2,127
  18131c:	1000031e 	bne	r2,zero,18132c <trg_level_up+0x28>
        level++;
  181320:	d0a01217 	ldw	r2,-32696(gp)
  181324:	10800044 	addi	r2,r2,1
  181328:	d0a01215 	stw	r2,-32696(gp)

    /* tell the hardware the new trigger level */
    set_trigger(level, slope);
  18132c:	d0e01217 	ldw	r3,-32696(gp)
  181330:	d0a01317 	ldw	r2,-32692(gp)
  181334:	1809883a 	mov	r4,r3
  181338:	100b883a 	mov	r5,r2
  18133c:	0182da00 	call	182da0 <set_trigger>


    /* all done raising the trigger level - return */
    return;
  181340:	0001883a 	nop

}
  181344:	e037883a 	mov	sp,fp
  181348:	dfc00117 	ldw	ra,4(sp)
  18134c:	df000017 	ldw	fp,0(sp)
  181350:	dec00204 	addi	sp,sp,8
  181354:	f800283a 	ret

00181358 <display_trg_level>:
   Last Modified:    Mar. 10, 1995

*/

void  display_trg_level(int x_pos, int y_pos, int style)
{
  181358:	defff704 	addi	sp,sp,-36
  18135c:	dfc00815 	stw	ra,32(sp)
  181360:	df000715 	stw	fp,28(sp)
  181364:	df000704 	addi	fp,sp,28
  181368:	e13ffd15 	stw	r4,-12(fp)
  18136c:	e17ffe15 	stw	r5,-8(fp)
  181370:	e1bfff15 	stw	r6,-4(fp)
    /* variables */
    char      level_str[] = "        "; /* string containing the trigger level */
  181374:	00880834 	movhi	r2,8224
  181378:	10880804 	addi	r2,r2,8224
  18137c:	e0bffa15 	stw	r2,-24(fp)
  181380:	00880834 	movhi	r2,8224
  181384:	10880804 	addi	r2,r2,8224
  181388:	e0bffb15 	stw	r2,-20(fp)
  18138c:	e03ffc05 	stb	zero,-16(fp)
    long int  l;			/* trigger level in mV */



    /* compute the trigger level in millivolts */
    l = ((long int) MAX_LEVEL - MIN_LEVEL) * level / (MAX_TRG_LEVEL_SET - MIN_TRG_LEVEL_SET) + MIN_LEVEL;
  181390:	d0a01217 	ldw	r2,-32696(gp)
  181394:	1009883a 	mov	r4,r2
  181398:	01577004 	movi	r5,24000
  18139c:	01832700 	call	183270 <__mulsi3>
  1813a0:	1009883a 	mov	r4,r2
  1813a4:	01401fc4 	movi	r5,127
  1813a8:	01831b40 	call	1831b4 <__divsi3>
  1813ac:	10b44804 	addi	r2,r2,-12000
  1813b0:	e0bff915 	stw	r2,-28(fp)

    /* convert the level to the string (leave first character blank) */
    cvt_num_field(l, &level_str[1]);
  1813b4:	e0bffa04 	addi	r2,fp,-24
  1813b8:	10800044 	addi	r2,r2,1
  1813bc:	e13ff917 	ldw	r4,-28(fp)
  1813c0:	100b883a 	mov	r5,r2
  1813c4:	01818e00 	call	1818e0 <cvt_num_field>

    /* add in the units */
    level_str[7] = 'V';
  1813c8:	00801584 	movi	r2,86
  1813cc:	e0bffbc5 	stb	r2,-17(fp)


    /* now finally display the trigger level */
    plot_string(x_pos, y_pos, level_str, style);
  1813d0:	e0bfff17 	ldw	r2,-4(fp)
  1813d4:	e0fffa04 	addi	r3,fp,-24
  1813d8:	e13ffd17 	ldw	r4,-12(fp)
  1813dc:	e17ffe17 	ldw	r5,-8(fp)
  1813e0:	180d883a 	mov	r6,r3
  1813e4:	100f883a 	mov	r7,r2
  1813e8:	01806cc0 	call	1806cc <plot_string>


    /* all done displaying the trigger level - return */
    return;

}
  1813ec:	e037883a 	mov	sp,fp
  1813f0:	dfc00117 	ldw	ra,4(sp)
  1813f4:	df000017 	ldw	fp,0(sp)
  1813f8:	dec00204 	addi	sp,sp,8
  1813fc:	f800283a 	ret

00181400 <set_trg_slope>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_slope(enum slope_type s)
{
  181400:	defffd04 	addi	sp,sp,-12
  181404:	dfc00215 	stw	ra,8(sp)
  181408:	df000115 	stw	fp,4(sp)
  18140c:	df000104 	addi	fp,sp,4
  181410:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the slope type */
    slope = s;
  181414:	e0bfff17 	ldw	r2,-4(fp)
  181418:	d0a01315 	stw	r2,-32692(gp)

    /* also tell the hardware what the slope is */
    set_trigger(level, slope);
  18141c:	d0e01217 	ldw	r3,-32696(gp)
  181420:	d0a01317 	ldw	r2,-32692(gp)
  181424:	1809883a 	mov	r4,r3
  181428:	100b883a 	mov	r5,r2
  18142c:	0182da00 	call	182da0 <set_trigger>


    /* all done setting the trigger slope - return */
    return;
  181430:	0001883a 	nop

}
  181434:	e037883a 	mov	sp,fp
  181438:	dfc00117 	ldw	ra,4(sp)
  18143c:	df000017 	ldw	fp,0(sp)
  181440:	dec00204 	addi	sp,sp,8
  181444:	f800283a 	ret

00181448 <trg_slope_toggle>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_slope_toggle()
{
  181448:	defffe04 	addi	sp,sp,-8
  18144c:	dfc00115 	stw	ra,4(sp)
  181450:	df000015 	stw	fp,0(sp)
  181454:	d839883a 	mov	fp,sp
      /* none */



    /* toggle the trigger slope */
    if (slope == SLOPE_POSITIVE)
  181458:	d0a01317 	ldw	r2,-32692(gp)
  18145c:	1000031e 	bne	r2,zero,18146c <trg_slope_toggle+0x24>
        slope = SLOPE_NEGATIVE;
  181460:	00800044 	movi	r2,1
  181464:	d0a01315 	stw	r2,-32692(gp)
  181468:	00000106 	br	181470 <trg_slope_toggle+0x28>
    else
        slope = SLOPE_POSITIVE;
  18146c:	d0201315 	stw	zero,-32692(gp)

    /* set the new trigger slope */
    set_trigger(level, slope);
  181470:	d0e01217 	ldw	r3,-32696(gp)
  181474:	d0a01317 	ldw	r2,-32692(gp)
  181478:	1809883a 	mov	r4,r3
  18147c:	100b883a 	mov	r5,r2
  181480:	0182da00 	call	182da0 <set_trigger>


    /* all done with the trigger slope - return */
    return;
  181484:	0001883a 	nop

}
  181488:	e037883a 	mov	sp,fp
  18148c:	dfc00117 	ldw	ra,4(sp)
  181490:	df000017 	ldw	fp,0(sp)
  181494:	dec00204 	addi	sp,sp,8
  181498:	f800283a 	ret

0018149c <display_trg_slope>:
   Last Modified:    Mar. 13, 1994

*/

void  display_trg_slope(int x_pos, int y_pos, int style)
{
  18149c:	defffb04 	addi	sp,sp,-20
  1814a0:	dfc00415 	stw	ra,16(sp)
  1814a4:	df000315 	stw	fp,12(sp)
  1814a8:	df000304 	addi	fp,sp,12
  1814ac:	e13ffd15 	stw	r4,-12(fp)
  1814b0:	e17ffe15 	stw	r5,-8(fp)
  1814b4:	e1bfff15 	stw	r6,-4(fp)
    const static char * const  slopes[] =  {  " +", " -"  };



    /* display the trigger slope */
    plot_string(x_pos, y_pos, slopes[slope], style);
  1814b8:	d0a01317 	ldw	r2,-32692(gp)
  1814bc:	1085883a 	add	r2,r2,r2
  1814c0:	1087883a 	add	r3,r2,r2
  1814c4:	d0a00004 	addi	r2,gp,-32768
  1814c8:	1885883a 	add	r2,r3,r2
  1814cc:	10c00017 	ldw	r3,0(r2)
  1814d0:	e0bfff17 	ldw	r2,-4(fp)
  1814d4:	e13ffd17 	ldw	r4,-12(fp)
  1814d8:	e17ffe17 	ldw	r5,-8(fp)
  1814dc:	180d883a 	mov	r6,r3
  1814e0:	100f883a 	mov	r7,r2
  1814e4:	01806cc0 	call	1806cc <plot_string>


    /* all done displaying the trigger slope - return */
    return;
  1814e8:	0001883a 	nop

}
  1814ec:	e037883a 	mov	sp,fp
  1814f0:	dfc00117 	ldw	ra,4(sp)
  1814f4:	df000017 	ldw	fp,0(sp)
  1814f8:	dec00204 	addi	sp,sp,8
  1814fc:	f800283a 	ret

00181500 <set_trg_delay>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_delay(long int d)
{
  181500:	defffd04 	addi	sp,sp,-12
  181504:	dfc00215 	stw	ra,8(sp)
  181508:	df000115 	stw	fp,4(sp)
  18150c:	df000104 	addi	fp,sp,4
  181510:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger delay */
    delay = d;
  181514:	e0bfff17 	ldw	r2,-4(fp)
  181518:	d0a01415 	stw	r2,-32688(gp)

    /* set the trigger delay in hardware too */
    set_delay(delay);
  18151c:	d0a01417 	ldw	r2,-32688(gp)
  181520:	1009883a 	mov	r4,r2
  181524:	0182df00 	call	182df0 <set_delay>


    /* all done initializing the trigger delay - return */
    return;
  181528:	0001883a 	nop

}
  18152c:	e037883a 	mov	sp,fp
  181530:	dfc00117 	ldw	ra,4(sp)
  181534:	df000017 	ldw	fp,0(sp)
  181538:	dec00204 	addi	sp,sp,8
  18153c:	f800283a 	ret

00181540 <trg_delay_down>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_delay_down()
{
  181540:	defffe04 	addi	sp,sp,-8
  181544:	dfc00115 	stw	ra,4(sp)
  181548:	df000015 	stw	fp,0(sp)
  18154c:	d839883a 	mov	fp,sp
      /* none */



    /* decrease the trigger delay, if not already the minimum */
    if (delay > MIN_DELAY)
  181550:	d0a01417 	ldw	r2,-32688(gp)
  181554:	0080030e 	bge	zero,r2,181564 <trg_delay_down+0x24>
        delay--;
  181558:	d0a01417 	ldw	r2,-32688(gp)
  18155c:	10bfffc4 	addi	r2,r2,-1
  181560:	d0a01415 	stw	r2,-32688(gp)

    /* set the trigger delay for the hardware */
    set_delay(delay);
  181564:	d0a01417 	ldw	r2,-32688(gp)
  181568:	1009883a 	mov	r4,r2
  18156c:	0182df00 	call	182df0 <set_delay>


    /* all done with lowering the trigger delay - return */
    return;
  181570:	0001883a 	nop

}
  181574:	e037883a 	mov	sp,fp
  181578:	dfc00117 	ldw	ra,4(sp)
  18157c:	df000017 	ldw	fp,0(sp)
  181580:	dec00204 	addi	sp,sp,8
  181584:	f800283a 	ret

00181588 <trg_delay_up>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_delay_up()
{
  181588:	defffe04 	addi	sp,sp,-8
  18158c:	dfc00115 	stw	ra,4(sp)
  181590:	df000015 	stw	fp,0(sp)
  181594:	d839883a 	mov	fp,sp
      /* none */



    /* increase the trigger delay, if not already the maximum */
    if (delay < MAX_DELAY)
  181598:	d0a01417 	ldw	r2,-32688(gp)
  18159c:	00ffff44 	movi	r3,-3
  1815a0:	18800336 	bltu	r3,r2,1815b0 <trg_delay_up+0x28>
        delay++;
  1815a4:	d0a01417 	ldw	r2,-32688(gp)
  1815a8:	10800044 	addi	r2,r2,1
  1815ac:	d0a01415 	stw	r2,-32688(gp)

    /* tell the hardware the new trigger delay */
    set_delay(delay);
  1815b0:	d0a01417 	ldw	r2,-32688(gp)
  1815b4:	1009883a 	mov	r4,r2
  1815b8:	0182df00 	call	182df0 <set_delay>


    /* all done raising the trigger delay - return */
    return;
  1815bc:	0001883a 	nop

}
  1815c0:	e037883a 	mov	sp,fp
  1815c4:	dfc00117 	ldw	ra,4(sp)
  1815c8:	df000017 	ldw	fp,0(sp)
  1815cc:	dec00204 	addi	sp,sp,8
  1815d0:	f800283a 	ret

001815d4 <adjust_trg_delay>:
   Last Modified:    Mar. 8, 1994

*/

static void  adjust_trg_delay(int old_sweep, int new_sweep)
{
  1815d4:	defffc04 	addi	sp,sp,-16
  1815d8:	dfc00315 	stw	ra,12(sp)
  1815dc:	df000215 	stw	fp,8(sp)
  1815e0:	df000204 	addi	fp,sp,8
  1815e4:	e13ffe15 	stw	r4,-8(fp)
  1815e8:	e17fff15 	stw	r5,-4(fp)
      /* none */



    /* multiply by 10 times the ratio of sweep rates */
    delay *= (10 * sweep_rates[new_sweep].sample_rate) / sweep_rates[old_sweep].sample_rate;
  1815ec:	00c00634 	movhi	r3,24
  1815f0:	18d71c04 	addi	r3,r3,23664
  1815f4:	e0bfff17 	ldw	r2,-4(fp)
  1815f8:	100490fa 	slli	r2,r2,3
  1815fc:	1885883a 	add	r2,r3,r2
  181600:	10800017 	ldw	r2,0(r2)
  181604:	1009883a 	mov	r4,r2
  181608:	01400284 	movi	r5,10
  18160c:	01832700 	call	183270 <__mulsi3>
  181610:	1007883a 	mov	r3,r2
  181614:	01000634 	movhi	r4,24
  181618:	21171c04 	addi	r4,r4,23664
  18161c:	e0bffe17 	ldw	r2,-8(fp)
  181620:	100490fa 	slli	r2,r2,3
  181624:	2085883a 	add	r2,r4,r2
  181628:	10800017 	ldw	r2,0(r2)
  18162c:	1809883a 	mov	r4,r3
  181630:	100b883a 	mov	r5,r2
  181634:	01831b40 	call	1831b4 <__divsi3>
  181638:	1007883a 	mov	r3,r2
  18163c:	d0a01417 	ldw	r2,-32688(gp)
  181640:	1809883a 	mov	r4,r3
  181644:	100b883a 	mov	r5,r2
  181648:	01832700 	call	183270 <__mulsi3>
  18164c:	d0a01415 	stw	r2,-32688(gp)
    /* now divide the factor of 10 back out */
    delay /= 10;
  181650:	d0a01417 	ldw	r2,-32688(gp)
  181654:	1009883a 	mov	r4,r2
  181658:	01400284 	movi	r5,10
  18165c:	01831b40 	call	1831b4 <__divsi3>
  181660:	d0a01415 	stw	r2,-32688(gp)

    /* make sure delay is not out of range */
    if (delay > MAX_DELAY)
  181664:	d0a01417 	ldw	r2,-32688(gp)
  181668:	10bfffd8 	cmpnei	r2,r2,-1
  18166c:	1000021e 	bne	r2,zero,181678 <adjust_trg_delay+0xa4>
        /* delay is too large - set to maximum */
        delay = MAX_DELAY;
  181670:	00bfff84 	movi	r2,-2
  181674:	d0a01415 	stw	r2,-32688(gp)
    if (delay < MIN_DELAY)
  181678:	d0a01417 	ldw	r2,-32688(gp)
  18167c:	1000010e 	bge	r2,zero,181684 <adjust_trg_delay+0xb0>
        /* delay is too small - set to minimum */
	delay = MIN_DELAY;
  181680:	d0201415 	stw	zero,-32688(gp)


    /* tell the hardware the new trigger delay */
    set_delay(delay);
  181684:	d0a01417 	ldw	r2,-32688(gp)
  181688:	1009883a 	mov	r4,r2
  18168c:	0182df00 	call	182df0 <set_delay>


    /* all done adjusting the trigger delay - return */
    return;
  181690:	0001883a 	nop

}
  181694:	e037883a 	mov	sp,fp
  181698:	dfc00117 	ldw	ra,4(sp)
  18169c:	df000017 	ldw	fp,0(sp)
  1816a0:	dec00204 	addi	sp,sp,8
  1816a4:	f800283a 	ret

001816a8 <display_trg_delay>:
   Last Modified:    June 11, 2014

*/

void  display_trg_delay(int x_pos, int y_pos, int style)
{
  1816a8:	defff504 	addi	sp,sp,-44
  1816ac:	dfc00a15 	stw	ra,40(sp)
  1816b0:	df000915 	stw	fp,36(sp)
  1816b4:	df000904 	addi	fp,sp,36
  1816b8:	e13ffd15 	stw	r4,-12(fp)
  1816bc:	e17ffe15 	stw	r5,-8(fp)
  1816c0:	e1bfff15 	stw	r6,-4(fp)
    /* variables */
    char      delay_str[] = "         "; /* string containing the trigger delay */
  1816c4:	00880834 	movhi	r2,8224
  1816c8:	10880804 	addi	r2,r2,8224
  1816cc:	e0bffa15 	stw	r2,-24(fp)
  1816d0:	00880834 	movhi	r2,8224
  1816d4:	10880804 	addi	r2,r2,8224
  1816d8:	e0bffb15 	stw	r2,-20(fp)
  1816dc:	00800804 	movi	r2,32
  1816e0:	e0bffc0d 	sth	r2,-16(fp)
    long int  d;                         /* delay in appropriate units */
    float     temp_d; 					 /* delay in float to avoid overflows */

    /* compute the delay in the appropriate units */
    /* have to watch out for overflow, so use float temp */
    if (sweep_rates[sweep].sample_rate > 1000000L)  {
  1816e4:	d0a01117 	ldw	r2,-32700(gp)
  1816e8:	00c00634 	movhi	r3,24
  1816ec:	18d71c04 	addi	r3,r3,23664
  1816f0:	100490fa 	slli	r2,r2,3
  1816f4:	1885883a 	add	r2,r3,r2
  1816f8:	10800017 	ldw	r2,0(r2)
  1816fc:	00c003f4 	movhi	r3,15
  181700:	18d09004 	addi	r3,r3,16960
  181704:	1880190e 	bge	r3,r2,18176c <display_trg_delay+0xc4>
        /* have a fast sweep rate  */
        /* first compute with float to avoid overflow */
    	temp_d = delay * (1000000000L / sweep_rates[sweep].sample_rate);
  181708:	d0a01117 	ldw	r2,-32700(gp)
  18170c:	00c00634 	movhi	r3,24
  181710:	18d71c04 	addi	r3,r3,23664
  181714:	100490fa 	slli	r2,r2,3
  181718:	1885883a 	add	r2,r3,r2
  18171c:	10800017 	ldw	r2,0(r2)
  181720:	010ee6f4 	movhi	r4,15259
  181724:	21328004 	addi	r4,r4,-13824
  181728:	100b883a 	mov	r5,r2
  18172c:	01831b40 	call	1831b4 <__divsi3>
  181730:	1007883a 	mov	r3,r2
  181734:	d0a01417 	ldw	r2,-32688(gp)
  181738:	1809883a 	mov	r4,r3
  18173c:	100b883a 	mov	r5,r2
  181740:	01832700 	call	183270 <__mulsi3>
  181744:	1009883a 	mov	r4,r2
  181748:	0182ff80 	call	182ff8 <__floatsisf>
  18174c:	1007883a 	mov	r3,r2
  181750:	e0fff915 	stw	r3,-28(fp)

	/* now convert to int */
	d = (int) temp_d;
  181754:	e13ff917 	ldw	r4,-28(fp)
  181758:	018309c0 	call	18309c <__fixsfsi>
  18175c:	e0bff815 	stw	r2,-32(fp)
	/* need to divide by 1000 to get to microseconds */
	units_adj = 1000;
  181760:	0080fa04 	movi	r2,1000
  181764:	e0bff715 	stw	r2,-36(fp)
  181768:	00001206 	br	1817b4 <display_trg_delay+0x10c>
    }
    else  {
        /* slow sweep rate, don't have to worry about overflow */
        d = delay * (1000000L / sweep_rates[sweep].sample_rate);
  18176c:	d0a01117 	ldw	r2,-32700(gp)
  181770:	00c00634 	movhi	r3,24
  181774:	18d71c04 	addi	r3,r3,23664
  181778:	100490fa 	slli	r2,r2,3
  18177c:	1885883a 	add	r2,r3,r2
  181780:	10800017 	ldw	r2,0(r2)
  181784:	010003f4 	movhi	r4,15
  181788:	21109004 	addi	r4,r4,16960
  18178c:	100b883a 	mov	r5,r2
  181790:	01831b40 	call	1831b4 <__divsi3>
  181794:	1007883a 	mov	r3,r2
  181798:	d0a01417 	ldw	r2,-32688(gp)
  18179c:	1809883a 	mov	r4,r3
  1817a0:	100b883a 	mov	r5,r2
  1817a4:	01832700 	call	183270 <__mulsi3>
  1817a8:	e0bff815 	stw	r2,-32(fp)
	/* already in microseconds, so adjustment is 1 */
	units_adj = 1;
  1817ac:	00800044 	movi	r2,1
  1817b0:	e0bff715 	stw	r2,-36(fp)
    }

    /* convert it to the string (leave first character blank) */
    cvt_num_field(d, &delay_str[1]);
  1817b4:	e0bffa04 	addi	r2,fp,-24
  1817b8:	10800044 	addi	r2,r2,1
  1817bc:	e13ff817 	ldw	r4,-32(fp)
  1817c0:	100b883a 	mov	r5,r2
  1817c4:	01818e00 	call	1818e0 <cvt_num_field>

    /* add in the units */
    if (((d / units_adj) < 1000) && ((d / units_adj) > -1000) && (units_adj == 1000)) {
  1817c8:	e13ff817 	ldw	r4,-32(fp)
  1817cc:	e17ff717 	ldw	r5,-36(fp)
  1817d0:	01831b40 	call	1831b4 <__divsi3>
  1817d4:	1080fa08 	cmpgei	r2,r2,1000
  1817d8:	10000d1e 	bne	r2,zero,181810 <display_trg_delay+0x168>
  1817dc:	e13ff817 	ldw	r4,-32(fp)
  1817e0:	e17ff717 	ldw	r5,-36(fp)
  1817e4:	01831b40 	call	1831b4 <__divsi3>
  1817e8:	10bf0650 	cmplti	r2,r2,-999
  1817ec:	1000081e 	bne	r2,zero,181810 <display_trg_delay+0x168>
  1817f0:	e0bff717 	ldw	r2,-36(fp)
  1817f4:	1080fa18 	cmpnei	r2,r2,1000
  1817f8:	1000051e 	bne	r2,zero,181810 <display_trg_delay+0x168>
        /* delay is in microseconds */
	delay_str[7] = '\004';
  1817fc:	00800104 	movi	r2,4
  181800:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
  181804:	00801cc4 	movi	r2,115
  181808:	e0bffc05 	stb	r2,-16(fp)
  18180c:	00002806 	br	1818b0 <display_trg_delay+0x208>
    }
    else if (((d / units_adj) < 1000000) && ((d / units_adj) > -1000000)) {
  181810:	e13ff817 	ldw	r4,-32(fp)
  181814:	e17ff717 	ldw	r5,-36(fp)
  181818:	01831b40 	call	1831b4 <__divsi3>
  18181c:	00c003f4 	movhi	r3,15
  181820:	18d08fc4 	addi	r3,r3,16959
  181824:	18800c16 	blt	r3,r2,181858 <display_trg_delay+0x1b0>
  181828:	e13ff817 	ldw	r4,-32(fp)
  18182c:	e17ff717 	ldw	r5,-36(fp)
  181830:	01831b40 	call	1831b4 <__divsi3>
  181834:	1007883a 	mov	r3,r2
  181838:	00bffc74 	movhi	r2,65521
  18183c:	10af7044 	addi	r2,r2,-16959
  181840:	18800516 	blt	r3,r2,181858 <display_trg_delay+0x1b0>
        /* delay is in milliseconds */
	delay_str[7] = 'm';
  181844:	00801b44 	movi	r2,109
  181848:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
  18184c:	00801cc4 	movi	r2,115
  181850:	e0bffc05 	stb	r2,-16(fp)
  181854:	00001606 	br	1818b0 <display_trg_delay+0x208>
    }
    else if (((d / units_adj) < 1000000000) && ((d / units_adj) > -1000000000))  {
  181858:	e13ff817 	ldw	r4,-32(fp)
  18185c:	e17ff717 	ldw	r5,-36(fp)
  181860:	01831b40 	call	1831b4 <__divsi3>
  181864:	00cee6f4 	movhi	r3,15259
  181868:	18f27fc4 	addi	r3,r3,-13825
  18186c:	18800c16 	blt	r3,r2,1818a0 <display_trg_delay+0x1f8>
  181870:	e13ff817 	ldw	r4,-32(fp)
  181874:	e17ff717 	ldw	r5,-36(fp)
  181878:	01831b40 	call	1831b4 <__divsi3>
  18187c:	1007883a 	mov	r3,r2
  181880:	00b11974 	movhi	r2,50277
  181884:	108d8044 	addi	r2,r2,13825
  181888:	18800516 	blt	r3,r2,1818a0 <display_trg_delay+0x1f8>
        /* delay is in seconds */
	delay_str[7] = 's';
  18188c:	00801cc4 	movi	r2,115
  181890:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = ' ';
  181894:	00800804 	movi	r2,32
  181898:	e0bffc05 	stb	r2,-16(fp)
  18189c:	00000406 	br	1818b0 <display_trg_delay+0x208>
    }
    else  {
        /* delay is in kiloseconds */
	delay_str[7] = 'k';
  1818a0:	00801ac4 	movi	r2,107
  1818a4:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
  1818a8:	00801cc4 	movi	r2,115
  1818ac:	e0bffc05 	stb	r2,-16(fp)
    }


    /* now actually display the trigger delay */
    plot_string(x_pos, y_pos, delay_str, style);
  1818b0:	e0bfff17 	ldw	r2,-4(fp)
  1818b4:	e0fffa04 	addi	r3,fp,-24
  1818b8:	e13ffd17 	ldw	r4,-12(fp)
  1818bc:	e17ffe17 	ldw	r5,-8(fp)
  1818c0:	180d883a 	mov	r6,r3
  1818c4:	100f883a 	mov	r7,r2
  1818c8:	01806cc0 	call	1806cc <plot_string>


    /* all done displaying the trigger delay - return */
    return;

}
  1818cc:	e037883a 	mov	sp,fp
  1818d0:	dfc00117 	ldw	ra,4(sp)
  1818d4:	df000017 	ldw	fp,0(sp)
  1818d8:	dec00204 	addi	sp,sp,8
  1818dc:	f800283a 	ret

001818e0 <cvt_num_field>:
   Last Modified:    Mar. 8, 1994

*/

static void  cvt_num_field(long int n, char *s)
{
  1818e0:	defff804 	addi	sp,sp,-32
  1818e4:	dfc00715 	stw	ra,28(sp)
  1818e8:	df000615 	stw	fp,24(sp)
  1818ec:	dc000515 	stw	r16,20(sp)
  1818f0:	df000504 	addi	fp,sp,20
  1818f4:	e13ffe15 	stw	r4,-8(fp)
  1818f8:	e17fff15 	stw	r5,-4(fp)
    /* variables */
    int  dp = 3;		/* digits to right of decimal point */
  1818fc:	008000c4 	movi	r2,3
  181900:	e0bffb15 	stw	r2,-20(fp)
    int  d;			/* digit weight (power of 10) */

    int  i = 0;			/* string index */
  181904:	e03ffd15 	stw	zero,-12(fp)



    /* first get the sign (and make n positive for conversion) */
    if (n < 0)  {
  181908:	e0bffe17 	ldw	r2,-8(fp)
  18190c:	10000c0e 	bge	r2,zero,181940 <cvt_num_field+0x60>
        /* n is negative, set sign and convert to positive */
	s[i++] = '-';
  181910:	e0bffd17 	ldw	r2,-12(fp)
  181914:	e0ffff17 	ldw	r3,-4(fp)
  181918:	1885883a 	add	r2,r3,r2
  18191c:	00c00b44 	movi	r3,45
  181920:	10c00005 	stb	r3,0(r2)
  181924:	e0bffd17 	ldw	r2,-12(fp)
  181928:	10800044 	addi	r2,r2,1
  18192c:	e0bffd15 	stw	r2,-12(fp)
	n = -n;
  181930:	e0bffe17 	ldw	r2,-8(fp)
  181934:	0085c83a 	sub	r2,zero,r2
  181938:	e0bffe15 	stw	r2,-8(fp)
	s[i++] = '+';
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  18193c:	00001106 	br	181984 <cvt_num_field+0xa4>
	s[i++] = '-';
	n = -n;
    }
    else  {
        /* n is positive, set sign only */
	s[i++] = '+';
  181940:	e0bffd17 	ldw	r2,-12(fp)
  181944:	e0ffff17 	ldw	r3,-4(fp)
  181948:	1885883a 	add	r2,r3,r2
  18194c:	00c00ac4 	movi	r3,43
  181950:	10c00005 	stb	r3,0(r2)
  181954:	e0bffd17 	ldw	r2,-12(fp)
  181958:	10800044 	addi	r2,r2,1
  18195c:	e0bffd15 	stw	r2,-12(fp)
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  181960:	00000806 	br	181984 <cvt_num_field+0xa4>
        /* have more than 4 digits - get rid of one */
	n /= 10;
  181964:	e0bffe17 	ldw	r2,-8(fp)
  181968:	1009883a 	mov	r4,r2
  18196c:	01400284 	movi	r5,10
  181970:	01831b40 	call	1831b4 <__divsi3>
  181974:	e0bffe15 	stw	r2,-8(fp)
	/* adjust the decimal point */
	dp--;
  181978:	e0bffb17 	ldw	r2,-20(fp)
  18197c:	10bfffc4 	addi	r2,r2,-1
  181980:	e0bffb15 	stw	r2,-20(fp)
	s[i++] = '+';
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  181984:	e0bffe17 	ldw	r2,-8(fp)
  181988:	1089c408 	cmpgei	r2,r2,10000
  18198c:	103ff51e 	bne	r2,zero,181964 <cvt_num_field+0x84>
	dp--;
    }

    /* if decimal point is non-positive, make positive */
    /* (assume will take care of adjustment with output units in this case) */
    while (dp <= 0)
  181990:	00000306 	br	1819a0 <cvt_num_field+0xc0>
       dp += 3;
  181994:	e0bffb17 	ldw	r2,-20(fp)
  181998:	108000c4 	addi	r2,r2,3
  18199c:	e0bffb15 	stw	r2,-20(fp)
	dp--;
    }

    /* if decimal point is non-positive, make positive */
    /* (assume will take care of adjustment with output units in this case) */
    while (dp <= 0)
  1819a0:	e0bffb17 	ldw	r2,-20(fp)
  1819a4:	00bffb0e 	bge	zero,r2,181994 <cvt_num_field+0xb4>
       dp += 3;


    /* adjust dp to be digits to the right of the decimal point */
    /* (assuming 4 digits) */
    dp = 4 - dp;
  1819a8:	00c00104 	movi	r3,4
  1819ac:	e0bffb17 	ldw	r2,-20(fp)
  1819b0:	1885c83a 	sub	r2,r3,r2
  1819b4:	e0bffb15 	stw	r2,-20(fp)


    /* finally, loop getting and converting digits */
    for (d = 1000; d > 0; d /= 10)  {
  1819b8:	0080fa04 	movi	r2,1000
  1819bc:	e0bffc15 	stw	r2,-16(fp)
  1819c0:	00002406 	br	181a54 <cvt_num_field+0x174>

        /* check if need decimal the decimal point now */
	if (dp-- == 0)
  1819c4:	e0bffb17 	ldw	r2,-20(fp)
  1819c8:	1005003a 	cmpeq	r2,r2,zero
  1819cc:	e0fffb17 	ldw	r3,-20(fp)
  1819d0:	18ffffc4 	addi	r3,r3,-1
  1819d4:	e0fffb15 	stw	r3,-20(fp)
  1819d8:	10803fcc 	andi	r2,r2,255
  1819dc:	10000826 	beq	r2,zero,181a00 <cvt_num_field+0x120>
	    /* time for decimal point */
	    s[i++] = '.';
  1819e0:	e0bffd17 	ldw	r2,-12(fp)
  1819e4:	e0ffff17 	ldw	r3,-4(fp)
  1819e8:	1885883a 	add	r2,r3,r2
  1819ec:	00c00b84 	movi	r3,46
  1819f0:	10c00005 	stb	r3,0(r2)
  1819f4:	e0bffd17 	ldw	r2,-12(fp)
  1819f8:	10800044 	addi	r2,r2,1
  1819fc:	e0bffd15 	stw	r2,-12(fp)

	/* get and convert this digit */
	s[i++] = (n / d) + '0';
  181a00:	e0bffd17 	ldw	r2,-12(fp)
  181a04:	e0ffff17 	ldw	r3,-4(fp)
  181a08:	18a1883a 	add	r16,r3,r2
  181a0c:	e13ffe17 	ldw	r4,-8(fp)
  181a10:	e17ffc17 	ldw	r5,-16(fp)
  181a14:	01831b40 	call	1831b4 <__divsi3>
  181a18:	10800c04 	addi	r2,r2,48
  181a1c:	80800005 	stb	r2,0(r16)
  181a20:	e0bffd17 	ldw	r2,-12(fp)
  181a24:	10800044 	addi	r2,r2,1
  181a28:	e0bffd15 	stw	r2,-12(fp)
	/* remove this digit from n */
	n %= d;
  181a2c:	e0bffe17 	ldw	r2,-8(fp)
  181a30:	1009883a 	mov	r4,r2
  181a34:	e17ffc17 	ldw	r5,-16(fp)
  181a38:	01832040 	call	183204 <__modsi3>
  181a3c:	e0bffe15 	stw	r2,-8(fp)
    /* (assuming 4 digits) */
    dp = 4 - dp;


    /* finally, loop getting and converting digits */
    for (d = 1000; d > 0; d /= 10)  {
  181a40:	e0bffc17 	ldw	r2,-16(fp)
  181a44:	1009883a 	mov	r4,r2
  181a48:	01400284 	movi	r5,10
  181a4c:	01831b40 	call	1831b4 <__divsi3>
  181a50:	e0bffc15 	stw	r2,-16(fp)
  181a54:	e0bffc17 	ldw	r2,-16(fp)
  181a58:	00bfda16 	blt	zero,r2,1819c4 <cvt_num_field+0xe4>
	n %= d;
    }


    /* all done converting the number, return */
    return;
  181a5c:	0001883a 	nop

}
  181a60:	e037883a 	mov	sp,fp
  181a64:	dfc00217 	ldw	ra,8(sp)
  181a68:	df000117 	ldw	fp,4(sp)
  181a6c:	dc000017 	ldw	r16,0(sp)
  181a70:	dec00304 	addi	sp,sp,12
  181a74:	f800283a 	ret

00181a78 <get_test_sample>:
   Last Modified:    May 3, 2006

*/

void  get_test_sample(long int sample_rate, int sample_size, unsigned char *sample)
{
  181a78:	defff904 	addi	sp,sp,-28
  181a7c:	dfc00615 	stw	ra,24(sp)
  181a80:	df000515 	stw	fp,20(sp)
  181a84:	df000504 	addi	fp,sp,20
  181a88:	e13ffd15 	stw	r4,-12(fp)
  181a8c:	e17ffe15 	stw	r5,-8(fp)
  181a90:	e1bfff15 	stw	r6,-4(fp)
	    63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
	    63,  63,  63,  63,  63,  63,  64,  64,  64,  64,  64,  64,  64,
	    64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64
	  };

    long int  sample_pt = 0;	/* current sample within the waveform */
  181a94:	e03ffb15 	stw	zero,-20(fp)

    int       sample_sign = 1;	/* sample waveform sign */
  181a98:	00800044 	movi	r2,1
  181a9c:	e0bffc15 	stw	r2,-16(fp)



    /* loop, getting sample points */
    while (sample_size-- > 0)  {
  181aa0:	00003306 	br	181b70 <get_test_sample+0xf8>

        /* get this sample point (value based on sign) */
	if (sample_sign > 0)
  181aa4:	e0bffc17 	ldw	r2,-16(fp)
  181aa8:	0080100e 	bge	zero,r2,181aec <get_test_sample+0x74>
	    *sample++ = waveform[sample_pt/20] + 127;
  181aac:	e0bffb17 	ldw	r2,-20(fp)
  181ab0:	1009883a 	mov	r4,r2
  181ab4:	01400504 	movi	r5,20
  181ab8:	01831b40 	call	1831b4 <__divsi3>
  181abc:	00c00634 	movhi	r3,24
  181ac0:	18d75704 	addi	r3,r3,23900
  181ac4:	1885883a 	add	r2,r3,r2
  181ac8:	10800003 	ldbu	r2,0(r2)
  181acc:	10801fc4 	addi	r2,r2,127
  181ad0:	1007883a 	mov	r3,r2
  181ad4:	e0bfff17 	ldw	r2,-4(fp)
  181ad8:	10c00005 	stb	r3,0(r2)
  181adc:	e0bfff17 	ldw	r2,-4(fp)
  181ae0:	10800044 	addi	r2,r2,1
  181ae4:	e0bfff15 	stw	r2,-4(fp)
  181ae8:	00001006 	br	181b2c <get_test_sample+0xb4>
	else
	    *sample++ = 128 - waveform[sample_pt/20];
  181aec:	e0bffb17 	ldw	r2,-20(fp)
  181af0:	1009883a 	mov	r4,r2
  181af4:	01400504 	movi	r5,20
  181af8:	01831b40 	call	1831b4 <__divsi3>
  181afc:	00c00634 	movhi	r3,24
  181b00:	18d75704 	addi	r3,r3,23900
  181b04:	1885883a 	add	r2,r3,r2
  181b08:	10800003 	ldbu	r2,0(r2)
  181b0c:	00ffe004 	movi	r3,-128
  181b10:	1885c83a 	sub	r2,r3,r2
  181b14:	1007883a 	mov	r3,r2
  181b18:	e0bfff17 	ldw	r2,-4(fp)
  181b1c:	10c00005 	stb	r3,0(r2)
  181b20:	e0bfff17 	ldw	r2,-4(fp)
  181b24:	10800044 	addi	r2,r2,1
  181b28:	e0bfff15 	stw	r2,-4(fp)

	/* compute the time for the next sample point */
	sample_pt += (10000000L / sample_rate);
  181b2c:	01002674 	movhi	r4,153
  181b30:	2125a004 	addi	r4,r4,-27008
  181b34:	e17ffd17 	ldw	r5,-12(fp)
  181b38:	01831b40 	call	1831b4 <__divsi3>
  181b3c:	e0fffb17 	ldw	r3,-20(fp)
  181b40:	1885883a 	add	r2,r3,r2
  181b44:	e0bffb15 	stw	r2,-20(fp)
	/* keep sample_pt within the waveform (need to scale it) */
	while (sample_pt >= (20 * NO_TEST_PTS))  {
  181b48:	00000606 	br	181b64 <get_test_sample+0xec>
	    /* keep sample_pt within the test waveform */
	    sample_pt -= (20 * NO_TEST_PTS);
  181b4c:	e0bffb17 	ldw	r2,-20(fp)
  181b50:	10b6a004 	addi	r2,r2,-9600
  181b54:	e0bffb15 	stw	r2,-20(fp)
	    /* each time through the waveform, invert it */
	    sample_sign = -sample_sign;
  181b58:	e0bffc17 	ldw	r2,-16(fp)
  181b5c:	0085c83a 	sub	r2,zero,r2
  181b60:	e0bffc15 	stw	r2,-16(fp)
	    *sample++ = 128 - waveform[sample_pt/20];

	/* compute the time for the next sample point */
	sample_pt += (10000000L / sample_rate);
	/* keep sample_pt within the waveform (need to scale it) */
	while (sample_pt >= (20 * NO_TEST_PTS))  {
  181b64:	e0bffb17 	ldw	r2,-20(fp)
  181b68:	10896028 	cmpgeui	r2,r2,9600
  181b6c:	103ff71e 	bne	r2,zero,181b4c <get_test_sample+0xd4>
    int       sample_sign = 1;	/* sample waveform sign */



    /* loop, getting sample points */
    while (sample_size-- > 0)  {
  181b70:	e0bffe17 	ldw	r2,-8(fp)
  181b74:	0084803a 	cmplt	r2,zero,r2
  181b78:	e0fffe17 	ldw	r3,-8(fp)
  181b7c:	18ffffc4 	addi	r3,r3,-1
  181b80:	e0fffe15 	stw	r3,-8(fp)
  181b84:	10803fcc 	andi	r2,r2,255
  181b88:	103fc61e 	bne	r2,zero,181aa4 <get_test_sample+0x2c>
        }
    }


    /* done getting the sample - return */
    return;
  181b8c:	0001883a 	nop

}
  181b90:	e037883a 	mov	sp,fp
  181b94:	dfc00117 	ldw	ra,4(sp)
  181b98:	df000017 	ldw	fp,0(sp)
  181b9c:	dec00204 	addi	sp,sp,8
  181ba0:	f800283a 	ret

00181ba4 <init_trace>:
   Last Modified:    May 9, 2006

*/

void  init_trace()
{
  181ba4:	defffe04 	addi	sp,sp,-8
  181ba8:	dfc00115 	stw	ra,4(sp)
  181bac:	df000015 	stw	fp,0(sp)
  181bb0:	d839883a 	mov	fp,sp


    /* initialize system status variables */

    /* ready for a trace */
    trace_status = TRUE;
  181bb4:	00800044 	movi	r2,1
  181bb8:	d0a01515 	stw	r2,-32684(gp)

    /* not currently sampling data */
    sampling = FALSE;
  181bbc:	d0201615 	stw	zero,-32680(gp)

    /* turn off the displayed scale */
    cur_scale = SCALE_NONE;
  181bc0:	d0201815 	stw	zero,-32672(gp)

    /* sample size is the screen size */
    sample_size = SIZE_X;
  181bc4:	00807804 	movi	r2,480
  181bc8:	d0a01715 	stw	r2,-32676(gp)


    /* clear save areas */
    clear_saved_areas();
  181bcc:	01821300 	call	182130 <clear_saved_areas>

    /* also clear the general saved area location variables (off-screen) */
    saved_pos_x = SIZE_X + 1;
  181bd0:	00807844 	movi	r2,481
  181bd4:	d0a01915 	stw	r2,-32668(gp)
    saved_pos_y = SIZE_Y + 1;
  181bd8:	00804444 	movi	r2,273
  181bdc:	d0a01a15 	stw	r2,-32664(gp)
    saved_end_x = SIZE_X + 1;
  181be0:	00807844 	movi	r2,481
  181be4:	d0a01b15 	stw	r2,-32660(gp)
    saved_end_y = SIZE_Y + 1;
  181be8:	00804444 	movi	r2,273
  181bec:	d0a01c15 	stw	r2,-32656(gp)


    /* done initializing, return */
    return;
  181bf0:	0001883a 	nop

}
  181bf4:	e037883a 	mov	sp,fp
  181bf8:	dfc00117 	ldw	ra,4(sp)
  181bfc:	df000017 	ldw	fp,0(sp)
  181c00:	dec00204 	addi	sp,sp,8
  181c04:	f800283a 	ret

00181c08 <set_mode>:
   Last Modified:    May 27, 2008

*/

void  set_mode(enum trigger_type trigger_mode)
{
  181c08:	defffe04 	addi	sp,sp,-8
  181c0c:	df000115 	stw	fp,4(sp)
  181c10:	df000104 	addi	fp,sp,4
  181c14:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* if not one-shot triggering - ready for trace too */
    trace_status = (trigger_mode != ONESHOT_TRIGGER);
  181c18:	e0bfff17 	ldw	r2,-4(fp)
  181c1c:	10800098 	cmpnei	r2,r2,2
  181c20:	10803fcc 	andi	r2,r2,255
  181c24:	d0a01515 	stw	r2,-32684(gp)


    /* turn off the sampling flag so will start a new sample */
    sampling = FALSE;
  181c28:	d0201615 	stw	zero,-32680(gp)


    /* all done, return */
    return;
  181c2c:	0001883a 	nop

}
  181c30:	e037883a 	mov	sp,fp
  181c34:	df000017 	ldw	fp,0(sp)
  181c38:	dec00104 	addi	sp,sp,4
  181c3c:	f800283a 	ret

00181c40 <is_sampling>:
   Last Modified:    May 27, 2008

*/

int  is_sampling()
{
  181c40:	deffff04 	addi	sp,sp,-4
  181c44:	df000015 	stw	fp,0(sp)
  181c48:	d839883a 	mov	fp,sp
      /* none */



    /* currently sampling if sampling flag is set */
    return  sampling;
  181c4c:	d0a01617 	ldw	r2,-32680(gp)

}
  181c50:	e037883a 	mov	sp,fp
  181c54:	df000017 	ldw	fp,0(sp)
  181c58:	dec00104 	addi	sp,sp,4
  181c5c:	f800283a 	ret

00181c60 <trace_rdy>:
   Last Modified:    Mar. 13, 1994

*/

int  trace_rdy()
{
  181c60:	deffff04 	addi	sp,sp,-4
  181c64:	df000015 	stw	fp,0(sp)
  181c68:	d839883a 	mov	fp,sp
      /* none */



    /* ready for another trace if not sampling and trace is ready */
    return  (!sampling && trace_status);
  181c6c:	d0a01617 	ldw	r2,-32680(gp)
  181c70:	1000041e 	bne	r2,zero,181c84 <trace_rdy+0x24>
  181c74:	d0a01517 	ldw	r2,-32684(gp)
  181c78:	10000226 	beq	r2,zero,181c84 <trace_rdy+0x24>
  181c7c:	00800044 	movi	r2,1
  181c80:	00000106 	br	181c88 <trace_rdy+0x28>
  181c84:	0005883a 	mov	r2,zero

}
  181c88:	e037883a 	mov	sp,fp
  181c8c:	df000017 	ldw	fp,0(sp)
  181c90:	dec00104 	addi	sp,sp,4
  181c94:	f800283a 	ret

00181c98 <trace_done>:
   Last Modified:    May 9, 2006

*/

void  trace_done()
{
  181c98:	defffe04 	addi	sp,sp,-8
  181c9c:	dfc00115 	stw	ra,4(sp)
  181ca0:	df000015 	stw	fp,0(sp)
  181ca4:	d839883a 	mov	fp,sp
      /* none */



    /* done with a trace - if retriggering, ready for another one */
    if (get_trigger_mode() != ONESHOT_TRIGGER)
  181ca8:	0180de00 	call	180de0 <get_trigger_mode>
  181cac:	108000a0 	cmpeqi	r2,r2,2
  181cb0:	1000021e 	bne	r2,zero,181cbc <trace_done+0x24>
        /* in a retriggering mode - set trace_status to TRUE (ready) */
	trace_status = TRUE;
  181cb4:	00800044 	movi	r2,1
  181cb8:	d0a01515 	stw	r2,-32684(gp)

    /* no longer sampling data */
    sampling = FALSE;
  181cbc:	d0201615 	stw	zero,-32680(gp)


    /* done so return */
    return;
  181cc0:	0001883a 	nop

}
  181cc4:	e037883a 	mov	sp,fp
  181cc8:	dfc00117 	ldw	ra,4(sp)
  181ccc:	df000017 	ldw	fp,0(sp)
  181cd0:	dec00204 	addi	sp,sp,8
  181cd4:	f800283a 	ret

00181cd8 <trace_rearm>:
   Last Modified:    Mar. 8, 1994

*/

void  trace_rearm()
{
  181cd8:	deffff04 	addi	sp,sp,-4
  181cdc:	df000015 	stw	fp,0(sp)
  181ce0:	d839883a 	mov	fp,sp
      /* none */



    /* rearm the trace - set status to ready (TRUE) */
    trace_status = TRUE;
  181ce4:	00800044 	movi	r2,1
  181ce8:	d0a01515 	stw	r2,-32684(gp)


    /* all done - return */
    return;
  181cec:	0001883a 	nop

}
  181cf0:	e037883a 	mov	sp,fp
  181cf4:	df000017 	ldw	fp,0(sp)
  181cf8:	dec00104 	addi	sp,sp,4
  181cfc:	f800283a 	ret

00181d00 <set_trace_size>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trace_size(int size)
{
  181d00:	defffe04 	addi	sp,sp,-8
  181d04:	df000115 	stw	fp,4(sp)
  181d08:	df000104 	addi	fp,sp,4
  181d0c:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the locally global sample size */
    sample_size = size;
  181d10:	e0bfff17 	ldw	r2,-4(fp)
  181d14:	d0a01715 	stw	r2,-32676(gp)


    /* all done, return */
    return;
  181d18:	0001883a 	nop

}
  181d1c:	e037883a 	mov	sp,fp
  181d20:	df000017 	ldw	fp,0(sp)
  181d24:	dec00104 	addi	sp,sp,4
  181d28:	f800283a 	ret

00181d2c <set_display_scale>:
   Last Modified:   June 03, 2014

*/

void  set_display_scale(enum scale_type scale)
{
  181d2c:	defff804 	addi	sp,sp,-32
  181d30:	dfc00715 	stw	ra,28(sp)
  181d34:	df000615 	stw	fp,24(sp)
  181d38:	dc400515 	stw	r17,20(sp)
  181d3c:	dc000415 	stw	r16,16(sp)
  181d40:	df000404 	addi	fp,sp,16
  181d44:	e13fff15 	stw	r4,-4(fp)



    /* whenever change scale type, need to clear out previous scale */
    /* unnecessary if going to SCALE_GRID or from SCALE_NONE or not changing the scale */
    if ((scale != SCALE_GRID) && (cur_scale != SCALE_NONE) && (scale != cur_scale))  {
  181d48:	e0bfff17 	ldw	r2,-4(fp)
  181d4c:	108000a0 	cmpeqi	r2,r2,2
  181d50:	1000951e 	bne	r2,zero,181fa8 <set_display_scale+0x27c>
  181d54:	d0a01817 	ldw	r2,-32672(gp)
  181d58:	10009326 	beq	r2,zero,181fa8 <set_display_scale+0x27c>
  181d5c:	d0a01817 	ldw	r2,-32672(gp)
  181d60:	e0ffff17 	ldw	r3,-4(fp)
  181d64:	18809026 	beq	r3,r2,181fa8 <set_display_scale+0x27c>

        /* need to restore the trace under the lines (tick, grid, or axis) */

	/* go through all points on horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  181d68:	00bfff84 	movi	r2,-2
  181d6c:	e0bffe15 	stw	r2,-8(fp)
  181d70:	00004206 	br	181e7c <set_display_scale+0x150>

	    /* get y position of the line */
	    p = X_AXIS_POS + j * Y_TICK_SIZE;
  181d74:	e13ffe17 	ldw	r4,-8(fp)
  181d78:	01400c04 	movi	r5,48
  181d7c:	01832700 	call	183270 <__mulsi3>
  181d80:	10802204 	addi	r2,r2,136
  181d84:	e0bffc15 	stw	r2,-16(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_Y)
  181d88:	e0bffc17 	ldw	r2,-16(fp)
  181d8c:	10804410 	cmplti	r2,r2,272
  181d90:	1000021e 	bne	r2,zero,181d9c <set_display_scale+0x70>
	        p = PLOT_SIZE_Y - 1;
  181d94:	008043c4 	movi	r2,271
  181d98:	e0bffc15 	stw	r2,-16(fp)
	    if (p < 0)
  181d9c:	e0bffc17 	ldw	r2,-16(fp)
  181da0:	1000010e 	bge	r2,zero,181da8 <set_display_scale+0x7c>
	        p = 0;
  181da4:	e03ffc15 	stw	zero,-16(fp)

	    /* look at entire horizontal line */
	    for (i = 0; i < PLOT_SIZE_X; i++)  {
  181da8:	e03ffd15 	stw	zero,-12(fp)
  181dac:	00002d06 	br	181e64 <set_display_scale+0x138>
	        /* check if this point is on or off (need to look at bits) */
		if ((saved_axis_x[j + Y_TICK_CNT][i / 8] & (0x80 >> (i % 8))) == 0)
  181db0:	e0bffe17 	ldw	r2,-8(fp)
  181db4:	10c00084 	addi	r3,r2,2
  181db8:	e0bffd17 	ldw	r2,-12(fp)
  181dbc:	1000010e 	bge	r2,zero,181dc4 <set_display_scale+0x98>
  181dc0:	108001c4 	addi	r2,r2,7
  181dc4:	1005d0fa 	srai	r2,r2,3
  181dc8:	1023883a 	mov	r17,r2
  181dcc:	040008b4 	movhi	r16,34
  181dd0:	84080704 	addi	r16,r16,8220
  181dd4:	1809883a 	mov	r4,r3
  181dd8:	01400f04 	movi	r5,60
  181ddc:	01832700 	call	183270 <__mulsi3>
  181de0:	1445883a 	add	r2,r2,r17
  181de4:	8085883a 	add	r2,r16,r2
  181de8:	10800003 	ldbu	r2,0(r2)
  181dec:	10c03fcc 	andi	r3,r2,255
  181df0:	e13ffd17 	ldw	r4,-12(fp)
  181df4:	00a00034 	movhi	r2,32768
  181df8:	108001c4 	addi	r2,r2,7
  181dfc:	2084703a 	and	r2,r4,r2
  181e00:	1000040e 	bge	r2,zero,181e14 <set_display_scale+0xe8>
  181e04:	10bfffc4 	addi	r2,r2,-1
  181e08:	013ffe04 	movi	r4,-8
  181e0c:	1104b03a 	or	r2,r2,r4
  181e10:	10800044 	addi	r2,r2,1
  181e14:	01002004 	movi	r4,128
  181e18:	2085d83a 	sra	r2,r4,r2
  181e1c:	1884703a 	and	r2,r3,r2
  181e20:	1000071e 	bne	r2,zero,181e40 <set_display_scale+0x114>
		    /* saved pixel is off */
		    plot_pixel(i, p, PIXEL_CLEAR);
  181e24:	e0fffd17 	ldw	r3,-12(fp)
  181e28:	e0bffc17 	ldw	r2,-16(fp)
  181e2c:	1809883a 	mov	r4,r3
  181e30:	100b883a 	mov	r5,r2
  181e34:	000d883a 	mov	r6,zero
  181e38:	0182bf40 	call	182bf4 <plot_pixel>
  181e3c:	00000606 	br	181e58 <set_display_scale+0x12c>
		else
		    /* saved pixel is on */
		    plot_pixel(i, p, PIXEL_TRACE);
  181e40:	e0fffd17 	ldw	r3,-12(fp)
  181e44:	e0bffc17 	ldw	r2,-16(fp)
  181e48:	1809883a 	mov	r4,r3
  181e4c:	100b883a 	mov	r5,r2
  181e50:	01a80014 	movui	r6,40960
  181e54:	0182bf40 	call	182bf4 <plot_pixel>
	        p = PLOT_SIZE_Y - 1;
	    if (p < 0)
	        p = 0;

	    /* look at entire horizontal line */
	    for (i = 0; i < PLOT_SIZE_X; i++)  {
  181e58:	e0bffd17 	ldw	r2,-12(fp)
  181e5c:	10800044 	addi	r2,r2,1
  181e60:	e0bffd15 	stw	r2,-12(fp)
  181e64:	e0bffd17 	ldw	r2,-12(fp)
  181e68:	10807810 	cmplti	r2,r2,480
  181e6c:	103fd01e 	bne	r2,zero,181db0 <set_display_scale+0x84>
    if ((scale != SCALE_GRID) && (cur_scale != SCALE_NONE) && (scale != cur_scale))  {

        /* need to restore the trace under the lines (tick, grid, or axis) */

	/* go through all points on horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  181e70:	e0bffe17 	ldw	r2,-8(fp)
  181e74:	10800044 	addi	r2,r2,1
  181e78:	e0bffe15 	stw	r2,-8(fp)
  181e7c:	e0bffe17 	ldw	r2,-8(fp)
  181e80:	108000d0 	cmplti	r2,r2,3
  181e84:	103fbb1e 	bne	r2,zero,181d74 <set_display_scale+0x48>
		    plot_pixel(i, p, PIXEL_TRACE);
	    }
	}

	/* go through all points on vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  181e88:	00bffec4 	movi	r2,-5
  181e8c:	e0bffe15 	stw	r2,-8(fp)
  181e90:	00004206 	br	181f9c <set_display_scale+0x270>

	    /* get x position of the line */
	    p = Y_AXIS_POS + j * X_TICK_SIZE;
  181e94:	e13ffe17 	ldw	r4,-8(fp)
  181e98:	01400c04 	movi	r5,48
  181e9c:	01832700 	call	183270 <__mulsi3>
  181ea0:	10803c04 	addi	r2,r2,240
  181ea4:	e0bffc15 	stw	r2,-16(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_X)
  181ea8:	e0bffc17 	ldw	r2,-16(fp)
  181eac:	10807810 	cmplti	r2,r2,480
  181eb0:	1000021e 	bne	r2,zero,181ebc <set_display_scale+0x190>
	        p = PLOT_SIZE_X - 1;
  181eb4:	008077c4 	movi	r2,479
  181eb8:	e0bffc15 	stw	r2,-16(fp)
	    if (p < 0)
  181ebc:	e0bffc17 	ldw	r2,-16(fp)
  181ec0:	1000010e 	bge	r2,zero,181ec8 <set_display_scale+0x19c>
	        p = 0;
  181ec4:	e03ffc15 	stw	zero,-16(fp)

	    /* look at entire vertical line */
	    for (i = 0; i < PLOT_SIZE_Y; i++)  {
  181ec8:	e03ffd15 	stw	zero,-12(fp)
  181ecc:	00002d06 	br	181f84 <set_display_scale+0x258>
	        /* check if this point is on or off (need to look at bits) */
		if ((saved_axis_y[j + X_TICK_CNT][i / 8] & (0x80 >> (i % 8))) == 0)
  181ed0:	e0bffe17 	ldw	r2,-8(fp)
  181ed4:	10c00144 	addi	r3,r2,5
  181ed8:	e0bffd17 	ldw	r2,-12(fp)
  181edc:	1000010e 	bge	r2,zero,181ee4 <set_display_scale+0x1b8>
  181ee0:	108001c4 	addi	r2,r2,7
  181ee4:	1005d0fa 	srai	r2,r2,3
  181ee8:	1023883a 	mov	r17,r2
  181eec:	040008b4 	movhi	r16,34
  181ef0:	84085204 	addi	r16,r16,8520
  181ef4:	1809883a 	mov	r4,r3
  181ef8:	01400884 	movi	r5,34
  181efc:	01832700 	call	183270 <__mulsi3>
  181f00:	1445883a 	add	r2,r2,r17
  181f04:	8085883a 	add	r2,r16,r2
  181f08:	10800003 	ldbu	r2,0(r2)
  181f0c:	10c03fcc 	andi	r3,r2,255
  181f10:	e13ffd17 	ldw	r4,-12(fp)
  181f14:	00a00034 	movhi	r2,32768
  181f18:	108001c4 	addi	r2,r2,7
  181f1c:	2084703a 	and	r2,r4,r2
  181f20:	1000040e 	bge	r2,zero,181f34 <set_display_scale+0x208>
  181f24:	10bfffc4 	addi	r2,r2,-1
  181f28:	013ffe04 	movi	r4,-8
  181f2c:	1104b03a 	or	r2,r2,r4
  181f30:	10800044 	addi	r2,r2,1
  181f34:	01002004 	movi	r4,128
  181f38:	2085d83a 	sra	r2,r4,r2
  181f3c:	1884703a 	and	r2,r3,r2
  181f40:	1000071e 	bne	r2,zero,181f60 <set_display_scale+0x234>
		    /* saved pixel is off */
		    plot_pixel(p, i, PIXEL_CLEAR);
  181f44:	e0fffc17 	ldw	r3,-16(fp)
  181f48:	e0bffd17 	ldw	r2,-12(fp)
  181f4c:	1809883a 	mov	r4,r3
  181f50:	100b883a 	mov	r5,r2
  181f54:	000d883a 	mov	r6,zero
  181f58:	0182bf40 	call	182bf4 <plot_pixel>
  181f5c:	00000606 	br	181f78 <set_display_scale+0x24c>
		else
		    /* saved pixel is on */
		    plot_pixel(p, i, PIXEL_TRACE);
  181f60:	e0fffc17 	ldw	r3,-16(fp)
  181f64:	e0bffd17 	ldw	r2,-12(fp)
  181f68:	1809883a 	mov	r4,r3
  181f6c:	100b883a 	mov	r5,r2
  181f70:	01a80014 	movui	r6,40960
  181f74:	0182bf40 	call	182bf4 <plot_pixel>
	        p = PLOT_SIZE_X - 1;
	    if (p < 0)
	        p = 0;

	    /* look at entire vertical line */
	    for (i = 0; i < PLOT_SIZE_Y; i++)  {
  181f78:	e0bffd17 	ldw	r2,-12(fp)
  181f7c:	10800044 	addi	r2,r2,1
  181f80:	e0bffd15 	stw	r2,-12(fp)
  181f84:	e0bffd17 	ldw	r2,-12(fp)
  181f88:	10804410 	cmplti	r2,r2,272
  181f8c:	103fd01e 	bne	r2,zero,181ed0 <set_display_scale+0x1a4>
		    plot_pixel(i, p, PIXEL_TRACE);
	    }
	}

	/* go through all points on vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  181f90:	e0bffe17 	ldw	r2,-8(fp)
  181f94:	10800044 	addi	r2,r2,1
  181f98:	e0bffe15 	stw	r2,-8(fp)
  181f9c:	e0bffe17 	ldw	r2,-8(fp)
  181fa0:	10800190 	cmplti	r2,r2,6
  181fa4:	103fbb1e 	bne	r2,zero,181e94 <set_display_scale+0x168>
	}
    }


    /* now handle the scale type appropriately */
    switch (scale)  {
  181fa8:	e0bfff17 	ldw	r2,-4(fp)
  181fac:	10005526 	beq	r2,zero,182104 <set_display_scale+0x3d8>
  181fb0:	108000e8 	cmpgeui	r2,r2,3
  181fb4:	1000541e 	bne	r2,zero,182108 <set_display_scale+0x3dc>

    	case SCALE_AXES:    /* axes for the scale */
    	case SCALE_GRID:    /* grid for the scale */

		            /* draw x lines (grid or tick marks) */
			    for (i = -Y_TICK_CNT; i <= Y_TICK_CNT; i++)  {
  181fb8:	00bfff84 	movi	r2,-2
  181fbc:	e0bffd15 	stw	r2,-12(fp)
  181fc0:	00002306 	br	182050 <set_display_scale+0x324>

				/* get y position of the line */
				p = X_AXIS_POS + i * Y_TICK_SIZE;
  181fc4:	e13ffd17 	ldw	r4,-12(fp)
  181fc8:	01400c04 	movi	r5,48
  181fcc:	01832700 	call	183270 <__mulsi3>
  181fd0:	10802204 	addi	r2,r2,136
  181fd4:	e0bffc15 	stw	r2,-16(fp)
				/* make sure it is in range */
				if (p >= PLOT_SIZE_Y)
  181fd8:	e0bffc17 	ldw	r2,-16(fp)
  181fdc:	10804410 	cmplti	r2,r2,272
  181fe0:	1000021e 	bne	r2,zero,181fec <set_display_scale+0x2c0>
				    p = PLOT_SIZE_Y - 1;
  181fe4:	008043c4 	movi	r2,271
  181fe8:	e0bffc15 	stw	r2,-16(fp)
				if (p < 0)
  181fec:	e0bffc17 	ldw	r2,-16(fp)
  181ff0:	1000010e 	bge	r2,zero,181ff8 <set_display_scale+0x2cc>
				    p = 0;
  181ff4:	e03ffc15 	stw	zero,-16(fp)

				/* should we draw a grid, an axis, or a tick mark */
				if (scale == SCALE_GRID)
  181ff8:	e0bfff17 	ldw	r2,-4(fp)
  181ffc:	10800098 	cmpnei	r2,r2,2
  182000:	1000051e 	bne	r2,zero,182018 <set_display_scale+0x2ec>
				    /* drawing a grid line */
			            plot_hline(X_GRID_START, p, (X_GRID_END - X_GRID_START));
  182004:	0009883a 	mov	r4,zero
  182008:	e17ffc17 	ldw	r5,-16(fp)
  18200c:	018077c4 	movi	r6,479
  182010:	01803d00 	call	1803d0 <plot_hline>
  182014:	00000b06 	br	182044 <set_display_scale+0x318>
				else if (i == 0)
  182018:	e0bffd17 	ldw	r2,-12(fp)
  18201c:	1000051e 	bne	r2,zero,182034 <set_display_scale+0x308>
				    /* drawing the x axis */
			            plot_hline(X_AXIS_START, p, (X_AXIS_END - X_AXIS_START));
  182020:	0009883a 	mov	r4,zero
  182024:	e17ffc17 	ldw	r5,-16(fp)
  182028:	018077c4 	movi	r6,479
  18202c:	01803d00 	call	1803d0 <plot_hline>
  182030:	00000406 	br	182044 <set_display_scale+0x318>
				else
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
  182034:	01003b84 	movi	r4,238
  182038:	e17ffc17 	ldw	r5,-16(fp)
  18203c:	01800144 	movi	r6,5
  182040:	01803d00 	call	1803d0 <plot_hline>

    	case SCALE_AXES:    /* axes for the scale */
    	case SCALE_GRID:    /* grid for the scale */

		            /* draw x lines (grid or tick marks) */
			    for (i = -Y_TICK_CNT; i <= Y_TICK_CNT; i++)  {
  182044:	e0bffd17 	ldw	r2,-12(fp)
  182048:	10800044 	addi	r2,r2,1
  18204c:	e0bffd15 	stw	r2,-12(fp)
  182050:	e0bffd17 	ldw	r2,-12(fp)
  182054:	108000d0 	cmplti	r2,r2,3
  182058:	103fda1e 	bne	r2,zero,181fc4 <set_display_scale+0x298>
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
			    }

		            /* draw y lines (grid or tick marks) */
			    for (i = -X_TICK_CNT; i <= X_TICK_CNT; i++)  {
  18205c:	00bffec4 	movi	r2,-5
  182060:	e0bffd15 	stw	r2,-12(fp)
  182064:	00002306 	br	1820f4 <set_display_scale+0x3c8>

				/* get x position of the line */
				p = Y_AXIS_POS + i * X_TICK_SIZE;
  182068:	e13ffd17 	ldw	r4,-12(fp)
  18206c:	01400c04 	movi	r5,48
  182070:	01832700 	call	183270 <__mulsi3>
  182074:	10803c04 	addi	r2,r2,240
  182078:	e0bffc15 	stw	r2,-16(fp)
				/* make sure it is in range */
				if (p >= PLOT_SIZE_X)
  18207c:	e0bffc17 	ldw	r2,-16(fp)
  182080:	10807810 	cmplti	r2,r2,480
  182084:	1000021e 	bne	r2,zero,182090 <set_display_scale+0x364>
				    p = PLOT_SIZE_X - 1;
  182088:	008077c4 	movi	r2,479
  18208c:	e0bffc15 	stw	r2,-16(fp)
			        if (p < 0)
  182090:	e0bffc17 	ldw	r2,-16(fp)
  182094:	1000010e 	bge	r2,zero,18209c <set_display_scale+0x370>
				    p = 0;
  182098:	e03ffc15 	stw	zero,-16(fp)

				/* should we draw a grid, an axis, or a tick mark */
				if (scale == SCALE_GRID)
  18209c:	e0bfff17 	ldw	r2,-4(fp)
  1820a0:	10800098 	cmpnei	r2,r2,2
  1820a4:	1000051e 	bne	r2,zero,1820bc <set_display_scale+0x390>
				    /* drawing a grid line */
			            plot_vline(p, Y_GRID_START, (Y_GRID_END - Y_GRID_START));
  1820a8:	e13ffc17 	ldw	r4,-16(fp)
  1820ac:	000b883a 	mov	r5,zero
  1820b0:	018043c4 	movi	r6,271
  1820b4:	01804800 	call	180480 <plot_vline>
  1820b8:	00000b06 	br	1820e8 <set_display_scale+0x3bc>
				else if (i == 0)
  1820bc:	e0bffd17 	ldw	r2,-12(fp)
  1820c0:	1000051e 	bne	r2,zero,1820d8 <set_display_scale+0x3ac>
				    /* drawing the y axis */
			            plot_vline(p, Y_AXIS_START, (Y_AXIS_END - Y_AXIS_START));
  1820c4:	e13ffc17 	ldw	r4,-16(fp)
  1820c8:	000b883a 	mov	r5,zero
  1820cc:	018043c4 	movi	r6,271
  1820d0:	01804800 	call	180480 <plot_vline>
  1820d4:	00000406 	br	1820e8 <set_display_scale+0x3bc>
				else
				    /* must be drawing a tick mark */
			            plot_vline(p, (X_AXIS_POS - (TICK_LEN / 2)), TICK_LEN);
  1820d8:	e13ffc17 	ldw	r4,-16(fp)
  1820dc:	01402184 	movi	r5,134
  1820e0:	01800144 	movi	r6,5
  1820e4:	01804800 	call	180480 <plot_vline>
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
			    }

		            /* draw y lines (grid or tick marks) */
			    for (i = -X_TICK_CNT; i <= X_TICK_CNT; i++)  {
  1820e8:	e0bffd17 	ldw	r2,-12(fp)
  1820ec:	10800044 	addi	r2,r2,1
  1820f0:	e0bffd15 	stw	r2,-12(fp)
  1820f4:	e0bffd17 	ldw	r2,-12(fp)
  1820f8:	10800190 	cmplti	r2,r2,6
  1820fc:	103fda1e 	bne	r2,zero,182068 <set_display_scale+0x33c>
				    /* must be drawing a tick mark */
			            plot_vline(p, (X_AXIS_POS - (TICK_LEN / 2)), TICK_LEN);
			    }

			    /* done with the axes */
			    break;
  182100:	00000106 	br	182108 <set_display_scale+0x3dc>

        case SCALE_NONE:    /* there is no scale */
			    /* already restored plot so nothing to do */
			    break;
  182104:	0001883a 	nop

    }


    /* now remember the new (now current) scale type */
    cur_scale = scale;
  182108:	e0bfff17 	ldw	r2,-4(fp)
  18210c:	d0a01815 	stw	r2,-32672(gp)


    /* scale is taken care of, return */
    return;
  182110:	0001883a 	nop

}
  182114:	e037883a 	mov	sp,fp
  182118:	dfc00317 	ldw	ra,12(sp)
  18211c:	df000217 	ldw	fp,8(sp)
  182120:	dc400117 	ldw	r17,4(sp)
  182124:	dc000017 	ldw	r16,0(sp)
  182128:	dec00404 	addi	sp,sp,16
  18212c:	f800283a 	ret

00182130 <clear_saved_areas>:
   Last Modified:    May 9, 2006

*/

void  clear_saved_areas()
{
  182130:	defffb04 	addi	sp,sp,-20
  182134:	dfc00415 	stw	ra,16(sp)
  182138:	df000315 	stw	fp,12(sp)
  18213c:	dc000215 	stw	r16,8(sp)
  182140:	df000204 	addi	fp,sp,8
    int  j;



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
  182144:	e03fff15 	stw	zero,-4(fp)
  182148:	00001506 	br	1821a0 <clear_saved_areas+0x70>
        for (i = 0; i < (SIZE_X / 8); i++)
  18214c:	e03ffe15 	stw	zero,-8(fp)
  182150:	00000d06 	br	182188 <clear_saved_areas+0x58>
            saved_axis_x[j][i] = 0;
  182154:	040008b4 	movhi	r16,34
  182158:	84080704 	addi	r16,r16,8220
  18215c:	e0bfff17 	ldw	r2,-4(fp)
  182160:	1009883a 	mov	r4,r2
  182164:	01400f04 	movi	r5,60
  182168:	01832700 	call	183270 <__mulsi3>
  18216c:	e0fffe17 	ldw	r3,-8(fp)
  182170:	10c5883a 	add	r2,r2,r3
  182174:	8085883a 	add	r2,r16,r2
  182178:	10000005 	stb	zero,0(r2)



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
  18217c:	e0bffe17 	ldw	r2,-8(fp)
  182180:	10800044 	addi	r2,r2,1
  182184:	e0bffe15 	stw	r2,-8(fp)
  182188:	e0bffe17 	ldw	r2,-8(fp)
  18218c:	10800f10 	cmplti	r2,r2,60
  182190:	103ff01e 	bne	r2,zero,182154 <clear_saved_areas+0x24>
    int  j;



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
  182194:	e0bfff17 	ldw	r2,-4(fp)
  182198:	10800044 	addi	r2,r2,1
  18219c:	e0bfff15 	stw	r2,-4(fp)
  1821a0:	e0bfff17 	ldw	r2,-4(fp)
  1821a4:	10800150 	cmplti	r2,r2,5
  1821a8:	103fe81e 	bne	r2,zero,18214c <clear_saved_areas+0x1c>
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
  1821ac:	e03fff15 	stw	zero,-4(fp)
  1821b0:	00001506 	br	182208 <clear_saved_areas+0xd8>
        for (i = 0; i < (SIZE_Y / 8); i++)
  1821b4:	e03ffe15 	stw	zero,-8(fp)
  1821b8:	00000d06 	br	1821f0 <clear_saved_areas+0xc0>
            saved_axis_y[j][i] = 0;
  1821bc:	040008b4 	movhi	r16,34
  1821c0:	84085204 	addi	r16,r16,8520
  1821c4:	e0bfff17 	ldw	r2,-4(fp)
  1821c8:	1009883a 	mov	r4,r2
  1821cc:	01400884 	movi	r5,34
  1821d0:	01832700 	call	183270 <__mulsi3>
  1821d4:	e0fffe17 	ldw	r3,-8(fp)
  1821d8:	10c5883a 	add	r2,r2,r3
  1821dc:	8085883a 	add	r2,r16,r2
  1821e0:	10000005 	stb	zero,0(r2)
    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
        for (i = 0; i < (SIZE_Y / 8); i++)
  1821e4:	e0bffe17 	ldw	r2,-8(fp)
  1821e8:	10800044 	addi	r2,r2,1
  1821ec:	e0bffe15 	stw	r2,-8(fp)
  1821f0:	e0bffe17 	ldw	r2,-8(fp)
  1821f4:	10800890 	cmplti	r2,r2,34
  1821f8:	103ff01e 	bne	r2,zero,1821bc <clear_saved_areas+0x8c>

    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
  1821fc:	e0bfff17 	ldw	r2,-4(fp)
  182200:	10800044 	addi	r2,r2,1
  182204:	e0bfff15 	stw	r2,-4(fp)
  182208:	e0bfff17 	ldw	r2,-4(fp)
  18220c:	108002d0 	cmplti	r2,r2,11
  182210:	103fe81e 	bne	r2,zero,1821b4 <clear_saved_areas+0x84>
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
  182214:	e03ffe15 	stw	zero,-8(fp)
  182218:	00001506 	br	182270 <clear_saved_areas+0x140>
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
  18221c:	e03fff15 	stw	zero,-4(fp)
  182220:	00000d06 	br	182258 <clear_saved_areas+0x128>
	    saved_menu[i][j] = 0;
  182224:	040008b4 	movhi	r16,34
  182228:	8408af84 	addi	r16,r16,8894
  18222c:	e0bffe17 	ldw	r2,-8(fp)
  182230:	1009883a 	mov	r4,r2
  182234:	01400304 	movi	r5,12
  182238:	01832700 	call	183270 <__mulsi3>
  18223c:	e0ffff17 	ldw	r3,-4(fp)
  182240:	10c5883a 	add	r2,r2,r3
  182244:	8085883a 	add	r2,r16,r2
  182248:	10000005 	stb	zero,0(r2)
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
  18224c:	e0bfff17 	ldw	r2,-4(fp)
  182250:	10800044 	addi	r2,r2,1
  182254:	e0bfff15 	stw	r2,-4(fp)
  182258:	e0bfff17 	ldw	r2,-4(fp)
  18225c:	10800310 	cmplti	r2,r2,12
  182260:	103ff01e 	bne	r2,zero,182224 <clear_saved_areas+0xf4>
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
  182264:	e0bffe17 	ldw	r2,-8(fp)
  182268:	10800044 	addi	r2,r2,1
  18226c:	e0bffe15 	stw	r2,-8(fp)
  182270:	e0bffe17 	ldw	r2,-8(fp)
  182274:	10800e10 	cmplti	r2,r2,56
  182278:	103fe81e 	bne	r2,zero,18221c <clear_saved_areas+0xec>
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
  18227c:	e03ffe15 	stw	zero,-8(fp)
  182280:	00001506 	br	1822d8 <clear_saved_areas+0x1a8>
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
  182284:	e03fff15 	stw	zero,-4(fp)
  182288:	00000d06 	br	1822c0 <clear_saved_areas+0x190>
	    saved_area[i][j] = 0;
  18228c:	040008b4 	movhi	r16,34
  182290:	84095784 	addi	r16,r16,9566
  182294:	e0bffe17 	ldw	r2,-8(fp)
  182298:	1009883a 	mov	r4,r2
  18229c:	014003c4 	movi	r5,15
  1822a0:	01832700 	call	183270 <__mulsi3>
  1822a4:	e0ffff17 	ldw	r3,-4(fp)
  1822a8:	10c5883a 	add	r2,r2,r3
  1822ac:	8085883a 	add	r2,r16,r2
  1822b0:	10000005 	stb	zero,0(r2)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
  1822b4:	e0bfff17 	ldw	r2,-4(fp)
  1822b8:	10800044 	addi	r2,r2,1
  1822bc:	e0bfff15 	stw	r2,-4(fp)
  1822c0:	e0bfff17 	ldw	r2,-4(fp)
  1822c4:	108003d0 	cmplti	r2,r2,15
  1822c8:	103ff01e 	bne	r2,zero,18228c <clear_saved_areas+0x15c>
    for (i = 0; i < MENU_SIZE_Y; i++)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
  1822cc:	e0bffe17 	ldw	r2,-8(fp)
  1822d0:	10800044 	addi	r2,r2,1
  1822d4:	e0bffe15 	stw	r2,-8(fp)
  1822d8:	e0bffe17 	ldw	r2,-8(fp)
  1822dc:	10800410 	cmplti	r2,r2,16
  1822e0:	103fe81e 	bne	r2,zero,182284 <clear_saved_areas+0x154>
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
	    saved_area[i][j] = 0;


    /* done clearing the saved areas - return */
    return;
  1822e4:	0001883a 	nop

}
  1822e8:	e037883a 	mov	sp,fp
  1822ec:	dfc00217 	ldw	ra,8(sp)
  1822f0:	df000117 	ldw	fp,4(sp)
  1822f4:	dc000017 	ldw	r16,0(sp)
  1822f8:	dec00304 	addi	sp,sp,12
  1822fc:	f800283a 	ret

00182300 <restore_menu_trace>:
   Last Modified:    June 03, 2014

*/

void  restore_menu_trace()
{
  182300:	defff904 	addi	sp,sp,-28
  182304:	dfc00615 	stw	ra,24(sp)
  182308:	df000515 	stw	fp,20(sp)
  18230c:	dc000415 	stw	r16,16(sp)
  182310:	df000404 	addi	fp,sp,16
    int  y;



    /* loop, restoring the trace under the menu */
    for (y = MENU_UL_Y; y < (MENU_UL_Y + MENU_SIZE_Y); y++)  {
  182314:	e03fff15 	stw	zero,-4(fp)
  182318:	00003406 	br	1823ec <restore_menu_trace+0xec>

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
  18231c:	00802004 	movi	r2,128
  182320:	e0bffc15 	stw	r2,-16(fp)
	bit_offset = 0;		/* first byte of the row */
  182324:	e03ffd15 	stw	zero,-12(fp)

        for (x = MENU_UL_X; x < (MENU_UL_X + MENU_SIZE_X); x++)  {
  182328:	00805e84 	movi	r2,378
  18232c:	e0bffe15 	stw	r2,-8(fp)
  182330:	00002806 	br	1823d4 <restore_menu_trace+0xd4>

	    /* check if this point is on or off (need to look at bits) */
	    if ((saved_menu[y - MENU_UL_Y][bit_offset] & bit_position) == 0)
  182334:	040008b4 	movhi	r16,34
  182338:	8408af84 	addi	r16,r16,8894
  18233c:	e0bfff17 	ldw	r2,-4(fp)
  182340:	1009883a 	mov	r4,r2
  182344:	01400304 	movi	r5,12
  182348:	01832700 	call	183270 <__mulsi3>
  18234c:	e0fffd17 	ldw	r3,-12(fp)
  182350:	10c5883a 	add	r2,r2,r3
  182354:	8085883a 	add	r2,r16,r2
  182358:	10800003 	ldbu	r2,0(r2)
  18235c:	10c03fcc 	andi	r3,r2,255
  182360:	e0bffc17 	ldw	r2,-16(fp)
  182364:	1884703a 	and	r2,r3,r2
  182368:	1000071e 	bne	r2,zero,182388 <restore_menu_trace+0x88>
	        /* saved pixel is off */
		plot_pixel(x, y, PIXEL_CLEAR);
  18236c:	e0fffe17 	ldw	r3,-8(fp)
  182370:	e0bfff17 	ldw	r2,-4(fp)
  182374:	1809883a 	mov	r4,r3
  182378:	100b883a 	mov	r5,r2
  18237c:	000d883a 	mov	r6,zero
  182380:	0182bf40 	call	182bf4 <plot_pixel>
  182384:	00000606 	br	1823a0 <restore_menu_trace+0xa0>
	    else
	        /* saved pixel is on */
		plot_pixel(x, y, PIXEL_TRACE);
  182388:	e0fffe17 	ldw	r3,-8(fp)
  18238c:	e0bfff17 	ldw	r2,-4(fp)
  182390:	1809883a 	mov	r4,r3
  182394:	100b883a 	mov	r5,r2
  182398:	01a80014 	movui	r6,40960
  18239c:	0182bf40 	call	182bf4 <plot_pixel>

	    /* move to the next bit position */
	    bit_position >>= 1;
  1823a0:	e0bffc17 	ldw	r2,-16(fp)
  1823a4:	1005d07a 	srai	r2,r2,1
  1823a8:	e0bffc15 	stw	r2,-16(fp)
	    /* check if moving to next byte */
	    if (bit_position == 0)  {
  1823ac:	e0bffc17 	ldw	r2,-16(fp)
  1823b0:	1000051e 	bne	r2,zero,1823c8 <restore_menu_trace+0xc8>
	        /* now on high bit of next byte */
		bit_position = 0x80;
  1823b4:	00802004 	movi	r2,128
  1823b8:	e0bffc15 	stw	r2,-16(fp)
		bit_offset++;
  1823bc:	e0bffd17 	ldw	r2,-12(fp)
  1823c0:	10800044 	addi	r2,r2,1
  1823c4:	e0bffd15 	stw	r2,-12(fp)

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
	bit_offset = 0;		/* first byte of the row */

        for (x = MENU_UL_X; x < (MENU_UL_X + MENU_SIZE_X); x++)  {
  1823c8:	e0bffe17 	ldw	r2,-8(fp)
  1823cc:	10800044 	addi	r2,r2,1
  1823d0:	e0bffe15 	stw	r2,-8(fp)
  1823d4:	e0bffe17 	ldw	r2,-8(fp)
  1823d8:	10807690 	cmplti	r2,r2,474
  1823dc:	103fd51e 	bne	r2,zero,182334 <restore_menu_trace+0x34>
    int  y;



    /* loop, restoring the trace under the menu */
    for (y = MENU_UL_Y; y < (MENU_UL_Y + MENU_SIZE_Y); y++)  {
  1823e0:	e0bfff17 	ldw	r2,-4(fp)
  1823e4:	10800044 	addi	r2,r2,1
  1823e8:	e0bfff15 	stw	r2,-4(fp)
  1823ec:	e0bfff17 	ldw	r2,-4(fp)
  1823f0:	10800e10 	cmplti	r2,r2,56
  1823f4:	103fc91e 	bne	r2,zero,18231c <restore_menu_trace+0x1c>
        }
    }


    /* restored menu area - return */
    return;
  1823f8:	0001883a 	nop

}
  1823fc:	e037883a 	mov	sp,fp
  182400:	dfc00217 	ldw	ra,8(sp)
  182404:	df000117 	ldw	fp,4(sp)
  182408:	dc000017 	ldw	r16,0(sp)
  18240c:	dec00304 	addi	sp,sp,12
  182410:	f800283a 	ret

00182414 <set_save_area>:
   Last Modified:    Mar. 8, 1994

*/

void  set_save_area(int pos_x, int pos_y, int size_x, int size_y)
{
  182414:	defff704 	addi	sp,sp,-36
  182418:	dfc00815 	stw	ra,32(sp)
  18241c:	df000715 	stw	fp,28(sp)
  182420:	dc000615 	stw	r16,24(sp)
  182424:	df000604 	addi	fp,sp,24
  182428:	e13ffc15 	stw	r4,-16(fp)
  18242c:	e17ffd15 	stw	r5,-12(fp)
  182430:	e1bffe15 	stw	r6,-8(fp)
  182434:	e1ffff15 	stw	r7,-4(fp)
    int  y;



    /* just setup all the locally global variables from the passed values */
    saved_pos_x = pos_x;
  182438:	e0bffc17 	ldw	r2,-16(fp)
  18243c:	d0a01915 	stw	r2,-32668(gp)
    saved_pos_y = pos_y;
  182440:	e0bffd17 	ldw	r2,-12(fp)
  182444:	d0a01a15 	stw	r2,-32664(gp)
    saved_end_x = pos_x + size_x;
  182448:	e0fffc17 	ldw	r3,-16(fp)
  18244c:	e0bffe17 	ldw	r2,-8(fp)
  182450:	1885883a 	add	r2,r3,r2
  182454:	d0a01b15 	stw	r2,-32660(gp)
    saved_end_y = pos_y + size_y;
  182458:	e0fffd17 	ldw	r3,-12(fp)
  18245c:	e0bfff17 	ldw	r2,-4(fp)
  182460:	1885883a 	add	r2,r3,r2
  182464:	d0a01c15 	stw	r2,-32656(gp)


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
  182468:	e03ffb15 	stw	zero,-20(fp)
  18246c:	00001506 	br	1824c4 <set_save_area+0xb0>
        for (x = 0; x < (SAVE_SIZE_X / 8); x++)  {
  182470:	e03ffa15 	stw	zero,-24(fp)
  182474:	00000d06 	br	1824ac <set_save_area+0x98>
	    saved_area[y][x] = 0;
  182478:	040008b4 	movhi	r16,34
  18247c:	84095784 	addi	r16,r16,9566
  182480:	e0bffb17 	ldw	r2,-20(fp)
  182484:	1009883a 	mov	r4,r2
  182488:	014003c4 	movi	r5,15
  18248c:	01832700 	call	183270 <__mulsi3>
  182490:	e0fffa17 	ldw	r3,-24(fp)
  182494:	10c5883a 	add	r2,r2,r3
  182498:	8085883a 	add	r2,r16,r2
  18249c:	10000005 	stb	zero,0(r2)
    saved_end_y = pos_y + size_y;


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
        for (x = 0; x < (SAVE_SIZE_X / 8); x++)  {
  1824a0:	e0bffa17 	ldw	r2,-24(fp)
  1824a4:	10800044 	addi	r2,r2,1
  1824a8:	e0bffa15 	stw	r2,-24(fp)
  1824ac:	e0bffa17 	ldw	r2,-24(fp)
  1824b0:	108003d0 	cmplti	r2,r2,15
  1824b4:	103ff01e 	bne	r2,zero,182478 <set_save_area+0x64>
    saved_end_x = pos_x + size_x;
    saved_end_y = pos_y + size_y;


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
  1824b8:	e0bffb17 	ldw	r2,-20(fp)
  1824bc:	10800044 	addi	r2,r2,1
  1824c0:	e0bffb15 	stw	r2,-20(fp)
  1824c4:	e0bffb17 	ldw	r2,-20(fp)
  1824c8:	10800410 	cmplti	r2,r2,16
  1824cc:	103fe81e 	bne	r2,zero,182470 <set_save_area+0x5c>
        }
    }


    /* setup the saved area - return */
    return;
  1824d0:	0001883a 	nop

}
  1824d4:	e037883a 	mov	sp,fp
  1824d8:	dfc00217 	ldw	ra,8(sp)
  1824dc:	df000117 	ldw	fp,4(sp)
  1824e0:	dc000017 	ldw	r16,0(sp)
  1824e4:	dec00304 	addi	sp,sp,12
  1824e8:	f800283a 	ret

001824ec <restore_trace>:
   Last Modified:    June 03, 2014

*/

void  restore_trace()
{
  1824ec:	defff904 	addi	sp,sp,-28
  1824f0:	dfc00615 	stw	ra,24(sp)
  1824f4:	df000515 	stw	fp,20(sp)
  1824f8:	dc000415 	stw	r16,16(sp)
  1824fc:	df000404 	addi	fp,sp,16
    int  y;



    /* loop, restoring the saved trace */
    for (y = saved_pos_y; y < saved_end_y; y++)  {
  182500:	d0a01a17 	ldw	r2,-32664(gp)
  182504:	e0bfff15 	stw	r2,-4(fp)
  182508:	00003606 	br	1825e4 <restore_trace+0xf8>

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
  18250c:	00802004 	movi	r2,128
  182510:	e0bffc15 	stw	r2,-16(fp)
	bit_offset = 0;		/* first byte of the row */
  182514:	e03ffd15 	stw	zero,-12(fp)

        for (x = saved_pos_x; x < saved_end_x; x++)  {
  182518:	d0a01917 	ldw	r2,-32668(gp)
  18251c:	e0bffe15 	stw	r2,-8(fp)
  182520:	00002a06 	br	1825cc <restore_trace+0xe0>

	    /* check if this point is on or off (need to look at bits) */
	    if ((saved_area[y - saved_pos_y][bit_offset] & bit_position) == 0)
  182524:	d0a01a17 	ldw	r2,-32664(gp)
  182528:	e0ffff17 	ldw	r3,-4(fp)
  18252c:	1885c83a 	sub	r2,r3,r2
  182530:	040008b4 	movhi	r16,34
  182534:	84095784 	addi	r16,r16,9566
  182538:	1009883a 	mov	r4,r2
  18253c:	014003c4 	movi	r5,15
  182540:	01832700 	call	183270 <__mulsi3>
  182544:	e0fffd17 	ldw	r3,-12(fp)
  182548:	10c5883a 	add	r2,r2,r3
  18254c:	8085883a 	add	r2,r16,r2
  182550:	10800003 	ldbu	r2,0(r2)
  182554:	10c03fcc 	andi	r3,r2,255
  182558:	e0bffc17 	ldw	r2,-16(fp)
  18255c:	1884703a 	and	r2,r3,r2
  182560:	1000071e 	bne	r2,zero,182580 <restore_trace+0x94>
	        /* saved pixel is off */
		plot_pixel(x, y, PIXEL_CLEAR);
  182564:	e0fffe17 	ldw	r3,-8(fp)
  182568:	e0bfff17 	ldw	r2,-4(fp)
  18256c:	1809883a 	mov	r4,r3
  182570:	100b883a 	mov	r5,r2
  182574:	000d883a 	mov	r6,zero
  182578:	0182bf40 	call	182bf4 <plot_pixel>
  18257c:	00000606 	br	182598 <restore_trace+0xac>
	    else
	        /* saved pixel is on */
		plot_pixel(x, y, PIXEL_TRACE);
  182580:	e0fffe17 	ldw	r3,-8(fp)
  182584:	e0bfff17 	ldw	r2,-4(fp)
  182588:	1809883a 	mov	r4,r3
  18258c:	100b883a 	mov	r5,r2
  182590:	01a80014 	movui	r6,40960
  182594:	0182bf40 	call	182bf4 <plot_pixel>

	    /* move to the next bit position */
	    bit_position >>= 1;
  182598:	e0bffc17 	ldw	r2,-16(fp)
  18259c:	1005d07a 	srai	r2,r2,1
  1825a0:	e0bffc15 	stw	r2,-16(fp)
	    /* check if moving to next byte */
	    if (bit_position == 0)  {
  1825a4:	e0bffc17 	ldw	r2,-16(fp)
  1825a8:	1000051e 	bne	r2,zero,1825c0 <restore_trace+0xd4>
	        /* now on high bit of next byte */
		bit_position = 0x80;
  1825ac:	00802004 	movi	r2,128
  1825b0:	e0bffc15 	stw	r2,-16(fp)
		bit_offset++;
  1825b4:	e0bffd17 	ldw	r2,-12(fp)
  1825b8:	10800044 	addi	r2,r2,1
  1825bc:	e0bffd15 	stw	r2,-12(fp)

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
	bit_offset = 0;		/* first byte of the row */

        for (x = saved_pos_x; x < saved_end_x; x++)  {
  1825c0:	e0bffe17 	ldw	r2,-8(fp)
  1825c4:	10800044 	addi	r2,r2,1
  1825c8:	e0bffe15 	stw	r2,-8(fp)
  1825cc:	d0a01b17 	ldw	r2,-32660(gp)
  1825d0:	e0fffe17 	ldw	r3,-8(fp)
  1825d4:	18bfd316 	blt	r3,r2,182524 <restore_trace+0x38>
    int  y;



    /* loop, restoring the saved trace */
    for (y = saved_pos_y; y < saved_end_y; y++)  {
  1825d8:	e0bfff17 	ldw	r2,-4(fp)
  1825dc:	10800044 	addi	r2,r2,1
  1825e0:	e0bfff15 	stw	r2,-4(fp)
  1825e4:	d0a01c17 	ldw	r2,-32656(gp)
  1825e8:	e0ffff17 	ldw	r3,-4(fp)
  1825ec:	18bfc716 	blt	r3,r2,18250c <restore_trace+0x20>
        }
    }


    /* restored the saved area - return */
    return;
  1825f0:	0001883a 	nop

}
  1825f4:	e037883a 	mov	sp,fp
  1825f8:	dfc00217 	ldw	ra,8(sp)
  1825fc:	df000117 	ldw	fp,4(sp)
  182600:	dc000017 	ldw	r16,0(sp)
  182604:	dec00304 	addi	sp,sp,12
  182608:	f800283a 	ret

0018260c <do_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  do_trace()
{
  18260c:	defffe04 	addi	sp,sp,-8
  182610:	dfc00115 	stw	ra,4(sp)
  182614:	df000015 	stw	fp,0(sp)
  182618:	d839883a 	mov	fp,sp



    /* start up the trace */
    /* indicate whether using automatic triggering or not */
    start_sample(get_trigger_mode() == AUTO_TRIGGER);
  18261c:	0180de00 	call	180de0 <get_trigger_mode>
  182620:	10800060 	cmpeqi	r2,r2,1
  182624:	10803fcc 	andi	r2,r2,255
  182628:	1009883a 	mov	r4,r2
  18262c:	0182e1c0 	call	182e1c <start_sample>

    /* now not ready for another trace (currently doing one) */
    trace_status = FALSE;
  182630:	d0201515 	stw	zero,-32684(gp)

    /* and are currently sampling data */
    sampling = TRUE;
  182634:	00800044 	movi	r2,1
  182638:	d0a01615 	stw	r2,-32680(gp)


    /* trace is going, return */
    return;
  18263c:	0001883a 	nop

}
  182640:	e037883a 	mov	sp,fp
  182644:	dfc00117 	ldw	ra,4(sp)
  182648:	df000017 	ldw	fp,0(sp)
  18264c:	dec00204 	addi	sp,sp,8
  182650:	f800283a 	ret

00182654 <plot_trace>:
   Last Modified:    June 03, 2014

*/

void  plot_trace(unsigned char *sample)
{
  182654:	defff304 	addi	sp,sp,-52
  182658:	dfc00c15 	stw	ra,48(sp)
  18265c:	df000b15 	stw	fp,44(sp)
  182660:	dcc00a15 	stw	r19,40(sp)
  182664:	dc800915 	stw	r18,36(sp)
  182668:	dc400815 	stw	r17,32(sp)
  18266c:	dc000715 	stw	r16,28(sp)
  182670:	df000704 	addi	fp,sp,28
  182674:	e13fff15 	stw	r4,-4(fp)
    /* variables */
    int  x = 0;				/* current x position to plot */
  182678:	e03ff915 	stw	zero,-28(fp)
    int  x_pos = (PLOT_SIZE_X / 2);	/* "fine" x position for multiple point plotting */
  18267c:	00803c04 	movi	r2,240
  182680:	e0bffa15 	stw	r2,-24(fp)
    int  i;				/* loop indices */
    int  j;


    /* clear the saved areas too */
    clear_saved_areas();
  182684:	01821300 	call	182130 <clear_saved_areas>

    /* re-display the menu (if it was on) */
    refresh_menu();
  182688:	01809b80 	call	1809b8 <refresh_menu>


    /* plot the sample */
    for (i = 0; i < sample_size; i++)  {
  18268c:	e03ffc15 	stw	zero,-16(fp)
  182690:	00012306 	br	182b20 <plot_trace+0x4cc>

        /* determine y position of point (note: screen coordinates invert) */
	y = (PLOT_SIZE_Y - 1) - ((sample[i] * (PLOT_SIZE_Y - 1)) / 255);
  182694:	e0bffc17 	ldw	r2,-16(fp)
  182698:	e0ffff17 	ldw	r3,-4(fp)
  18269c:	1885883a 	add	r2,r3,r2
  1826a0:	10800003 	ldbu	r2,0(r2)
  1826a4:	10803fcc 	andi	r2,r2,255
  1826a8:	1009883a 	mov	r4,r2
  1826ac:	014043c4 	movi	r5,271
  1826b0:	01832700 	call	183270 <__mulsi3>
  1826b4:	1009883a 	mov	r4,r2
  1826b8:	01403fc4 	movi	r5,255
  1826bc:	01831b40 	call	1831b4 <__divsi3>
  1826c0:	00c043c4 	movi	r3,271
  1826c4:	1885c83a 	sub	r2,r3,r2
  1826c8:	e0bffe15 	stw	r2,-8(fp)

	/* clear previous point on trace */
	plot_pixel(i, old_sample[i], PIXEL_CLEAR);
  1826cc:	e0fffc17 	ldw	r3,-16(fp)
  1826d0:	010008b4 	movhi	r4,34
  1826d4:	21062704 	addi	r4,r4,6300
  1826d8:	e0bffc17 	ldw	r2,-16(fp)
  1826dc:	1085883a 	add	r2,r2,r2
  1826e0:	1085883a 	add	r2,r2,r2
  1826e4:	2085883a 	add	r2,r4,r2
  1826e8:	10800017 	ldw	r2,0(r2)
  1826ec:	1809883a 	mov	r4,r3
  1826f0:	100b883a 	mov	r5,r2
  1826f4:	000d883a 	mov	r6,zero
  1826f8:	0182bf40 	call	182bf4 <plot_pixel>

        /* plot this point */
	plot_pixel(x, y, PIXEL_TRACE);
  1826fc:	e0fff917 	ldw	r3,-28(fp)
  182700:	e0bffe17 	ldw	r2,-8(fp)
  182704:	1809883a 	mov	r4,r3
  182708:	100b883a 	mov	r5,r2
  18270c:	01a80014 	movui	r6,40960
  182710:	0182bf40 	call	182bf4 <plot_pixel>

	/* and save new value */
	old_sample[i] = y;
  182714:	00c008b4 	movhi	r3,34
  182718:	18c62704 	addi	r3,r3,6300
  18271c:	e0bffc17 	ldw	r2,-16(fp)
  182720:	1085883a 	add	r2,r2,r2
  182724:	1085883a 	add	r2,r2,r2
  182728:	1885883a 	add	r2,r3,r2
  18272c:	e0fffe17 	ldw	r3,-8(fp)
  182730:	10c00015 	stw	r3,0(r2)


	/* check if the point is in a save area */

	/* check if in the menu area */
	if ((x >= MENU_UL_X) && (x < (MENU_UL_X + MENU_SIZE_X)) &&
  182734:	e0bff917 	ldw	r2,-28(fp)
  182738:	10805e90 	cmplti	r2,r2,378
  18273c:	10002f1e 	bne	r2,zero,1827fc <plot_trace+0x1a8>
  182740:	e0bff917 	ldw	r2,-28(fp)
  182744:	10807688 	cmpgei	r2,r2,474
  182748:	10002c1e 	bne	r2,zero,1827fc <plot_trace+0x1a8>
  18274c:	e0bffe17 	ldw	r2,-8(fp)
  182750:	10002a16 	blt	r2,zero,1827fc <plot_trace+0x1a8>
	    (y >= MENU_UL_Y) && (y < (MENU_UL_Y + MENU_SIZE_Y)))
  182754:	e0bffe17 	ldw	r2,-8(fp)
  182758:	10800e08 	cmpgei	r2,r2,56
  18275c:	1000271e 	bne	r2,zero,1827fc <plot_trace+0x1a8>
	    /* point is in the menu area - save it */
	    saved_menu[y - MENU_UL_Y][(x - MENU_UL_X)/8] |= (0x80 >> ((x - MENU_UL_X) % 8));
  182760:	e0bff917 	ldw	r2,-28(fp)
  182764:	10bfa184 	addi	r2,r2,-378
  182768:	1000010e 	bge	r2,zero,182770 <plot_trace+0x11c>
  18276c:	108001c4 	addi	r2,r2,7
  182770:	1005d0fa 	srai	r2,r2,3
  182774:	1021883a 	mov	r16,r2
  182778:	044008b4 	movhi	r17,34
  18277c:	8c48af84 	addi	r17,r17,8894
  182780:	e0bffe17 	ldw	r2,-8(fp)
  182784:	1009883a 	mov	r4,r2
  182788:	01400304 	movi	r5,12
  18278c:	01832700 	call	183270 <__mulsi3>
  182790:	1405883a 	add	r2,r2,r16
  182794:	8885883a 	add	r2,r17,r2
  182798:	10800003 	ldbu	r2,0(r2)
  18279c:	1007883a 	mov	r3,r2
  1827a0:	e0bff917 	ldw	r2,-28(fp)
  1827a4:	113fa184 	addi	r4,r2,-378
  1827a8:	00a00034 	movhi	r2,32768
  1827ac:	108001c4 	addi	r2,r2,7
  1827b0:	2084703a 	and	r2,r4,r2
  1827b4:	1000040e 	bge	r2,zero,1827c8 <plot_trace+0x174>
  1827b8:	10bfffc4 	addi	r2,r2,-1
  1827bc:	013ffe04 	movi	r4,-8
  1827c0:	1104b03a 	or	r2,r2,r4
  1827c4:	10800044 	addi	r2,r2,1
  1827c8:	01002004 	movi	r4,128
  1827cc:	2085d83a 	sra	r2,r4,r2
  1827d0:	1884b03a 	or	r2,r3,r2
  1827d4:	1023883a 	mov	r17,r2
  1827d8:	048008b4 	movhi	r18,34
  1827dc:	9488af84 	addi	r18,r18,8894
  1827e0:	e0bffe17 	ldw	r2,-8(fp)
  1827e4:	1009883a 	mov	r4,r2
  1827e8:	01400304 	movi	r5,12
  1827ec:	01832700 	call	183270 <__mulsi3>
  1827f0:	1405883a 	add	r2,r2,r16
  1827f4:	9085883a 	add	r2,r18,r2
  1827f8:	14400005 	stb	r17,0(r2)

	/* check if in the saved area */
	if ((x >= saved_pos_x) && (x <= saved_end_x) && (y >= saved_pos_y) && (y <= saved_end_y))
  1827fc:	d0a01917 	ldw	r2,-32668(gp)
  182800:	e0fff917 	ldw	r3,-28(fp)
  182804:	18803616 	blt	r3,r2,1828e0 <plot_trace+0x28c>
  182808:	d0e01b17 	ldw	r3,-32660(gp)
  18280c:	e0bff917 	ldw	r2,-28(fp)
  182810:	18803316 	blt	r3,r2,1828e0 <plot_trace+0x28c>
  182814:	d0a01a17 	ldw	r2,-32664(gp)
  182818:	e0fffe17 	ldw	r3,-8(fp)
  18281c:	18803016 	blt	r3,r2,1828e0 <plot_trace+0x28c>
  182820:	d0e01c17 	ldw	r3,-32656(gp)
  182824:	e0bffe17 	ldw	r2,-8(fp)
  182828:	18802d16 	blt	r3,r2,1828e0 <plot_trace+0x28c>
	    /* point is in the save area - save it */
	    saved_area[y - saved_pos_y][(x - saved_pos_x)/8] |= (0x80 >> ((x - saved_pos_x) % 8));
  18282c:	d0a01a17 	ldw	r2,-32664(gp)
  182830:	e0fffe17 	ldw	r3,-8(fp)
  182834:	18a3c83a 	sub	r17,r3,r2
  182838:	d0a01917 	ldw	r2,-32668(gp)
  18283c:	e0fff917 	ldw	r3,-28(fp)
  182840:	1885c83a 	sub	r2,r3,r2
  182844:	1000010e 	bge	r2,zero,18284c <plot_trace+0x1f8>
  182848:	108001c4 	addi	r2,r2,7
  18284c:	1005d0fa 	srai	r2,r2,3
  182850:	1021883a 	mov	r16,r2
  182854:	d0a01a17 	ldw	r2,-32664(gp)
  182858:	e0fffe17 	ldw	r3,-8(fp)
  18285c:	1885c83a 	sub	r2,r3,r2
  182860:	048008b4 	movhi	r18,34
  182864:	94895784 	addi	r18,r18,9566
  182868:	1009883a 	mov	r4,r2
  18286c:	014003c4 	movi	r5,15
  182870:	01832700 	call	183270 <__mulsi3>
  182874:	1405883a 	add	r2,r2,r16
  182878:	9085883a 	add	r2,r18,r2
  18287c:	10800003 	ldbu	r2,0(r2)
  182880:	1007883a 	mov	r3,r2
  182884:	d0a01917 	ldw	r2,-32668(gp)
  182888:	e13ff917 	ldw	r4,-28(fp)
  18288c:	2089c83a 	sub	r4,r4,r2
  182890:	00a00034 	movhi	r2,32768
  182894:	108001c4 	addi	r2,r2,7
  182898:	2084703a 	and	r2,r4,r2
  18289c:	1000040e 	bge	r2,zero,1828b0 <plot_trace+0x25c>
  1828a0:	10bfffc4 	addi	r2,r2,-1
  1828a4:	013ffe04 	movi	r4,-8
  1828a8:	1104b03a 	or	r2,r2,r4
  1828ac:	10800044 	addi	r2,r2,1
  1828b0:	01002004 	movi	r4,128
  1828b4:	2085d83a 	sra	r2,r4,r2
  1828b8:	1884b03a 	or	r2,r3,r2
  1828bc:	1025883a 	mov	r18,r2
  1828c0:	04c008b4 	movhi	r19,34
  1828c4:	9cc95784 	addi	r19,r19,9566
  1828c8:	8809883a 	mov	r4,r17
  1828cc:	014003c4 	movi	r5,15
  1828d0:	01832700 	call	183270 <__mulsi3>
  1828d4:	1405883a 	add	r2,r2,r16
  1828d8:	9885883a 	add	r2,r19,r2
  1828dc:	14800005 	stb	r18,0(r2)

	/* check if on a grid line */
	/* go through all the horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  1828e0:	00bfff84 	movi	r2,-2
  1828e4:	e0bffd15 	stw	r2,-12(fp)
  1828e8:	00003a06 	br	1829d4 <plot_trace+0x380>

	    /* get y position of the line */
	    p = X_AXIS_POS + j * Y_TICK_SIZE;
  1828ec:	e13ffd17 	ldw	r4,-12(fp)
  1828f0:	01400c04 	movi	r5,48
  1828f4:	01832700 	call	183270 <__mulsi3>
  1828f8:	10802204 	addi	r2,r2,136
  1828fc:	e0bffb15 	stw	r2,-20(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_Y)
  182900:	e0bffb17 	ldw	r2,-20(fp)
  182904:	10804410 	cmplti	r2,r2,272
  182908:	1000021e 	bne	r2,zero,182914 <plot_trace+0x2c0>
	        p = PLOT_SIZE_Y - 1;
  18290c:	008043c4 	movi	r2,271
  182910:	e0bffb15 	stw	r2,-20(fp)
	    if (p < 0)
  182914:	e0bffb17 	ldw	r2,-20(fp)
  182918:	1000010e 	bge	r2,zero,182920 <plot_trace+0x2cc>
	        p = 0;
  18291c:	e03ffb15 	stw	zero,-20(fp)

	    /* if the point is on this line, save it */
	    if (y == p)
  182920:	e0fffe17 	ldw	r3,-8(fp)
  182924:	e0bffb17 	ldw	r2,-20(fp)
  182928:	1880271e 	bne	r3,r2,1829c8 <plot_trace+0x374>
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
  18292c:	e0bffd17 	ldw	r2,-12(fp)
  182930:	14400084 	addi	r17,r2,2
  182934:	e0bff917 	ldw	r2,-28(fp)
  182938:	1000010e 	bge	r2,zero,182940 <plot_trace+0x2ec>
  18293c:	108001c4 	addi	r2,r2,7
  182940:	1005d0fa 	srai	r2,r2,3
  182944:	1021883a 	mov	r16,r2
  182948:	e0bffd17 	ldw	r2,-12(fp)
  18294c:	10800084 	addi	r2,r2,2
  182950:	048008b4 	movhi	r18,34
  182954:	94880704 	addi	r18,r18,8220
  182958:	1009883a 	mov	r4,r2
  18295c:	01400f04 	movi	r5,60
  182960:	01832700 	call	183270 <__mulsi3>
  182964:	1405883a 	add	r2,r2,r16
  182968:	9085883a 	add	r2,r18,r2
  18296c:	10800003 	ldbu	r2,0(r2)
  182970:	1007883a 	mov	r3,r2
  182974:	e13ff917 	ldw	r4,-28(fp)
  182978:	00a00034 	movhi	r2,32768
  18297c:	108001c4 	addi	r2,r2,7
  182980:	2084703a 	and	r2,r4,r2
  182984:	1000040e 	bge	r2,zero,182998 <plot_trace+0x344>
  182988:	10bfffc4 	addi	r2,r2,-1
  18298c:	013ffe04 	movi	r4,-8
  182990:	1104b03a 	or	r2,r2,r4
  182994:	10800044 	addi	r2,r2,1
  182998:	01002004 	movi	r4,128
  18299c:	2085d83a 	sra	r2,r4,r2
  1829a0:	1884b03a 	or	r2,r3,r2
  1829a4:	1025883a 	mov	r18,r2
  1829a8:	04c008b4 	movhi	r19,34
  1829ac:	9cc80704 	addi	r19,r19,8220
  1829b0:	8809883a 	mov	r4,r17
  1829b4:	01400f04 	movi	r5,60
  1829b8:	01832700 	call	183270 <__mulsi3>
  1829bc:	1405883a 	add	r2,r2,r16
  1829c0:	9885883a 	add	r2,r19,r2
  1829c4:	14800005 	stb	r18,0(r2)
	    /* point is in the save area - save it */
	    saved_area[y - saved_pos_y][(x - saved_pos_x)/8] |= (0x80 >> ((x - saved_pos_x) % 8));

	/* check if on a grid line */
	/* go through all the horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  1829c8:	e0bffd17 	ldw	r2,-12(fp)
  1829cc:	10800044 	addi	r2,r2,1
  1829d0:	e0bffd15 	stw	r2,-12(fp)
  1829d4:	e0bffd17 	ldw	r2,-12(fp)
  1829d8:	108000d0 	cmplti	r2,r2,3
  1829dc:	103fc31e 	bne	r2,zero,1828ec <plot_trace+0x298>
	    if (y == p)
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
	}

	/* go through all the vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  1829e0:	00bffec4 	movi	r2,-5
  1829e4:	e0bffd15 	stw	r2,-12(fp)
  1829e8:	00003a06 	br	182ad4 <plot_trace+0x480>

	    /* get x position of the line */
	    p = Y_AXIS_POS + j * X_TICK_SIZE;
  1829ec:	e13ffd17 	ldw	r4,-12(fp)
  1829f0:	01400c04 	movi	r5,48
  1829f4:	01832700 	call	183270 <__mulsi3>
  1829f8:	10803c04 	addi	r2,r2,240
  1829fc:	e0bffb15 	stw	r2,-20(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_X)
  182a00:	e0bffb17 	ldw	r2,-20(fp)
  182a04:	10807810 	cmplti	r2,r2,480
  182a08:	1000021e 	bne	r2,zero,182a14 <plot_trace+0x3c0>
	        p = PLOT_SIZE_X - 1;
  182a0c:	008077c4 	movi	r2,479
  182a10:	e0bffb15 	stw	r2,-20(fp)
	    if (p < 0)
  182a14:	e0bffb17 	ldw	r2,-20(fp)
  182a18:	1000010e 	bge	r2,zero,182a20 <plot_trace+0x3cc>
	        p = 0;
  182a1c:	e03ffb15 	stw	zero,-20(fp)

	    /* if the point is on this line, save it */
	    if (x == p)
  182a20:	e0fff917 	ldw	r3,-28(fp)
  182a24:	e0bffb17 	ldw	r2,-20(fp)
  182a28:	1880271e 	bne	r3,r2,182ac8 <plot_trace+0x474>
		saved_axis_y[j + X_TICK_CNT][y / 8] |= (0x80 >> (y % 8));
  182a2c:	e0bffd17 	ldw	r2,-12(fp)
  182a30:	14400144 	addi	r17,r2,5
  182a34:	e0bffe17 	ldw	r2,-8(fp)
  182a38:	1000010e 	bge	r2,zero,182a40 <plot_trace+0x3ec>
  182a3c:	108001c4 	addi	r2,r2,7
  182a40:	1005d0fa 	srai	r2,r2,3
  182a44:	1021883a 	mov	r16,r2
  182a48:	e0bffd17 	ldw	r2,-12(fp)
  182a4c:	10800144 	addi	r2,r2,5
  182a50:	048008b4 	movhi	r18,34
  182a54:	94885204 	addi	r18,r18,8520
  182a58:	1009883a 	mov	r4,r2
  182a5c:	01400884 	movi	r5,34
  182a60:	01832700 	call	183270 <__mulsi3>
  182a64:	1405883a 	add	r2,r2,r16
  182a68:	9085883a 	add	r2,r18,r2
  182a6c:	10800003 	ldbu	r2,0(r2)
  182a70:	1007883a 	mov	r3,r2
  182a74:	e13ffe17 	ldw	r4,-8(fp)
  182a78:	00a00034 	movhi	r2,32768
  182a7c:	108001c4 	addi	r2,r2,7
  182a80:	2084703a 	and	r2,r4,r2
  182a84:	1000040e 	bge	r2,zero,182a98 <plot_trace+0x444>
  182a88:	10bfffc4 	addi	r2,r2,-1
  182a8c:	013ffe04 	movi	r4,-8
  182a90:	1104b03a 	or	r2,r2,r4
  182a94:	10800044 	addi	r2,r2,1
  182a98:	01002004 	movi	r4,128
  182a9c:	2085d83a 	sra	r2,r4,r2
  182aa0:	1884b03a 	or	r2,r3,r2
  182aa4:	1025883a 	mov	r18,r2
  182aa8:	04c008b4 	movhi	r19,34
  182aac:	9cc85204 	addi	r19,r19,8520
  182ab0:	8809883a 	mov	r4,r17
  182ab4:	01400884 	movi	r5,34
  182ab8:	01832700 	call	183270 <__mulsi3>
  182abc:	1405883a 	add	r2,r2,r16
  182ac0:	9885883a 	add	r2,r19,r2
  182ac4:	14800005 	stb	r18,0(r2)
	    if (y == p)
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
	}

	/* go through all the vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  182ac8:	e0bffd17 	ldw	r2,-12(fp)
  182acc:	10800044 	addi	r2,r2,1
  182ad0:	e0bffd15 	stw	r2,-12(fp)
  182ad4:	e0bffd17 	ldw	r2,-12(fp)
  182ad8:	10800190 	cmplti	r2,r2,6
  182adc:	103fc31e 	bne	r2,zero,1829ec <plot_trace+0x398>
		saved_axis_y[j + X_TICK_CNT][y / 8] |= (0x80 >> (y % 8));
	}


	/* update x position */
	x_pos += PLOT_SIZE_X;
  182ae0:	e0bffa17 	ldw	r2,-24(fp)
  182ae4:	10807804 	addi	r2,r2,480
  182ae8:	e0bffa15 	stw	r2,-24(fp)
	/* check if at next horizontal position */
	if (x_pos >= sample_size)  {
  182aec:	d0a01717 	ldw	r2,-32676(gp)
  182af0:	e0fffa17 	ldw	r3,-24(fp)
  182af4:	18800716 	blt	r3,r2,182b14 <plot_trace+0x4c0>
	    /* at next position - update positions */
	    x++;
  182af8:	e0bff917 	ldw	r2,-28(fp)
  182afc:	10800044 	addi	r2,r2,1
  182b00:	e0bff915 	stw	r2,-28(fp)
	    x_pos -= sample_size;
  182b04:	d0a01717 	ldw	r2,-32676(gp)
  182b08:	e0fffa17 	ldw	r3,-24(fp)
  182b0c:	1885c83a 	sub	r2,r3,r2
  182b10:	e0bffa15 	stw	r2,-24(fp)
    /* re-display the menu (if it was on) */
    refresh_menu();


    /* plot the sample */
    for (i = 0; i < sample_size; i++)  {
  182b14:	e0bffc17 	ldw	r2,-16(fp)
  182b18:	10800044 	addi	r2,r2,1
  182b1c:	e0bffc15 	stw	r2,-16(fp)
  182b20:	d0a01717 	ldw	r2,-32676(gp)
  182b24:	e0fffc17 	ldw	r3,-16(fp)
  182b28:	18beda16 	blt	r3,r2,182694 <plot_trace+0x40>
	}
    }


    /* finally, output the scale if need be */
    set_display_scale(cur_scale);
  182b2c:	d0a01817 	ldw	r2,-32672(gp)
  182b30:	1009883a 	mov	r4,r2
  182b34:	0181d2c0 	call	181d2c <set_display_scale>


    /* done with plot, return */
    return;
  182b38:	0001883a 	nop

}
  182b3c:	e037883a 	mov	sp,fp
  182b40:	dfc00517 	ldw	ra,20(sp)
  182b44:	df000417 	ldw	fp,16(sp)
  182b48:	dcc00317 	ldw	r19,12(sp)
  182b4c:	dc800217 	ldw	r18,8(sp)
  182b50:	dc400117 	ldw	r17,4(sp)
  182b54:	dc000017 	ldw	r16,0(sp)
  182b58:	dec00604 	addi	sp,sp,24
  182b5c:	f800283a 	ret

00182b60 <clear_display>:
 *      6/03/14   Santiago Navonne     Initial revision.
 *
 */
    .global clear_display
clear_display:                 /* clear the whole display */
	MOVHI 	r8, %hi(VRAM_BASE) /* start at base of VRAM */
  182b60:	02000034 	movhi	r8,0
	ORI 	r8, r8, %lo(VRAM_BASE)
  182b64:	42000014 	ori	r8,r8,0
	MOVI 	r9, SIZE_X         /* and will loop through all columns */
  182b68:	02407804 	movi	r9,480
	MOVI 	r10, SIZE_Y        /*  and rows */
  182b6c:	02804404 	movi	r10,272
	MOV     r11, r0            /* starting at coordinates (0, 0) */
  182b70:	0017883a 	mov	r11,zero
	MOV 	r12, r0            /* (top left corner) */
  182b74:	0019883a 	mov	r12,zero

00182b78 <row_loop>:

row_loop:                      /* go through an entire row */
    STWIO   r0, (r8)           /* first clear the current pixel */
  182b78:	40000035 	stwio	zero,0(r8)
    ADDI 	r8, r8, WORD_SIZE  /* then go to next column */
  182b7c:	42000104 	addi	r8,r8,4
    ADDI 	r11, r11, 1        /*  also incrementing the index */
  182b80:	5ac00044 	addi	r11,r11,1
    BLT 	r11, r9, row_loop  /* and if we're still within display, repeat */
  182b84:	5a7ffc16 	blt	r11,r9,182b78 <row_loop>

00182b88 <next_row>:

next_row:                      /* move to next row */
	ADDI 	r8, r8, REMAINDER  /* add the remainder to finish up a VRAM row */
  182b88:	42002004 	addi	r8,r8,128
	MOV 	r11, r0            /* reset the column index */
  182b8c:	0017883a 	mov	r11,zero
	ADDI    r12, r12, 1        /* and increment the row index */
  182b90:	63000044 	addi	r12,r12,1
	BLT 	r12, r10, row_loop /* if we're still within display, repeat */
  182b94:	62bff816 	blt	r12,r10,182b78 <row_loop>

    RET                        /* all done, so return */
  182b98:	f800283a 	ret

00182b9c <clear_trace_old>:
 *      6/03/14   Santiago Navonne     Initial revision.
 * TODO REMOVE?
 */
    .global clear_trace_old
clear_trace_old:                   /* clear all trace pixels on display */
    MOVHI   r8, %hi(VRAM_BASE) /* start at base of VRAM */
  182b9c:	02000034 	movhi	r8,0
    ORI     r8, r8, %lo(VRAM_BASE)
  182ba0:	42000014 	ori	r8,r8,0
    MOVHI   r13, %hi(PIXEL_TRACE) /* load colors that will be cleared */
  182ba4:	03400034 	movhi	r13,0
    ORI     r13, r13, %lo(PIXEL_TRACE)
  182ba8:	6b680014 	ori	r13,r13,40960
    MOVHI   r14, %hi(PIXEL_CURSOR)/* which are trace and cursor */
  182bac:	03802834 	movhi	r14,160
    ORI     r14, r14, %lo(PIXEL_CURSOR)
  182bb0:	73802834 	orhi	r14,r14,160
    MOVI    r9, SIZE_X         /* will loop through all columns */
  182bb4:	02407804 	movi	r9,480
    MOVI    r10, SIZE_Y        /*  and all rows */
  182bb8:	02804404 	movi	r10,272
    MOV     r11, r0            /* starting at (0, 0) */
  182bbc:	0017883a 	mov	r11,zero
    MOV     r12, r0            /* (top left corner) */
  182bc0:	0019883a 	mov	r12,zero

00182bc4 <trace_check>:

trace_check:                   /* check if current pixel is part of trace */
    LDWIO   r15, (r8)          /* read value from VRAM */
  182bc4:	43c00037 	ldwio	r15,0(r8)
    BEQ     r13, r15, trace_clear /* definitely clear if color is trace color */
  182bc8:	6bc00126 	beq	r13,r15,182bd0 <trace_clear>

00182bcc <cursor_check>:

cursor_check:                  /* check if current pixel is part of cursor */
    BNE     r14, r15, trace_row_loop /* also clear if part of cursor */
  182bcc:	73c0011e 	bne	r14,r15,182bd4 <trace_row_loop>

00182bd0 <trace_clear>:
 
trace_clear:                   /* pixel is part of trace or cursor */
    STWIO   r0, (r8)           /*  so clear it */
  182bd0:	40000035 	stwio	zero,0(r8)

00182bd4 <trace_row_loop>:

trace_row_loop:                /* done with current pixel */
    ADDI    r8, r8, WORD_SIZE  /*  so go to next */
  182bd4:	42000104 	addi	r8,r8,4
    ADDI    r11, r11, 1        /*  and also increment column index */
  182bd8:	5ac00044 	addi	r11,r11,1
    BLT     r11, r9, trace_check /* if still within display, repeat */
  182bdc:	5a7ff916 	blt	r11,r9,182bc4 <trace_check>

00182be0 <trace_next_row>:

trace_next_row:                /* done with current row */
    ADDI    r8, r8, REMAINDER  /* add remainder to finish up VRAM row */
  182be0:	42002004 	addi	r8,r8,128
    MOV     r11, r0            /* reset column index */
  182be4:	0017883a 	mov	r11,zero
    ADDI    r12, r12, 1        /*  and increment row index */
  182be8:	63000044 	addi	r12,r12,1
    BLT     r12, r10, trace_check /* if still within display, repeat */
  182bec:	62bff516 	blt	r12,r10,182bc4 <trace_check>

    RET                        /* all done, so return */
  182bf0:	f800283a 	ret

00182bf4 <plot_pixel>:
 *      6/03/14   Santiago Navonne     Initial revision.
 *
 */
    .global plot_pixel
plot_pixel:                    /* draw a pixel of the specified color */
	MOVHI 	r8, %hi(VRAM_BASE) /* find pixel location by first going to VRAM base */
  182bf4:	02000034 	movhi	r8,0
	ORI 	r8, r8, %lo(VRAM_BASE)
  182bf8:	42000014 	ori	r8,r8,0
	MOVI    r9, ROW_ADDR_SHIFT /* shift the row to the row part of the address */
  182bfc:	024002c4 	movi	r9,11
	SLL     r9, r5, r9     
  182c00:	2a52983a 	sll	r9,r5,r9
	MOVI 	r10, COL_ADDR_SHIFT/* and the column to the column part */
  182c04:	02800084 	movi	r10,2
	SLL     r10, r4, r10
  182c08:	2294983a 	sll	r10,r4,r10
	OR      r8, r8, r9         /* OR row, column, and VRAM base together */
  182c0c:	4250b03a 	or	r8,r8,r9
	OR      r8, r8, r10        /*  to create final pixel address */
  182c10:	4290b03a 	or	r8,r8,r10
	STWIO   r6, (r8)           /* and finally save passed color value to that address */
  182c14:	41800035 	stwio	r6,0(r8)

    RET                        /* all done, so return */
  182c18:	f800283a 	ret

00182c1c <pixel_color>:
 *      6/03/14   Santiago Navonne     Initial revision.
 *
 */
    .global pixel_color
pixel_color:                   /* read a pixel from display */
    MOVHI   r8, %hi(VRAM_BASE) /* find pixel location by first going to VRAM base */
  182c1c:	02000034 	movhi	r8,0
    ORI     r8, r8, %lo(VRAM_BASE)
  182c20:	42000014 	ori	r8,r8,0
    MOVI    r9, ROW_ADDR_SHIFT /* shift the row to the row part of the address */
  182c24:	024002c4 	movi	r9,11
    SLL     r9, r5, r9
  182c28:	2a52983a 	sll	r9,r5,r9
    MOVI    r10, COL_ADDR_SHIFT/* and the column to the column part */
  182c2c:	02800084 	movi	r10,2
    SLL     r10, r4, r10
  182c30:	2294983a 	sll	r10,r4,r10
    OR      r8, r8, r9         /* OR row, column, and VRAM base together */
  182c34:	4250b03a 	or	r8,r8,r9
    OR      r8, r8, r10        /*  to create final pixel address */
  182c38:	4290b03a 	or	r8,r8,r10
    LDWIO   r2, (r8)           /* and finally read color value from that address */
  182c3c:	40800037 	ldwio	r2,0(r8)

    RET                        /* storing it in return register */
  182c40:	f800283a 	ret

00182c44 <keys_init>:
 *      5/14/14   Santiago Navonne     Added additional documentation.
 *
 */
    .global keys_init
keys_init:
    ADDI    sp, sp, NEG_WORD_SIZE  /* push return address */
  182c44:	deffff04 	addi	sp,sp,-4
    STW     ra, (sp)
  182c48:	dfc00015 	stw	ra,0(sp)
  182c4c:	024008b4 	movhi	r9,34

    MOVIA   r9, curr_key           /* no key (r0) available at start */
  182c50:	4a400004 	addi	r9,r9,0
    STB     r0, (r9)               /* so store it into variable curr_key */
  182c54:	48000005 	stb	zero,0(r9)

	MOVHI   r8, %hi(PIO_0_BASE)    /* write to the PIO registers */
  182c58:	02000934 	movhi	r8,36
    ORI 	r8, r8, %lo(PIO_0_BASE)
  182c5c:	42042814 	ori	r8,r8,4256
    MOVI    r9, ENABLE_ALL         /*  the ENABLE_ALL value */
  182c60:	02400fc4 	movi	r9,63
    STBIO   r9, EDGE_CAP_OF(r8)    /* sending general EOI to clear ints */
  182c64:	42400325 	stbio	r9,12(r8)

    MOV     r4, r0                 /* argument ic_id is ignored */
  182c68:	0009883a 	mov	r4,zero
    MOVI    r5, PIO_0_IRQ          /* second arg is IRQ num */
  182c6c:	01400044 	movi	r5,1
  182c70:	01800634 	movhi	r6,24
    MOVIA   r6, keys_handler       /* third arg is int handler */
  182c74:	318b2704 	addi	r6,r6,11420
    MOV     r7, r0                 /* fourth arg is data struct (null) */
  182c78:	000f883a 	mov	r7,zero
    ADDI    sp, sp, NEG_WORD_SIZE  /* fifth arg goes on stack */
  182c7c:	deffff04 	addi	sp,sp,-4
    STW     r0, (sp)               /*  and is ignored (so 0) */
  182c80:	d8000015 	stw	zero,0(sp)
    CALL    alt_ic_isr_register    /* finally, call setup function */
  182c84:	01835380 	call	183538 <alt_ic_isr_register>
    ADDI    sp, sp, WORD_SIZE      /* clean up stack after call */
  182c88:	dec00104 	addi	sp,sp,4

    LDW     ra, (sp)               /* pop return address */
  182c8c:	dfc00017 	ldw	ra,0(sp)
    ADDI    sp, sp, WORD_SIZE
  182c90:	dec00104 	addi	sp,sp,4

    STBIO   r9, INTMASK_OF(r8)     /* enable (unmask) interrupts */
  182c94:	42400225 	stbio	r9,8(r8)

    RET                            /* and finally return */
  182c98:	f800283a 	ret

00182c9c <keys_handler>:
 *      5/14/14   Santiago Navonne     Added additional documentation.
 *
 */
    .global keys_handler
keys_handler:
    ADDI    sp, sp, NEG_WORD_SIZE   /* save r8 */
  182c9c:	deffff04 	addi	sp,sp,-4
    STW     r8, (sp)
  182ca0:	da000015 	stw	r8,0(sp)

    MOVHI   et, %hi(PIO_0_BASE)  /* fetch PIO edge capture register */
  182ca4:	06000934 	movhi	et,36
    ORI 	et, et, %lo(PIO_0_BASE)
  182ca8:	c6042814 	ori	et,et,4256
    LDBIO   r8, EDGE_CAP_OF(et)
  182cac:	c2000327 	ldbio	r8,12(et)

    STBIO   r8, EDGE_CAP_OF(et)  /* and write back to send EOI */
  182cb0:	c2000325 	stbio	r8,12(et)
                                 /* figure out what interrupt fired */
    MOVI    et, PUSH1_MASK       /* check if it was pushbutton 1 */
  182cb4:	06000804 	movi	et,32
    BEQ     r8, et, keys_handler_push1
  182cb8:	46000926 	beq	r8,et,182ce0 <keys_handler_push1>
    MOVI    et, PUSH2_MASK       /* check if it was pushbutton 2 */
  182cbc:	06000404 	movi	et,16
    BEQ     r8, et, keys_handler_push2
  182cc0:	46000926 	beq	r8,et,182ce8 <keys_handler_push2>
    MOVI    et, ROT1R_MASK       /* check if it was rotary enc 1 right */
  182cc4:	06000104 	movi	et,4
    BEQ     r8, et, keys_handler_rot1r
  182cc8:	46000926 	beq	r8,et,182cf0 <keys_handler_rot1r>
    MOVI    et, ROT1L_MASK       /* check if it was rotary enc 1 left */
  182ccc:	06000204 	movi	et,8
    BEQ     r8, et, keys_handler_rot1l
  182cd0:	46000926 	beq	r8,et,182cf8 <keys_handler_rot1l>
    MOVI    et, ROT2R_MASK       /* check if it was rotary enc 2 right */
  182cd4:	06000044 	movi	et,1
    BEQ     r8, et, keys_handler_rot2r
  182cd8:	46000926 	beq	r8,et,182d00 <keys_handler_rot2r>
    JMPI    keys_handler_rot2l    /* else it must be rotary enc 2 left */
  182cdc:	0182d081 	jmpi	182d08 <keys_handler_rot2l>

00182ce0 <keys_handler_push1>:

keys_handler_push1:               /* handle pushbutton 1 ints */
    MOVI    et, KEY_MENU          /*  translates into menu key */
  182ce0:	06000044 	movi	et,1
    JMPI    keys_handler_done
  182ce4:	0182d101 	jmpi	182d10 <keys_handler_done>

00182ce8 <keys_handler_push2>:

keys_handler_push2:               /* handle pushbutton 2 ints */
    MOVI    et, KEY_MENU          /*  translates into menu key */
  182ce8:	06000044 	movi	et,1
    JMPI    keys_handler_done
  182cec:	0182d101 	jmpi	182d10 <keys_handler_done>

00182cf0 <keys_handler_rot1r>:

keys_handler_rot1r:               /* handle rotary enc 1 right ints */
    MOVI    et, KEY_DOWN          /*  translates into down key */
  182cf0:	060000c4 	movi	et,3
    JMPI    keys_handler_done
  182cf4:	0182d101 	jmpi	182d10 <keys_handler_done>

00182cf8 <keys_handler_rot1l>:

keys_handler_rot1l:               /* handle rotary enc 1 left ints */
    MOVI    et, KEY_UP            /*  translates into up key */
  182cf8:	06000084 	movi	et,2
    JMPI    keys_handler_done
  182cfc:	0182d101 	jmpi	182d10 <keys_handler_done>

00182d00 <keys_handler_rot2r>:

keys_handler_rot2r:               /* handle rotary enc 2 right ints */
    MOVI    et, KEY_RIGHT         /*  translates into right key */
  182d00:	06000144 	movi	et,5
    JMPI    keys_handler_done
  182d04:	0182d101 	jmpi	182d10 <keys_handler_done>

00182d08 <keys_handler_rot2l>:

keys_handler_rot2l:               /* handle rotary enc 2 left ints */
    MOVI    et, KEY_LEFT           /*  translates into left key */
  182d08:	06000104 	movi	et,4
    JMPI    keys_handler_done
  182d0c:	0182d101 	jmpi	182d10 <keys_handler_done>

00182d10 <keys_handler_done>:
  182d10:	020008b4 	movhi	r8,34

keys_handler_done:                /* handling completed */
	MOVIA   r8, curr_key          /* save to curr_key */
  182d14:	42000004 	addi	r8,r8,0
    STB     et, (r8)              /*  the processed key */
  182d18:	46000005 	stb	et,0(r8)

    LDW     r8, (sp)              /* restore r8 */
  182d1c:	da000017 	ldw	r8,0(sp)
    ADDI    sp, sp, WORD_SIZE
  182d20:	dec00104 	addi	sp,sp,4
    RET                           /* all done */
  182d24:	f800283a 	ret

00182d28 <getkey>:
  182d28:	020008b4 	movhi	r8,34
 *      5/14/14   Santiago Navonne     Added additional documentation.
 *
 */
    .global getkey
getkey:
    MOVIA   r8, curr_key      /* return current pending key */
  182d2c:	42000004 	addi	r8,r8,0
    LDB     r2, (r8)
  182d30:	40800007 	ldb	r2,0(r8)
    BEQ     r0, r2, getkey    /* if there is no key (curr_key == r0), block */
  182d34:	00bffc26 	beq	zero,r2,182d28 <getkey>

	STB     r0, (r8) 	      /* clear current key */
  182d38:	40000005 	stb	zero,0(r8)
    RET                       /* return with current pending key in r2 */
  182d3c:	f800283a 	ret

00182d40 <key_available>:
  182d40:	020008b4 	movhi	r8,34
 *      5/14/14   Santiago Navonne     Added additional documentation.
 *
 */
    .globl key_available
key_available:
    MOVIA   r8, curr_key       /* return current pending key */
  182d44:	42000004 	addi	r8,r8,0
    LDB     r2, (r8)           /* will be zero (FALSE) if no key is pending */
  182d48:	40800007 	ldb	r2,0(r8)

    RET                        /* return with boolean in r2 */
  182d4c:	f800283a 	ret

00182d50 <set_sample_rate>:
 *                                     by repeated subtraction.
 *
 */
    .global set_sample_rate
set_sample_rate:
    MOV     r2, r0                 /* load return value of 0 in case of error */
  182d50:	0005883a 	mov	r2,zero
    BEQ     r4, r0, set_sample_rate_done /* error if argument is 0 */
  182d54:	20001126 	beq	r4,zero,182d9c <set_sample_rate_done>

	MOVHI   r8, %hi(CLK_FREQ)      /* load system clock frequency to */
  182d58:	020090f4 	movhi	r8,579
    ORI     r8, r8, %lo(CLK_FREQ)  /*  find number of system clocks that takes */
  182d5c:	42356014 	ori	r8,r8,54656
    /*DIVU    r9, r8, r4             /*  by dividing the sys clk by the requested rate */
    XOR 	r9, r9, r9             /* prepare register for division: r9 is quotient */
  182d60:	4a52f03a 	xor	r9,r9,r9

00182d64 <div_check>:

div_check:                         /* check if the divisor fits in the dividend */
    BLT     r8, r4, div_done       /* we're done when it doesn't any more */
  182d64:	41000316 	blt	r8,r4,182d74 <div_done>

00182d68 <div_loop>:

div_loop:                          /* need to keep subtracting: */
    SUB     r8, r8, r4             /* subtract divisor from dividend */
  182d68:	4111c83a 	sub	r8,r8,r4
    ADDI    r9, r9, 1              /* and increment quotient */
  182d6c:	4a400044 	addi	r9,r9,1
    JMPI    div_check              /* thus repeat as needed */
  182d70:	0182d641 	jmpi	182d64 <div_check>

00182d74 <div_done>:

div_done:
    MOVHI   r8, %hi(TRIG_PERIOD_BASE)     /* load period data register address to */
  182d74:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_PERIOD_BASE) /*  finally save result to trigger period */
  182d78:	42045814 	ori	r8,r8,4448
    STWIO   r9, (r8)               /*  data, effectively setting the sample rate */
  182d7c:	42400035 	stwio	r9,0(r8)

    MOVHI   r8, %hi(TRIG_CTRL_SET) /* load trigger control bit set reg address */
  182d80:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_CTRL_SET)   /* to reset trigger logic */
  182d84:	42041c14 	ori	r8,r8,4208
    MOVI    r9, FIFO_RESET_BIT     /* by sending reset bit high */
  182d88:	02400404 	movi	r9,16
    STWIO   r9, (r8)
  182d8c:	42400035 	stwio	r9,0(r8)
    ADDI    r8, r8, WORD_SIZE      /* and then move to bit clr reg */
  182d90:	42000104 	addi	r8,r8,4
    STWIO   r9, (r8)               /* to send it low */
  182d94:	42400035 	stwio	r9,0(r8)

    MOVI    r2, SIZE_X             /* number of samples acquired is always size of display */
  182d98:	00807804 	movi	r2,480

00182d9c <set_sample_rate_done>:

set_sample_rate_done:              /* all done */
    RET                            /* return value is in r2 */
  182d9c:	f800283a 	ret

00182da0 <set_trigger>:
 *      6/01/14   Santiago Navonne     Expanded documentation.
 *
 */
    .global set_trigger
set_trigger:
    MOVHI   r10, %hi(TRIG_LEVEL_BASE) /* load trigger level register address to update */
  182da0:	02800934 	movhi	r10,36
    ORI     r10, r10, %lo(TRIG_LEVEL_BASE) /* the desired trigger level */
  182da4:	52845414 	ori	r10,r10,4432
    MOVI    r9, TRIG_LEVEL_SHIFT   /* shift the passed argument left as needed to */
  182da8:	02400044 	movi	r9,1
    SLL     r4, r4, r9             /*  make sure we output a full byte */
  182dac:	2248983a 	sll	r4,r4,r9
    SUBI    r4, r4, CALIBRATION    /* and correct value with calibration data */
  182db0:	213ffcc4 	addi	r4,r4,-13

    MOVHI   r8, %hi(TRIG_CTRL_CLR) /* load control register bit clear address to */
  182db4:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_CTRL_CLR) /*  initially assume that we want to set  */
  182db8:	42041d14 	ori	r8,r8,4212
    MOVI    r9, 2                  /*  slope to negative (clear the bit) */
  182dbc:	02400084 	movi	r9,2
    SLL     r5, r5, r9             /* subtract argument multiplied by word size */
  182dc0:	2a4a983a 	sll	r5,r5,r9
    SUB     r8, r8, r5             /*  effectively moving to set bit register if enabling */
  182dc4:	4151c83a 	sub	r8,r8,r5
                                   /*  positive slope */

    MOVI    r9, SLOPE_BIT          /* finally write the appropriate bit to the register */
  182dc8:	02400084 	movi	r9,2
    STWIO   r9, (r8)               /* enabling or disabling the bit as needed */
  182dcc:	42400035 	stwio	r9,0(r8)

    STWIO   r4, (r10)              /* and output desired trigger level */
  182dd0:	51000035 	stwio	r4,0(r10)

    MOVHI   r8, %hi(TRIG_CTRL_SET) /* load trigger control bit set reg address */
  182dd4:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_CTRL_SET)     /* to reset trigger logic */
  182dd8:	42041c14 	ori	r8,r8,4208
    MOVI    r9, FIFO_RESET_BIT     /* by sending reset bit high */
  182ddc:	02400404 	movi	r9,16
    STWIO   r9, (r8)
  182de0:	42400035 	stwio	r9,0(r8)
    ADDI    r8, r8, WORD_SIZE      /* and then move to bit clr reg */
  182de4:	42000104 	addi	r8,r8,4
    STWIO   r9, (r8)               /* to send it low */
  182de8:	42400035 	stwio	r9,0(r8)

    RET                            /* all done, so return */
  182dec:	f800283a 	ret

00182df0 <set_delay>:
 *      6/01/14   Santiago Navonne     Expanded documentation.
 *
 */
    .global set_delay
set_delay:
    MOVHI   r10, %hi(TRIG_DELAY_BASE) /* load trigger delay register address to update */
  182df0:	02800934 	movhi	r10,36
    ORI     r10, r10, %lo(TRIG_DELAY_BASE) /* the desired delay time */
  182df4:	52844814 	ori	r10,r10,4384
    ADDI 	r4, r4, DELAY_CONSTANT    /* add delay constant to correct argument */
  182df8:	21000044 	addi	r4,r4,1
    STWIO   r4, (r10) 			      /* and output to delay register, effectively */
  182dfc:	51000035 	stwio	r4,0(r10)
                                      /* configuring delay */

    MOVHI   r8, %hi(TRIG_CTRL_SET)    /* load trigger control bit set reg address */
  182e00:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_CTRL_SET)     /* to reset trigger logic */
  182e04:	42041c14 	ori	r8,r8,4208
    MOVI    r9, FIFO_RESET_BIT        /* by sending reset bit high */
  182e08:	02400404 	movi	r9,16
    STWIO   r9, (r8)
  182e0c:	42400035 	stwio	r9,0(r8)
    ADDI    r8, r8, WORD_SIZE         /* and then move to bit clr reg */
  182e10:	42000104 	addi	r8,r8,4
    STWIO   r9, (r8)                  /* to send it low */
  182e14:	42400035 	stwio	r9,0(r8)

    RET                               /* all done, so return */
  182e18:	f800283a 	ret

00182e1c <start_sample>:
 *
 */
    .global start_sample
start_sample:

    MOVHI   r8, %hi(TRIG_CTRL_CLR) /* load trigger control bit clear reg address */
  182e1c:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_CTRL_CLR) /* assuming we'll clear auto trigger bit */
  182e20:	42041d14 	ori	r8,r8,4212
    MOVI    r9, 2                  /* subtract argument multiplied by word size */
  182e24:	02400084 	movi	r9,2
    SLL     r4, r4, r9             /* effectively moving to set bit register if enabling */
  182e28:	2248983a 	sll	r4,r4,r9
    SUB     r8, r8, r4             /*  auto trigger*/
  182e2c:	4111c83a 	sub	r8,r8,r4

    MOVI    r9, AUTO_TRIG_BIT      /* store auto trigger bit in configured register */
  182e30:	02400044 	movi	r9,1
    STWIO   r9, (r8)               /* enabling or disabling it as needed */
  182e34:	42400035 	stwio	r9,0(r8)

	MOVHI   r8, %hi(TRIG_CTRL_SET)    /* load trigger control bit set reg address */
  182e38:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_CTRL_SET)     /* to reset trigger logic */
  182e3c:	42041c14 	ori	r8,r8,4208
    MOVI    r9, FIFO_RESET_BIT        /* by sending reset bit high */
  182e40:	02400404 	movi	r9,16
    STWIO   r9, (r8)
  182e44:	42400035 	stwio	r9,0(r8)
    ADDI    r8, r8, WORD_SIZE         /* and then move to bit clr reg */
  182e48:	42000104 	addi	r8,r8,4
    STWIO   r9, (r8)                  /* to send it low */
  182e4c:	42400035 	stwio	r9,0(r8)

    MOVHI   r8, %hi(TRIG_CTRL_CLR) /* load trigger control bit clear reg address */
  182e50:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_CTRL_CLR) /* to clear fifo write enable (make active) */
  182e54:	42041d14 	ori	r8,r8,4212
    MOVI    r9, FIFO_WE_BIT        /* which allows the fifo to be filled with samples */
  182e58:	02400104 	movi	r9,4
    STWIO   r9, (r8)               /* effectively starting a sample */
  182e5c:	42400035 	stwio	r9,0(r8)

00182e60 <start_sample_done>:

start_sample_done:
    RET                            /* all done, so return */
  182e60:	f800283a 	ret

00182e64 <sample_done>:
 *      6/01/14   Santiago Navonne     Expanded documentation.
 *
 */
    .global sample_done
sample_done:
    MOV     r2, r0                 /* assume no sample ready: null pointer return val */
  182e64:	0005883a 	mov	r2,zero
  182e68:	020008b4 	movhi	r8,34
    MOVIA   r8, sample_pending     /* fetch current pending value to see if this call */
  182e6c:	42000044 	addi	r8,r8,1
    LDB     r9, (r8)               /* should be ignored */
  182e70:	42400007 	ldb	r9,0(r8)
    BEQ     r0, r9, sample_done_done   /*  which is when value is zero */
  182e74:	02402426 	beq	zero,r9,182f08 <sample_done_done>
  182e78:	020008b4 	movhi	r8,34

    MOVIA   r8, sample_pending     /* reset sample_pending to indicate  */
  182e7c:	42000044 	addi	r8,r8,1
    STB     r0, (r8)               /* no sample is ready for processing */
  182e80:	40000005 	stb	zero,0(r8)

    MOVHI   r12, %hi(FIFO_DATA_BASE) /* load fifo data register address */
  182e84:	03000934 	movhi	r12,36
    ORI     r12, r12, %lo(FIFO_DATA_BASE) /* to actually read data from fifo */
  182e88:	63045014 	ori	r12,r12,4416
    MOVHI   r8, %hi(TRIG_CTRL_SET) /* load ctrl reg set bit addr for */
  182e8c:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_CTRL_SET)    /* for bit banging */
  182e90:	42041c14 	ori	r8,r8,4208
  182e94:	034008b4 	movhi	r13,34
    MOVIA   r13, sample            /* load array address to store samples */
  182e98:	6b400084 	addi	r13,r13,2
    MOV     r2, r13                /* and also use it as return value (pointer) */
  182e9c:	6805883a 	mov	r2,r13
    MOV     r10, r0                /* and start a counter at 0 for looping */
  182ea0:	0015883a 	mov	r10,zero
    MOVI    r11, FIFO_SIZE         /* which will stop at FIFO_SIZE */
  182ea4:	02c08004 	movi	r11,512
    MOVI    r9, FIFO_READ_BIT      /* finally load read clk bit for big banging */
  182ea8:	02400204 	movi	r9,8

    							   /* FIFO has 2 clocks latency */
    STWIO   r9, (r8)               /* send read clock high to output sample */
  182eac:	42400035 	stwio	r9,0(r8)
    ADDI    r8, r8, WORD_SIZE      /* and move to clear register: will send low next time */
  182eb0:	42000104 	addi	r8,r8,4
    NOP                            /* wait for sample to actually come through */
  182eb4:	0001883a 	nop
    STWIO   r9, (r8)               /* send read clock low to prepare for next sample */
  182eb8:	42400035 	stwio	r9,0(r8)
    ADDI    r8, r8, NEG_WORD_SIZE  /* and move to set register: will send high next time  */
  182ebc:	423fff04 	addi	r8,r8,-4
    NOP                            /* wait for sample to actually come through */
  182ec0:	0001883a 	nop

    STWIO   r9, (r8)               /* send read clock high to output sample */
  182ec4:	42400035 	stwio	r9,0(r8)
    ADDI    r8, r8, WORD_SIZE      /* and move to clear register: will send low next time */
  182ec8:	42000104 	addi	r8,r8,4
    NOP                            /* wait for sample to actually come through */
  182ecc:	0001883a 	nop
    STWIO   r9, (r8)               /* send read clock low to prepare for next sample */
  182ed0:	42400035 	stwio	r9,0(r8)
    ADDI    r8, r8, NEG_WORD_SIZE  /* and move to set register: will send high next time  */
  182ed4:	423fff04 	addi	r8,r8,-4
    NOP                            /* wait for sample to actually come through */
  182ed8:	0001883a 	nop

00182edc <get_data>:

get_data:
    STWIO   r9, (r8)               /* send read clock high to output sample */
  182edc:	42400035 	stwio	r9,0(r8)
    ADDI    r8, r8, WORD_SIZE      /* and move to clear register: will send low next time */
  182ee0:	42000104 	addi	r8,r8,4
    NOP                            /* wait for sample to actually come through */
  182ee4:	0001883a 	nop
    
    LDBIO   r14, (r12)             /* read sample from fifo */
  182ee8:	63800027 	ldbio	r14,0(r12)
    ADDI    r14, r14, CALIBRATION  /* add calibration constant */
  182eec:	73800344 	addi	r14,r14,13
    STBIO   r14, (r13)             /* and store it in the sample array */
  182ef0:	6b800025 	stbio	r14,0(r13)

    STWIO   r9, (r8)               /* send read clock low to prepare for next sample */
  182ef4:	42400035 	stwio	r9,0(r8)
    ADDI    r8, r8, NEG_WORD_SIZE  /* and move to set register: will send high next time  */
  182ef8:	423fff04 	addi	r8,r8,-4

    ADDI    r10, r10, 1            /* increment counter */
  182efc:	52800044 	addi	r10,r10,1
    ADDI    r13, r13, 1            /* and sample pointer */
  182f00:	6b400044 	addi	r13,r13,1
    BNE     r10, r11, get_data     /* and keep getting data until we reach end */
  182f04:	52fff51e 	bne	r10,r11,182edc <get_data>

00182f08 <sample_done_done>:

sample_done_done:                  /* all done */
    RET                            /* so return with pointer (or NULL) in r2 */
  182f08:	f800283a 	ret

00182f0c <sample_handler>:
  182f0c:	020008b4 	movhi	r8,34
 *      6/01/14   Santiago Navonne     Expanded documentation.
 *
 */
    .global sample_handler
sample_handler:
    MOVIA   r8, sample_pending     /* mark sample_pending as true to indicate  */
  182f10:	42000044 	addi	r8,r8,1
	MOVI 	r9, TRUE  			   /* a sample is ready for processing */
  182f14:	02400044 	movi	r9,1
    STB     r9, (r8)               
  182f18:	42400005 	stb	r9,0(r8)

    MOVHI   r8, %hi(TRIG_CTRL_SET) /* load trigger control bit set reg address */
  182f1c:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_CTRL_SET)  /* to set fifo write enable (make inactive) */
  182f20:	42041c14 	ori	r8,r8,4208
    MOVI    r9, FIFO_WE_BIT        /* which prevents the fifo from being filled again */
  182f24:	02400104 	movi	r9,4
    STWIO   r9, (r8)               /* effectively stopping a sample */
  182f28:	42400035 	stwio	r9,0(r8)

    MOVHI   r8, %hi(FIFO_FULL_BASE)/* write to edge capture register */
  182f2c:	02000934 	movhi	r8,36
    ORI 	r8, r8, %lo(FIFO_FULL_BASE) /* to send EOI */
  182f30:	42044c14 	ori	r8,r8,4400
	MOVI 	r9, FIFO_INT
  182f34:	02400044 	movi	r9,1
    STWIO   r9, EDGE_CAP_OF(r8)
  182f38:	42400335 	stwio	r9,12(r8)

    RET                            /* all done, so return */
  182f3c:	f800283a 	ret

00182f40 <trigger_init>:
  182f40:	020008b4 	movhi	r8,34
 *      6/01/14   Santiago Navonne     Expanded documentation.
 *
 */
    .global trigger_init
trigger_init:
    MOVIA   r8, sample_pending     /* mark sample_pending as false to indicate  */
  182f44:	42000044 	addi	r8,r8,1
    STB     r0, (r8)               /* no sample is ready for processing */
  182f48:	40000005 	stb	zero,0(r8)

    MOVHI   r8, %hi(TRIG_LEVEL_BASE)     /* load trigger level reg address */
  182f4c:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_LEVEL_BASE) /* to set default value */
  182f50:	42045414 	ori	r8,r8,4432
    MOVI    r9, TRIG_LEVEL_DEF
  182f54:	02402004 	movi	r9,128
    STWIO   r9, (r8)
  182f58:	42400035 	stwio	r9,0(r8)

    MOVHI   r8, %hi(TRIG_DELAY_BASE)     /* load trigger delay reg address */
  182f5c:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_DELAY_BASE) /* to set default value */
  182f60:	42044814 	ori	r8,r8,4384
    MOVI    r9, TRIG_DELAY_DEF
  182f64:	02400044 	movi	r9,1
    STWIO   r9, (r8)
  182f68:	42400035 	stwio	r9,0(r8)

    MOVHI   r8, %hi(TRIG_PERIOD_BASE)    /* load trigger period reg address */
  182f6c:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_PERIOD_BASE)/* to set default value for rate */
  182f70:	42045814 	ori	r8,r8,4448
    MOVI    r9, TRIG_PERIOD_DEF
  182f74:	02400084 	movi	r9,2
    STWIO   r9, (r8)
  182f78:	42400035 	stwio	r9,0(r8)

    MOVHI   r8, %hi(TRIG_CTRL_SET) /* load trigger control bit set reg address */
  182f7c:	02000934 	movhi	r8,36
    ORI     r8, r8, %lo(TRIG_CTRL_SET)   /* to reset trigger logic */
  182f80:	42041c14 	ori	r8,r8,4208
    MOVI    r9, FIFO_RESET_BIT     /* by sending reset bit high */
  182f84:	02400404 	movi	r9,16
    STWIO   r9, (r8)
  182f88:	42400035 	stwio	r9,0(r8)

    MOVI    r9, TRIG_CTRL_DEF      /* load default WE, read clock, auto */
  182f8c:	024001c4 	movi	r9,7
    STWIO   r9, (r8)               /* trigger, and slope values */
  182f90:	42400035 	stwio	r9,0(r8)
    ADDI    r8, r8, WORD_SIZE 	   /* and move to clear register */
  182f94:	42000104 	addi	r8,r8,4
    MOVI    r9, FIFO_RESET_BIT     /* to send reset bit low */
  182f98:	02400404 	movi	r9,16
    STWIO   r9, (r8)
  182f9c:	42400035 	stwio	r9,0(r8)

	MOVHI   r8, %hi(FIFO_FULL_BASE)/* write to edge capture register to send */
  182fa0:	02000934 	movhi	r8,36
    ORI 	r8, r8, %lo(FIFO_FULL_BASE)  /* EOI to pending interrupts */
  182fa4:	42044c14 	ori	r8,r8,4400
	MOVI 	r9, FIFO_INT 		   /* and to edge capture register to send */
  182fa8:	02400044 	movi	r9,1
    STWIO   r9, EDGE_CAP_OF(r8)    /* EOI to pending interrupts */
  182fac:	42400335 	stwio	r9,12(r8)


	ADDI    sp, sp, NEG_WORD_SIZE  /* register interrupt handler */
  182fb0:	deffff04 	addi	sp,sp,-4
    STW     ra, 0(sp)              /* push return address */
  182fb4:	dfc00015 	stw	ra,0(sp)
    MOV     r4, r0                 /* argument ic_id is ignored */
  182fb8:	0009883a 	mov	r4,zero
    MOVI    r5, FIFO_FULL_IRQ      /* second arg is IRQ num */
  182fbc:	01400104 	movi	r5,4
  182fc0:	01800634 	movhi	r6,24
    MOVIA   r6, sample_handler     /* third arg is int handler */
  182fc4:	318bc304 	addi	r6,r6,12044
    MOV     r7, r0                 /* fourth arg is data struct (null) */
  182fc8:	000f883a 	mov	r7,zero
    ADDI    sp, sp, NEG_WORD_SIZE  /* fifth arg goes on stack */
  182fcc:	deffff04 	addi	sp,sp,-4
    STW     r0, 0(sp)              /*  and is ignored (so 0) */
  182fd0:	d8000015 	stw	zero,0(sp)
    CALL    alt_ic_isr_register    /* finally, call setup function */
  182fd4:	01835380 	call	183538 <alt_ic_isr_register>
    ADDI    sp, sp, WORD_SIZE      /* clean up stack after call */
  182fd8:	dec00104 	addi	sp,sp,4
    LDW     ra, 0(sp)              /* pop return address */
  182fdc:	dfc00017 	ldw	ra,0(sp)
    ADDI    sp, sp, WORD_SIZE
  182fe0:	dec00104 	addi	sp,sp,4

	MOVHI   r8, %hi(FIFO_FULL_BASE)/* write to interrupt mask register */
  182fe4:	02000934 	movhi	r8,36
    ORI 	r8, r8, %lo(FIFO_FULL_BASE)  /* to enable interrupts */
  182fe8:	42044c14 	ori	r8,r8,4400
	MOVI 	r9, FIFO_INT
  182fec:	02400044 	movi	r9,1
    STWIO   r9, INTMASK_OF(r8)
  182ff0:	42400235 	stwio	r9,8(r8)


    RET                            /* all done, so return */
  182ff4:	f800283a 	ret

00182ff8 <__floatsisf>:
  182ff8:	2004d7fa 	srli	r2,r4,31
  182ffc:	defffa04 	addi	sp,sp,-24
  183000:	00c000c4 	movi	r3,3
  183004:	dfc00515 	stw	ra,20(sp)
  183008:	dc000415 	stw	r16,16(sp)
  18300c:	d8c00015 	stw	r3,0(sp)
  183010:	d8800115 	stw	r2,4(sp)
  183014:	2000081e 	bne	r4,zero,183038 <__floatsisf+0x40>
  183018:	00800084 	movi	r2,2
  18301c:	d8800015 	stw	r2,0(sp)
  183020:	d809883a 	mov	r4,sp
  183024:	01833440 	call	183344 <__pack_f>
  183028:	dfc00517 	ldw	ra,20(sp)
  18302c:	dc000417 	ldw	r16,16(sp)
  183030:	dec00604 	addi	sp,sp,24
  183034:	f800283a 	ret
  183038:	00c00784 	movi	r3,30
  18303c:	d8c00215 	stw	r3,8(sp)
  183040:	10000b1e 	bne	r2,zero,183070 <__floatsisf+0x78>
  183044:	2021883a 	mov	r16,r4
  183048:	8009883a 	mov	r4,r16
  18304c:	01832980 	call	183298 <__clzsi2>
  183050:	113fffc4 	addi	r4,r2,-1
  183054:	01000d0e 	bge	zero,r4,18308c <__floatsisf+0x94>
  183058:	8108983a 	sll	r4,r16,r4
  18305c:	00c007c4 	movi	r3,31
  183060:	1885c83a 	sub	r2,r3,r2
  183064:	d9000315 	stw	r4,12(sp)
  183068:	d8800215 	stw	r2,8(sp)
  18306c:	003fec06 	br	183020 <__floatsisf+0x28>
  183070:	00a00034 	movhi	r2,32768
  183074:	20800726 	beq	r4,r2,183094 <__floatsisf+0x9c>
  183078:	0121c83a 	sub	r16,zero,r4
  18307c:	8009883a 	mov	r4,r16
  183080:	01832980 	call	183298 <__clzsi2>
  183084:	113fffc4 	addi	r4,r2,-1
  183088:	013ff316 	blt	zero,r4,183058 <__floatsisf+0x60>
  18308c:	dc000315 	stw	r16,12(sp)
  183090:	003fe306 	br	183020 <__floatsisf+0x28>
  183094:	00b3c034 	movhi	r2,52992
  183098:	003fe306 	br	183028 <__floatsisf+0x30>

0018309c <__fixsfsi>:
  18309c:	defffa04 	addi	sp,sp,-24
  1830a0:	d9000415 	stw	r4,16(sp)
  1830a4:	d80b883a 	mov	r5,sp
  1830a8:	d9000404 	addi	r4,sp,16
  1830ac:	dfc00515 	stw	ra,20(sp)
  1830b0:	01834700 	call	183470 <__unpack_f>
  1830b4:	d8800017 	ldw	r2,0(sp)
  1830b8:	00c00084 	movi	r3,2
  1830bc:	10c01826 	beq	r2,r3,183120 <__fixsfsi+0x84>
  1830c0:	00c00044 	movi	r3,1
  1830c4:	1880162e 	bgeu	r3,r2,183120 <__fixsfsi+0x84>
  1830c8:	00c00104 	movi	r3,4
  1830cc:	10c00426 	beq	r2,r3,1830e0 <__fixsfsi+0x44>
  1830d0:	d8800217 	ldw	r2,8(sp)
  1830d4:	10001216 	blt	r2,zero,183120 <__fixsfsi+0x84>
  1830d8:	00c00784 	movi	r3,30
  1830dc:	1880070e 	bge	r3,r2,1830fc <__fixsfsi+0x60>
  1830e0:	d8800117 	ldw	r2,4(sp)
  1830e4:	1000121e 	bne	r2,zero,183130 <__fixsfsi+0x94>
  1830e8:	00a00034 	movhi	r2,32768
  1830ec:	10bfffc4 	addi	r2,r2,-1
  1830f0:	dfc00517 	ldw	ra,20(sp)
  1830f4:	dec00604 	addi	sp,sp,24
  1830f8:	f800283a 	ret
  1830fc:	1885c83a 	sub	r2,r3,r2
  183100:	d8c00317 	ldw	r3,12(sp)
  183104:	1884d83a 	srl	r2,r3,r2
  183108:	d8c00117 	ldw	r3,4(sp)
  18310c:	183ff826 	beq	r3,zero,1830f0 <__fixsfsi+0x54>
  183110:	0085c83a 	sub	r2,zero,r2
  183114:	dfc00517 	ldw	ra,20(sp)
  183118:	dec00604 	addi	sp,sp,24
  18311c:	f800283a 	ret
  183120:	0005883a 	mov	r2,zero
  183124:	dfc00517 	ldw	ra,20(sp)
  183128:	dec00604 	addi	sp,sp,24
  18312c:	f800283a 	ret
  183130:	00a00034 	movhi	r2,32768
  183134:	dfc00517 	ldw	ra,20(sp)
  183138:	dec00604 	addi	sp,sp,24
  18313c:	f800283a 	ret

00183140 <udivmodsi4>:
  183140:	2005883a 	mov	r2,r4
  183144:	2900182e 	bgeu	r5,r4,1831a8 <udivmodsi4+0x68>
  183148:	28001716 	blt	r5,zero,1831a8 <udivmodsi4+0x68>
  18314c:	01000804 	movi	r4,32
  183150:	00c00044 	movi	r3,1
  183154:	00000206 	br	183160 <udivmodsi4+0x20>
  183158:	20001126 	beq	r4,zero,1831a0 <udivmodsi4+0x60>
  18315c:	28000516 	blt	r5,zero,183174 <udivmodsi4+0x34>
  183160:	294b883a 	add	r5,r5,r5
  183164:	213fffc4 	addi	r4,r4,-1
  183168:	18c7883a 	add	r3,r3,r3
  18316c:	28bffa36 	bltu	r5,r2,183158 <udivmodsi4+0x18>
  183170:	18000b26 	beq	r3,zero,1831a0 <udivmodsi4+0x60>
  183174:	0009883a 	mov	r4,zero
  183178:	11400236 	bltu	r2,r5,183184 <udivmodsi4+0x44>
  18317c:	1145c83a 	sub	r2,r2,r5
  183180:	20c8b03a 	or	r4,r4,r3
  183184:	1806d07a 	srli	r3,r3,1
  183188:	280ad07a 	srli	r5,r5,1
  18318c:	183ffa1e 	bne	r3,zero,183178 <udivmodsi4+0x38>
  183190:	3000021e 	bne	r6,zero,18319c <udivmodsi4+0x5c>
  183194:	2005883a 	mov	r2,r4
  183198:	f800283a 	ret
  18319c:	f800283a 	ret
  1831a0:	0009883a 	mov	r4,zero
  1831a4:	003ffa06 	br	183190 <udivmodsi4+0x50>
  1831a8:	00c00044 	movi	r3,1
  1831ac:	0009883a 	mov	r4,zero
  1831b0:	003ff106 	br	183178 <udivmodsi4+0x38>

001831b4 <__divsi3>:
  1831b4:	defffe04 	addi	sp,sp,-8
  1831b8:	dfc00115 	stw	ra,4(sp)
  1831bc:	dc000015 	stw	r16,0(sp)
  1831c0:	20000a16 	blt	r4,zero,1831ec <__divsi3+0x38>
  1831c4:	0021883a 	mov	r16,zero
  1831c8:	28000b16 	blt	r5,zero,1831f8 <__divsi3+0x44>
  1831cc:	000d883a 	mov	r6,zero
  1831d0:	01831400 	call	183140 <udivmodsi4>
  1831d4:	80000126 	beq	r16,zero,1831dc <__divsi3+0x28>
  1831d8:	0085c83a 	sub	r2,zero,r2
  1831dc:	dfc00117 	ldw	ra,4(sp)
  1831e0:	dc000017 	ldw	r16,0(sp)
  1831e4:	dec00204 	addi	sp,sp,8
  1831e8:	f800283a 	ret
  1831ec:	0109c83a 	sub	r4,zero,r4
  1831f0:	04000044 	movi	r16,1
  1831f4:	283ff50e 	bge	r5,zero,1831cc <__divsi3+0x18>
  1831f8:	014bc83a 	sub	r5,zero,r5
  1831fc:	8400005c 	xori	r16,r16,1
  183200:	003ff206 	br	1831cc <__divsi3+0x18>

00183204 <__modsi3>:
  183204:	deffff04 	addi	sp,sp,-4
  183208:	dfc00015 	stw	ra,0(sp)
  18320c:	20000516 	blt	r4,zero,183224 <__modsi3+0x20>
  183210:	28000c16 	blt	r5,zero,183244 <__modsi3+0x40>
  183214:	01800044 	movi	r6,1
  183218:	dfc00017 	ldw	ra,0(sp)
  18321c:	dec00104 	addi	sp,sp,4
  183220:	01831401 	jmpi	183140 <udivmodsi4>
  183224:	0109c83a 	sub	r4,zero,r4
  183228:	28000b16 	blt	r5,zero,183258 <__modsi3+0x54>
  18322c:	01800044 	movi	r6,1
  183230:	01831400 	call	183140 <udivmodsi4>
  183234:	0085c83a 	sub	r2,zero,r2
  183238:	dfc00017 	ldw	ra,0(sp)
  18323c:	dec00104 	addi	sp,sp,4
  183240:	f800283a 	ret
  183244:	014bc83a 	sub	r5,zero,r5
  183248:	01800044 	movi	r6,1
  18324c:	dfc00017 	ldw	ra,0(sp)
  183250:	dec00104 	addi	sp,sp,4
  183254:	01831401 	jmpi	183140 <udivmodsi4>
  183258:	014bc83a 	sub	r5,zero,r5
  18325c:	003ff306 	br	18322c <__modsi3+0x28>

00183260 <__udivsi3>:
  183260:	000d883a 	mov	r6,zero
  183264:	01831401 	jmpi	183140 <udivmodsi4>

00183268 <__umodsi3>:
  183268:	01800044 	movi	r6,1
  18326c:	01831401 	jmpi	183140 <udivmodsi4>

00183270 <__mulsi3>:
  183270:	0005883a 	mov	r2,zero
  183274:	20000726 	beq	r4,zero,183294 <__mulsi3+0x24>
  183278:	20c0004c 	andi	r3,r4,1
  18327c:	2008d07a 	srli	r4,r4,1
  183280:	18000126 	beq	r3,zero,183288 <__mulsi3+0x18>
  183284:	1145883a 	add	r2,r2,r5
  183288:	294b883a 	add	r5,r5,r5
  18328c:	203ffa1e 	bne	r4,zero,183278 <__mulsi3+0x8>
  183290:	f800283a 	ret
  183294:	f800283a 	ret

00183298 <__clzsi2>:
  183298:	00bfffd4 	movui	r2,65535
  18329c:	11000b36 	bltu	r2,r4,1832cc <__clzsi2+0x34>
  1832a0:	00803fc4 	movi	r2,255
  1832a4:	11001e2e 	bgeu	r2,r4,183320 <__clzsi2+0x88>
  1832a8:	00c00204 	movi	r3,8
  1832ac:	20c8d83a 	srl	r4,r4,r3
  1832b0:	00c00634 	movhi	r3,24
  1832b4:	18d7cf04 	addi	r3,r3,24380
  1832b8:	00800604 	movi	r2,24
  1832bc:	1909883a 	add	r4,r3,r4
  1832c0:	20c00003 	ldbu	r3,0(r4)
  1832c4:	10c5c83a 	sub	r2,r2,r3
  1832c8:	f800283a 	ret
  1832cc:	00804034 	movhi	r2,256
  1832d0:	10bfffc4 	addi	r2,r2,-1
  1832d4:	11000936 	bltu	r2,r4,1832fc <__clzsi2+0x64>
  1832d8:	00800404 	movi	r2,16
  1832dc:	1007883a 	mov	r3,r2
  1832e0:	20c8d83a 	srl	r4,r4,r3
  1832e4:	00c00634 	movhi	r3,24
  1832e8:	18d7cf04 	addi	r3,r3,24380
  1832ec:	1909883a 	add	r4,r3,r4
  1832f0:	20c00003 	ldbu	r3,0(r4)
  1832f4:	10c5c83a 	sub	r2,r2,r3
  1832f8:	f800283a 	ret
  1832fc:	00c00604 	movi	r3,24
  183300:	20c8d83a 	srl	r4,r4,r3
  183304:	00c00634 	movhi	r3,24
  183308:	18d7cf04 	addi	r3,r3,24380
  18330c:	00800204 	movi	r2,8
  183310:	1909883a 	add	r4,r3,r4
  183314:	20c00003 	ldbu	r3,0(r4)
  183318:	10c5c83a 	sub	r2,r2,r3
  18331c:	f800283a 	ret
  183320:	0007883a 	mov	r3,zero
  183324:	20c8d83a 	srl	r4,r4,r3
  183328:	00c00634 	movhi	r3,24
  18332c:	18d7cf04 	addi	r3,r3,24380
  183330:	00800804 	movi	r2,32
  183334:	1909883a 	add	r4,r3,r4
  183338:	20c00003 	ldbu	r3,0(r4)
  18333c:	10c5c83a 	sub	r2,r2,r3
  183340:	f800283a 	ret

00183344 <__pack_f>:
  183344:	21400017 	ldw	r5,0(r4)
  183348:	01800044 	movi	r6,1
  18334c:	20c00317 	ldw	r3,12(r4)
  183350:	21c00117 	ldw	r7,4(r4)
  183354:	3140282e 	bgeu	r6,r5,1833f8 <__pack_f+0xb4>
  183358:	00800104 	movi	r2,4
  18335c:	28802326 	beq	r5,r2,1833ec <__pack_f+0xa8>
  183360:	00800084 	movi	r2,2
  183364:	28800f26 	beq	r5,r2,1833a4 <__pack_f+0x60>
  183368:	18000e26 	beq	r3,zero,1833a4 <__pack_f+0x60>
  18336c:	21000217 	ldw	r4,8(r4)
  183370:	00bfe084 	movi	r2,-126
  183374:	20802616 	blt	r4,r2,183410 <__pack_f+0xcc>
  183378:	00801fc4 	movi	r2,127
  18337c:	11001b16 	blt	r2,r4,1833ec <__pack_f+0xa8>
  183380:	188a703a 	and	r5,r3,r2
  183384:	00801004 	movi	r2,64
  183388:	28801126 	beq	r5,r2,1833d0 <__pack_f+0x8c>
  18338c:	18c00fc4 	addi	r3,r3,63
  183390:	18001316 	blt	r3,zero,1833e0 <__pack_f+0x9c>
  183394:	21001fc4 	addi	r4,r4,127
  183398:	180690ba 	slli	r3,r3,2
  18339c:	1806d27a 	srli	r3,r3,9
  1833a0:	00000206 	br	1833ac <__pack_f+0x68>
  1833a4:	0009883a 	mov	r4,zero
  1833a8:	0007883a 	mov	r3,zero
  1833ac:	21003fcc 	andi	r4,r4,255
  1833b0:	200895fa 	slli	r4,r4,23
  1833b4:	380a97fa 	slli	r5,r7,31
  1833b8:	00802034 	movhi	r2,128
  1833bc:	10bfffc4 	addi	r2,r2,-1
  1833c0:	1886703a 	and	r3,r3,r2
  1833c4:	1904b03a 	or	r2,r3,r4
  1833c8:	1144b03a 	or	r2,r2,r5
  1833cc:	f800283a 	ret
  1833d0:	1880200c 	andi	r2,r3,128
  1833d4:	103fee26 	beq	r2,zero,183390 <__pack_f+0x4c>
  1833d8:	18c01004 	addi	r3,r3,64
  1833dc:	183fed0e 	bge	r3,zero,183394 <__pack_f+0x50>
  1833e0:	1806d07a 	srli	r3,r3,1
  1833e4:	21002004 	addi	r4,r4,128
  1833e8:	003feb06 	br	183398 <__pack_f+0x54>
  1833ec:	013fffc4 	movi	r4,-1
  1833f0:	0007883a 	mov	r3,zero
  1833f4:	003fed06 	br	1833ac <__pack_f+0x68>
  1833f8:	18c00434 	orhi	r3,r3,16
  1833fc:	00802034 	movhi	r2,128
  183400:	10bfffc4 	addi	r2,r2,-1
  183404:	1886703a 	and	r3,r3,r2
  183408:	013fffc4 	movi	r4,-1
  18340c:	003fe706 	br	1833ac <__pack_f+0x68>
  183410:	1105c83a 	sub	r2,r2,r4
  183414:	01000644 	movi	r4,25
  183418:	20801216 	blt	r4,r2,183464 <__pack_f+0x120>
  18341c:	3088983a 	sll	r4,r6,r2
  183420:	1884d83a 	srl	r2,r3,r2
  183424:	213fffc4 	addi	r4,r4,-1
  183428:	20c6703a 	and	r3,r4,r3
  18342c:	1806c03a 	cmpne	r3,r3,zero
  183430:	1884b03a 	or	r2,r3,r2
  183434:	11001fcc 	andi	r4,r2,127
  183438:	00c01004 	movi	r3,64
  18343c:	20c00a1e 	bne	r4,r3,183468 <__pack_f+0x124>
  183440:	10c0200c 	andi	r3,r2,128
  183444:	18000126 	beq	r3,zero,18344c <__pack_f+0x108>
  183448:	10801004 	addi	r2,r2,64
  18344c:	100690ba 	slli	r3,r2,2
  183450:	01100034 	movhi	r4,16384
  183454:	1105403a 	cmpgeu	r2,r2,r4
  183458:	1806d27a 	srli	r3,r3,9
  18345c:	1009883a 	mov	r4,r2
  183460:	003fd206 	br	1833ac <__pack_f+0x68>
  183464:	0005883a 	mov	r2,zero
  183468:	10800fc4 	addi	r2,r2,63
  18346c:	003ff706 	br	18344c <__pack_f+0x108>

00183470 <__unpack_f>:
  183470:	20c00017 	ldw	r3,0(r4)
  183474:	00802034 	movhi	r2,128
  183478:	10bfffc4 	addi	r2,r2,-1
  18347c:	1808d5fa 	srli	r4,r3,23
  183480:	180cd7fa 	srli	r6,r3,31
  183484:	1884703a 	and	r2,r3,r2
  183488:	21003fcc 	andi	r4,r4,255
  18348c:	29800115 	stw	r6,4(r5)
  183490:	2000111e 	bne	r4,zero,1834d8 <__unpack_f+0x68>
  183494:	10001a26 	beq	r2,zero,183500 <__unpack_f+0x90>
  183498:	00ffe084 	movi	r3,-126
  18349c:	100491fa 	slli	r2,r2,7
  1834a0:	28c00215 	stw	r3,8(r5)
  1834a4:	00c000c4 	movi	r3,3
  1834a8:	28c00015 	stw	r3,0(r5)
  1834ac:	01900034 	movhi	r6,16384
  1834b0:	31bfffc4 	addi	r6,r6,-1
  1834b4:	30801036 	bltu	r6,r2,1834f8 <__unpack_f+0x88>
  1834b8:	00ffe044 	movi	r3,-127
  1834bc:	1085883a 	add	r2,r2,r2
  1834c0:	1809883a 	mov	r4,r3
  1834c4:	18ffffc4 	addi	r3,r3,-1
  1834c8:	30bffc2e 	bgeu	r6,r2,1834bc <__unpack_f+0x4c>
  1834cc:	29000215 	stw	r4,8(r5)
  1834d0:	28800315 	stw	r2,12(r5)
  1834d4:	f800283a 	ret
  1834d8:	01803fc4 	movi	r6,255
  1834dc:	21800b26 	beq	r4,r6,18350c <__unpack_f+0x9c>
  1834e0:	100491fa 	slli	r2,r2,7
  1834e4:	213fe044 	addi	r4,r4,-127
  1834e8:	00c000c4 	movi	r3,3
  1834ec:	10900034 	orhi	r2,r2,16384
  1834f0:	29000215 	stw	r4,8(r5)
  1834f4:	28c00015 	stw	r3,0(r5)
  1834f8:	28800315 	stw	r2,12(r5)
  1834fc:	f800283a 	ret
  183500:	00800084 	movi	r2,2
  183504:	28800015 	stw	r2,0(r5)
  183508:	f800283a 	ret
  18350c:	10000526 	beq	r2,zero,183524 <__unpack_f+0xb4>
  183510:	18c0042c 	andhi	r3,r3,16
  183514:	18000626 	beq	r3,zero,183530 <__unpack_f+0xc0>
  183518:	00c00044 	movi	r3,1
  18351c:	28c00015 	stw	r3,0(r5)
  183520:	003ff506 	br	1834f8 <__unpack_f+0x88>
  183524:	00800104 	movi	r2,4
  183528:	28800015 	stw	r2,0(r5)
  18352c:	f800283a 	ret
  183530:	28000015 	stw	zero,0(r5)
  183534:	003ff006 	br	1834f8 <__unpack_f+0x88>

00183538 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  183538:	defff904 	addi	sp,sp,-28
  18353c:	dfc00615 	stw	ra,24(sp)
  183540:	df000515 	stw	fp,20(sp)
  183544:	df000504 	addi	fp,sp,20
  183548:	e13ffc15 	stw	r4,-16(fp)
  18354c:	e17ffd15 	stw	r5,-12(fp)
  183550:	e1bffe15 	stw	r6,-8(fp)
  183554:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  183558:	e0800217 	ldw	r2,8(fp)
  18355c:	d8800015 	stw	r2,0(sp)
  183560:	e13ffc17 	ldw	r4,-16(fp)
  183564:	e17ffd17 	ldw	r5,-12(fp)
  183568:	e1bffe17 	ldw	r6,-8(fp)
  18356c:	e1ffff17 	ldw	r7,-4(fp)
  183570:	01837100 	call	183710 <alt_iic_isr_register>
}  
  183574:	e037883a 	mov	sp,fp
  183578:	dfc00117 	ldw	ra,4(sp)
  18357c:	df000017 	ldw	fp,0(sp)
  183580:	dec00204 	addi	sp,sp,8
  183584:	f800283a 	ret

00183588 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  183588:	defff904 	addi	sp,sp,-28
  18358c:	df000615 	stw	fp,24(sp)
  183590:	df000604 	addi	fp,sp,24
  183594:	e13ffe15 	stw	r4,-8(fp)
  183598:	e17fff15 	stw	r5,-4(fp)
  18359c:	e0bfff17 	ldw	r2,-4(fp)
  1835a0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1835a4:	0005303a 	rdctl	r2,status
  1835a8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1835ac:	e0fffb17 	ldw	r3,-20(fp)
  1835b0:	00bfff84 	movi	r2,-2
  1835b4:	1884703a 	and	r2,r3,r2
  1835b8:	1001703a 	wrctl	status,r2
  
  return context;
  1835bc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  1835c0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  1835c4:	e0bffa17 	ldw	r2,-24(fp)
  1835c8:	00c00044 	movi	r3,1
  1835cc:	1884983a 	sll	r2,r3,r2
  1835d0:	1007883a 	mov	r3,r2
  1835d4:	008008b4 	movhi	r2,34
  1835d8:	10862004 	addi	r2,r2,6272
  1835dc:	10800017 	ldw	r2,0(r2)
  1835e0:	1886b03a 	or	r3,r3,r2
  1835e4:	008008b4 	movhi	r2,34
  1835e8:	10862004 	addi	r2,r2,6272
  1835ec:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  1835f0:	008008b4 	movhi	r2,34
  1835f4:	10862004 	addi	r2,r2,6272
  1835f8:	10800017 	ldw	r2,0(r2)
  1835fc:	100170fa 	wrctl	ienable,r2
  183600:	e0bffc17 	ldw	r2,-16(fp)
  183604:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  183608:	e0bffd17 	ldw	r2,-12(fp)
  18360c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  183610:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
  183614:	e037883a 	mov	sp,fp
  183618:	df000017 	ldw	fp,0(sp)
  18361c:	dec00104 	addi	sp,sp,4
  183620:	f800283a 	ret

00183624 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  183624:	defff904 	addi	sp,sp,-28
  183628:	df000615 	stw	fp,24(sp)
  18362c:	df000604 	addi	fp,sp,24
  183630:	e13ffe15 	stw	r4,-8(fp)
  183634:	e17fff15 	stw	r5,-4(fp)
  183638:	e0bfff17 	ldw	r2,-4(fp)
  18363c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  183640:	0005303a 	rdctl	r2,status
  183644:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  183648:	e0fffb17 	ldw	r3,-20(fp)
  18364c:	00bfff84 	movi	r2,-2
  183650:	1884703a 	and	r2,r3,r2
  183654:	1001703a 	wrctl	status,r2
  
  return context;
  183658:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  18365c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  183660:	e0bffa17 	ldw	r2,-24(fp)
  183664:	00c00044 	movi	r3,1
  183668:	1884983a 	sll	r2,r3,r2
  18366c:	0084303a 	nor	r2,zero,r2
  183670:	1007883a 	mov	r3,r2
  183674:	008008b4 	movhi	r2,34
  183678:	10862004 	addi	r2,r2,6272
  18367c:	10800017 	ldw	r2,0(r2)
  183680:	1886703a 	and	r3,r3,r2
  183684:	008008b4 	movhi	r2,34
  183688:	10862004 	addi	r2,r2,6272
  18368c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  183690:	008008b4 	movhi	r2,34
  183694:	10862004 	addi	r2,r2,6272
  183698:	10800017 	ldw	r2,0(r2)
  18369c:	100170fa 	wrctl	ienable,r2
  1836a0:	e0bffc17 	ldw	r2,-16(fp)
  1836a4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1836a8:	e0bffd17 	ldw	r2,-12(fp)
  1836ac:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  1836b0:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
  1836b4:	e037883a 	mov	sp,fp
  1836b8:	df000017 	ldw	fp,0(sp)
  1836bc:	dec00104 	addi	sp,sp,4
  1836c0:	f800283a 	ret

001836c4 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  1836c4:	defffc04 	addi	sp,sp,-16
  1836c8:	df000315 	stw	fp,12(sp)
  1836cc:	df000304 	addi	fp,sp,12
  1836d0:	e13ffe15 	stw	r4,-8(fp)
  1836d4:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  1836d8:	000530fa 	rdctl	r2,ienable
  1836dc:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  1836e0:	e0bfff17 	ldw	r2,-4(fp)
  1836e4:	00c00044 	movi	r3,1
  1836e8:	1884983a 	sll	r2,r3,r2
  1836ec:	1007883a 	mov	r3,r2
  1836f0:	e0bffd17 	ldw	r2,-12(fp)
  1836f4:	1884703a 	and	r2,r3,r2
  1836f8:	1004c03a 	cmpne	r2,r2,zero
  1836fc:	10803fcc 	andi	r2,r2,255
}
  183700:	e037883a 	mov	sp,fp
  183704:	df000017 	ldw	fp,0(sp)
  183708:	dec00104 	addi	sp,sp,4
  18370c:	f800283a 	ret

00183710 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  183710:	defff504 	addi	sp,sp,-44
  183714:	dfc00a15 	stw	ra,40(sp)
  183718:	df000915 	stw	fp,36(sp)
  18371c:	df000904 	addi	fp,sp,36
  183720:	e13ffc15 	stw	r4,-16(fp)
  183724:	e17ffd15 	stw	r5,-12(fp)
  183728:	e1bffe15 	stw	r6,-8(fp)
  18372c:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  183730:	00bffa84 	movi	r2,-22
  183734:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  183738:	e0bffd17 	ldw	r2,-12(fp)
  18373c:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  183740:	e0bff817 	ldw	r2,-32(fp)
  183744:	10800808 	cmpgei	r2,r2,32
  183748:	1000271e 	bne	r2,zero,1837e8 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  18374c:	0005303a 	rdctl	r2,status
  183750:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  183754:	e0fffa17 	ldw	r3,-24(fp)
  183758:	00bfff84 	movi	r2,-2
  18375c:	1884703a 	and	r2,r3,r2
  183760:	1001703a 	wrctl	status,r2
  
  return context;
  183764:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  183768:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
  18376c:	00c008b4 	movhi	r3,34
  183770:	18c99404 	addi	r3,r3,9808
  183774:	e0bff817 	ldw	r2,-32(fp)
  183778:	100490fa 	slli	r2,r2,3
  18377c:	1885883a 	add	r2,r3,r2
  183780:	e0fffe17 	ldw	r3,-8(fp)
  183784:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  183788:	00c008b4 	movhi	r3,34
  18378c:	18c99404 	addi	r3,r3,9808
  183790:	e0bff817 	ldw	r2,-32(fp)
  183794:	100490fa 	slli	r2,r2,3
  183798:	1885883a 	add	r2,r3,r2
  18379c:	10800104 	addi	r2,r2,4
  1837a0:	e0ffff17 	ldw	r3,-4(fp)
  1837a4:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  1837a8:	e0bffe17 	ldw	r2,-8(fp)
  1837ac:	10000526 	beq	r2,zero,1837c4 <alt_iic_isr_register+0xb4>
  1837b0:	e0bff817 	ldw	r2,-32(fp)
  1837b4:	e13ffc17 	ldw	r4,-16(fp)
  1837b8:	100b883a 	mov	r5,r2
  1837bc:	01835880 	call	183588 <alt_ic_irq_enable>
  1837c0:	00000406 	br	1837d4 <alt_iic_isr_register+0xc4>
  1837c4:	e0bff817 	ldw	r2,-32(fp)
  1837c8:	e13ffc17 	ldw	r4,-16(fp)
  1837cc:	100b883a 	mov	r5,r2
  1837d0:	01836240 	call	183624 <alt_ic_irq_disable>
  1837d4:	e0bff715 	stw	r2,-36(fp)
  1837d8:	e0bff917 	ldw	r2,-28(fp)
  1837dc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1837e0:	e0bffb17 	ldw	r2,-20(fp)
  1837e4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  1837e8:	e0bff717 	ldw	r2,-36(fp)
}
  1837ec:	e037883a 	mov	sp,fp
  1837f0:	dfc00117 	ldw	ra,4(sp)
  1837f4:	df000017 	ldw	fp,0(sp)
  1837f8:	dec00204 	addi	sp,sp,8
  1837fc:	f800283a 	ret

00183800 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  183800:	defffc04 	addi	sp,sp,-16
  183804:	df000315 	stw	fp,12(sp)
  183808:	df000304 	addi	fp,sp,12
  18380c:	e13ffd15 	stw	r4,-12(fp)
  183810:	e17ffe15 	stw	r5,-8(fp)
  183814:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  183818:	e0fffe17 	ldw	r3,-8(fp)
  18381c:	e0bffd17 	ldw	r2,-12(fp)
  183820:	18800e26 	beq	r3,r2,18385c <alt_load_section+0x5c>
  {
    while( to != end )
  183824:	00000a06 	br	183850 <alt_load_section+0x50>
    {
      *to++ = *from++;
  183828:	e0bffd17 	ldw	r2,-12(fp)
  18382c:	10c00017 	ldw	r3,0(r2)
  183830:	e0bffe17 	ldw	r2,-8(fp)
  183834:	10c00015 	stw	r3,0(r2)
  183838:	e0bffe17 	ldw	r2,-8(fp)
  18383c:	10800104 	addi	r2,r2,4
  183840:	e0bffe15 	stw	r2,-8(fp)
  183844:	e0bffd17 	ldw	r2,-12(fp)
  183848:	10800104 	addi	r2,r2,4
  18384c:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  183850:	e0fffe17 	ldw	r3,-8(fp)
  183854:	e0bfff17 	ldw	r2,-4(fp)
  183858:	18bff31e 	bne	r3,r2,183828 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
  18385c:	e037883a 	mov	sp,fp
  183860:	df000017 	ldw	fp,0(sp)
  183864:	dec00104 	addi	sp,sp,4
  183868:	f800283a 	ret

0018386c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  18386c:	defffe04 	addi	sp,sp,-8
  183870:	dfc00115 	stw	ra,4(sp)
  183874:	df000015 	stw	fp,0(sp)
  183878:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  18387c:	01000634 	movhi	r4,24
  183880:	21181904 	addi	r4,r4,24676
  183884:	014008b4 	movhi	r5,34
  183888:	29400004 	addi	r5,r5,0
  18388c:	018008b4 	movhi	r6,34
  183890:	31861004 	addi	r6,r6,6208
  183894:	01838000 	call	183800 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  183898:	01000634 	movhi	r4,24
  18389c:	21000804 	addi	r4,r4,32
  1838a0:	01400634 	movhi	r5,24
  1838a4:	29400804 	addi	r5,r5,32
  1838a8:	01800634 	movhi	r6,24
  1838ac:	31806e04 	addi	r6,r6,440
  1838b0:	01838000 	call	183800 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  1838b4:	01000634 	movhi	r4,24
  1838b8:	2115c904 	addi	r4,r4,22308
  1838bc:	01400634 	movhi	r5,24
  1838c0:	2955c904 	addi	r5,r5,22308
  1838c4:	01800634 	movhi	r6,24
  1838c8:	31981904 	addi	r6,r6,24676
  1838cc:	01838000 	call	183800 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  1838d0:	01846d40 	call	1846d4 <alt_dcache_flush_all>
  alt_icache_flush_all();
  1838d4:	01848c40 	call	1848c4 <alt_icache_flush_all>
}
  1838d8:	e037883a 	mov	sp,fp
  1838dc:	dfc00117 	ldw	ra,4(sp)
  1838e0:	df000017 	ldw	fp,0(sp)
  1838e4:	dec00204 	addi	sp,sp,8
  1838e8:	f800283a 	ret

001838ec <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  1838ec:	defffd04 	addi	sp,sp,-12
  1838f0:	dfc00215 	stw	ra,8(sp)
  1838f4:	df000115 	stw	fp,4(sp)
  1838f8:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  1838fc:	0009883a 	mov	r4,zero
  183900:	018399c0 	call	18399c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  183904:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  183908:	01839d00 	call	1839d0 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  18390c:	01000634 	movhi	r4,24
  183910:	21180f04 	addi	r4,r4,24636
  183914:	01400634 	movhi	r5,24
  183918:	29580f04 	addi	r5,r5,24636
  18391c:	01800634 	movhi	r6,24
  183920:	31980f04 	addi	r6,r6,24636
  183924:	01849c00 	call	1849c0 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  183928:	018480c0 	call	18480c <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  18392c:	01000634 	movhi	r4,24
  183930:	21121a04 	addi	r4,r4,18536
  183934:	01851840 	call	185184 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  183938:	d1201e17 	ldw	r4,-32648(gp)
  18393c:	d0e01f17 	ldw	r3,-32644(gp)
  183940:	d0a02017 	ldw	r2,-32640(gp)
  183944:	180b883a 	mov	r5,r3
  183948:	100d883a 	mov	r6,r2
  18394c:	01807640 	call	180764 <main>
  183950:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  183954:	01000044 	movi	r4,1
  183958:	01846080 	call	184608 <close>
  exit (result);
  18395c:	e13fff17 	ldw	r4,-4(fp)
  183960:	01851980 	call	185198 <exit>

00183964 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  183964:	defffd04 	addi	sp,sp,-12
  183968:	dfc00215 	stw	ra,8(sp)
  18396c:	df000115 	stw	fp,4(sp)
  183970:	df000104 	addi	fp,sp,4
  183974:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  183978:	e13fff17 	ldw	r4,-4(fp)
  18397c:	014008b4 	movhi	r5,34
  183980:	29460804 	addi	r5,r5,6176
  183984:	018476c0 	call	18476c <alt_dev_llist_insert>
}
  183988:	e037883a 	mov	sp,fp
  18398c:	dfc00117 	ldw	ra,4(sp)
  183990:	df000017 	ldw	fp,0(sp)
  183994:	dec00204 	addi	sp,sp,8
  183998:	f800283a 	ret

0018399c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  18399c:	defffd04 	addi	sp,sp,-12
  1839a0:	dfc00215 	stw	ra,8(sp)
  1839a4:	df000115 	stw	fp,4(sp)
  1839a8:	df000104 	addi	fp,sp,4
  1839ac:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS, nios);
  1839b0:	0184eec0 	call	184eec <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  1839b4:	00800044 	movi	r2,1
  1839b8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  1839bc:	e037883a 	mov	sp,fp
  1839c0:	dfc00117 	ldw	ra,4(sp)
  1839c4:	df000017 	ldw	fp,0(sp)
  1839c8:	dec00204 	addi	sp,sp,8
  1839cc:	f800283a 	ret

001839d0 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  1839d0:	defffe04 	addi	sp,sp,-8
  1839d4:	dfc00115 	stw	ra,4(sp)
  1839d8:	df000015 	stw	fp,0(sp)
  1839dc:	d839883a 	mov	fp,sp
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG, jtag);
  1839e0:	010008b4 	movhi	r4,34
  1839e4:	21008b04 	addi	r4,r4,556
  1839e8:	000b883a 	mov	r5,zero
  1839ec:	000d883a 	mov	r6,zero
  1839f0:	0183b780 	call	183b78 <altera_avalon_jtag_uart_init>
  1839f4:	010008b4 	movhi	r4,34
  1839f8:	21008104 	addi	r4,r4,516
  1839fc:	01839640 	call	183964 <alt_dev_reg>
}
  183a00:	e037883a 	mov	sp,fp
  183a04:	dfc00117 	ldw	ra,4(sp)
  183a08:	df000017 	ldw	fp,0(sp)
  183a0c:	dec00204 	addi	sp,sp,8
  183a10:	f800283a 	ret

00183a14 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  183a14:	defffa04 	addi	sp,sp,-24
  183a18:	dfc00515 	stw	ra,20(sp)
  183a1c:	df000415 	stw	fp,16(sp)
  183a20:	df000404 	addi	fp,sp,16
  183a24:	e13ffd15 	stw	r4,-12(fp)
  183a28:	e17ffe15 	stw	r5,-8(fp)
  183a2c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  183a30:	e0bffd17 	ldw	r2,-12(fp)
  183a34:	10800017 	ldw	r2,0(r2)
  183a38:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  183a3c:	e0bffc17 	ldw	r2,-16(fp)
  183a40:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
  183a44:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  183a48:	10800217 	ldw	r2,8(r2)
  183a4c:	1809883a 	mov	r4,r3
  183a50:	e17ffe17 	ldw	r5,-8(fp)
  183a54:	e1bfff17 	ldw	r6,-4(fp)
  183a58:	100f883a 	mov	r7,r2
  183a5c:	018403c0 	call	18403c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  183a60:	e037883a 	mov	sp,fp
  183a64:	dfc00117 	ldw	ra,4(sp)
  183a68:	df000017 	ldw	fp,0(sp)
  183a6c:	dec00204 	addi	sp,sp,8
  183a70:	f800283a 	ret

00183a74 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  183a74:	defffa04 	addi	sp,sp,-24
  183a78:	dfc00515 	stw	ra,20(sp)
  183a7c:	df000415 	stw	fp,16(sp)
  183a80:	df000404 	addi	fp,sp,16
  183a84:	e13ffd15 	stw	r4,-12(fp)
  183a88:	e17ffe15 	stw	r5,-8(fp)
  183a8c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  183a90:	e0bffd17 	ldw	r2,-12(fp)
  183a94:	10800017 	ldw	r2,0(r2)
  183a98:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  183a9c:	e0bffc17 	ldw	r2,-16(fp)
  183aa0:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
  183aa4:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  183aa8:	10800217 	ldw	r2,8(r2)
  183aac:	1809883a 	mov	r4,r3
  183ab0:	e17ffe17 	ldw	r5,-8(fp)
  183ab4:	e1bfff17 	ldw	r6,-4(fp)
  183ab8:	100f883a 	mov	r7,r2
  183abc:	01842540 	call	184254 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  183ac0:	e037883a 	mov	sp,fp
  183ac4:	dfc00117 	ldw	ra,4(sp)
  183ac8:	df000017 	ldw	fp,0(sp)
  183acc:	dec00204 	addi	sp,sp,8
  183ad0:	f800283a 	ret

00183ad4 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  183ad4:	defffc04 	addi	sp,sp,-16
  183ad8:	dfc00315 	stw	ra,12(sp)
  183adc:	df000215 	stw	fp,8(sp)
  183ae0:	df000204 	addi	fp,sp,8
  183ae4:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  183ae8:	e0bfff17 	ldw	r2,-4(fp)
  183aec:	10800017 	ldw	r2,0(r2)
  183af0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  183af4:	e0bffe17 	ldw	r2,-8(fp)
  183af8:	10c00a04 	addi	r3,r2,40
  183afc:	e0bfff17 	ldw	r2,-4(fp)
  183b00:	10800217 	ldw	r2,8(r2)
  183b04:	1809883a 	mov	r4,r3
  183b08:	100b883a 	mov	r5,r2
  183b0c:	0183ee00 	call	183ee0 <altera_avalon_jtag_uart_close>
}
  183b10:	e037883a 	mov	sp,fp
  183b14:	dfc00117 	ldw	ra,4(sp)
  183b18:	df000017 	ldw	fp,0(sp)
  183b1c:	dec00204 	addi	sp,sp,8
  183b20:	f800283a 	ret

00183b24 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  183b24:	defffa04 	addi	sp,sp,-24
  183b28:	dfc00515 	stw	ra,20(sp)
  183b2c:	df000415 	stw	fp,16(sp)
  183b30:	df000404 	addi	fp,sp,16
  183b34:	e13ffd15 	stw	r4,-12(fp)
  183b38:	e17ffe15 	stw	r5,-8(fp)
  183b3c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  183b40:	e0bffd17 	ldw	r2,-12(fp)
  183b44:	10800017 	ldw	r2,0(r2)
  183b48:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  183b4c:	e0bffc17 	ldw	r2,-16(fp)
  183b50:	10800a04 	addi	r2,r2,40
  183b54:	1009883a 	mov	r4,r2
  183b58:	e17ffe17 	ldw	r5,-8(fp)
  183b5c:	e1bfff17 	ldw	r6,-4(fp)
  183b60:	0183f480 	call	183f48 <altera_avalon_jtag_uart_ioctl>
}
  183b64:	e037883a 	mov	sp,fp
  183b68:	dfc00117 	ldw	ra,4(sp)
  183b6c:	df000017 	ldw	fp,0(sp)
  183b70:	dec00204 	addi	sp,sp,8
  183b74:	f800283a 	ret

00183b78 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  183b78:	defffa04 	addi	sp,sp,-24
  183b7c:	dfc00515 	stw	ra,20(sp)
  183b80:	df000415 	stw	fp,16(sp)
  183b84:	df000404 	addi	fp,sp,16
  183b88:	e13ffd15 	stw	r4,-12(fp)
  183b8c:	e17ffe15 	stw	r5,-8(fp)
  183b90:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  183b94:	e0bffd17 	ldw	r2,-12(fp)
  183b98:	00c00044 	movi	r3,1
  183b9c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  183ba0:	e0bffd17 	ldw	r2,-12(fp)
  183ba4:	10800017 	ldw	r2,0(r2)
  183ba8:	10800104 	addi	r2,r2,4
  183bac:	e0fffd17 	ldw	r3,-12(fp)
  183bb0:	18c00817 	ldw	r3,32(r3)
  183bb4:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
  183bb8:	e0fffe17 	ldw	r3,-8(fp)
  183bbc:	e0bfff17 	ldw	r2,-4(fp)
  183bc0:	d8000015 	stw	zero,0(sp)
  183bc4:	1809883a 	mov	r4,r3
  183bc8:	100b883a 	mov	r5,r2
  183bcc:	01800634 	movhi	r6,24
  183bd0:	318f0e04 	addi	r6,r6,15416
  183bd4:	e1fffd17 	ldw	r7,-12(fp)
  183bd8:	01835380 	call	183538 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  183bdc:	e0bffd17 	ldw	r2,-12(fp)
  183be0:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  183be4:	e0bffd17 	ldw	r2,-12(fp)
  183be8:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  183bec:	008008b4 	movhi	r2,34
  183bf0:	10862404 	addi	r2,r2,6288
  183bf4:	10800017 	ldw	r2,0(r2)
  183bf8:	1809883a 	mov	r4,r3
  183bfc:	100b883a 	mov	r5,r2
  183c00:	01800634 	movhi	r6,24
  183c04:	318f8f04 	addi	r6,r6,15932
  183c08:	e1fffd17 	ldw	r7,-12(fp)
  183c0c:	01844780 	call	184478 <alt_alarm_start>
  183c10:	1000040e 	bge	r2,zero,183c24 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  183c14:	e0bffd17 	ldw	r2,-12(fp)
  183c18:	00e00034 	movhi	r3,32768
  183c1c:	18ffffc4 	addi	r3,r3,-1
  183c20:	10c00115 	stw	r3,4(r2)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  183c24:	e037883a 	mov	sp,fp
  183c28:	dfc00117 	ldw	ra,4(sp)
  183c2c:	df000017 	ldw	fp,0(sp)
  183c30:	dec00204 	addi	sp,sp,8
  183c34:	f800283a 	ret

00183c38 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  183c38:	defff804 	addi	sp,sp,-32
  183c3c:	df000715 	stw	fp,28(sp)
  183c40:	df000704 	addi	fp,sp,28
  183c44:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  183c48:	e0bfff17 	ldw	r2,-4(fp)
  183c4c:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
  183c50:	e0bffb17 	ldw	r2,-20(fp)
  183c54:	10800017 	ldw	r2,0(r2)
  183c58:	e0bffc15 	stw	r2,-16(fp)
  183c5c:	00000106 	br	183c64 <altera_avalon_jtag_uart_irq+0x2c>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
  183c60:	0001883a 	nop
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  183c64:	e0bffc17 	ldw	r2,-16(fp)
  183c68:	10800104 	addi	r2,r2,4
  183c6c:	10800037 	ldwio	r2,0(r2)
  183c70:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  183c74:	e0bffd17 	ldw	r2,-12(fp)
  183c78:	1080c00c 	andi	r2,r2,768
  183c7c:	10006a26 	beq	r2,zero,183e28 <altera_avalon_jtag_uart_irq+0x1f0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  183c80:	e0bffd17 	ldw	r2,-12(fp)
  183c84:	1080400c 	andi	r2,r2,256
  183c88:	10003326 	beq	r2,zero,183d58 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  183c8c:	00800074 	movhi	r2,1
  183c90:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  183c94:	e0bffb17 	ldw	r2,-20(fp)
  183c98:	10800a17 	ldw	r2,40(r2)
  183c9c:	10800044 	addi	r2,r2,1
  183ca0:	1081ffcc 	andi	r2,r2,2047
  183ca4:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
  183ca8:	e0bffb17 	ldw	r2,-20(fp)
  183cac:	10c00b17 	ldw	r3,44(r2)
  183cb0:	e0bffe17 	ldw	r2,-8(fp)
  183cb4:	18801426 	beq	r3,r2,183d08 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  183cb8:	e0bffc17 	ldw	r2,-16(fp)
  183cbc:	10800037 	ldwio	r2,0(r2)
  183cc0:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  183cc4:	e0bff917 	ldw	r2,-28(fp)
  183cc8:	10a0000c 	andi	r2,r2,32768
  183ccc:	10001026 	beq	r2,zero,183d10 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  183cd0:	e0bffb17 	ldw	r2,-20(fp)
  183cd4:	10800a17 	ldw	r2,40(r2)
  183cd8:	e0fff917 	ldw	r3,-28(fp)
  183cdc:	e13ffb17 	ldw	r4,-20(fp)
  183ce0:	2085883a 	add	r2,r4,r2
  183ce4:	10800e04 	addi	r2,r2,56
  183ce8:	10c00005 	stb	r3,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  183cec:	e0bffb17 	ldw	r2,-20(fp)
  183cf0:	10800a17 	ldw	r2,40(r2)
  183cf4:	10800044 	addi	r2,r2,1
  183cf8:	10c1ffcc 	andi	r3,r2,2047
  183cfc:	e0bffb17 	ldw	r2,-20(fp)
  183d00:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
  183d04:	003fe306 	br	183c94 <altera_avalon_jtag_uart_irq+0x5c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
  183d08:	0001883a 	nop
  183d0c:	00000106 	br	183d14 <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
  183d10:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  183d14:	e0bff917 	ldw	r2,-28(fp)
  183d18:	10bfffec 	andhi	r2,r2,65535
  183d1c:	10000e26 	beq	r2,zero,183d58 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  183d20:	e0bffb17 	ldw	r2,-20(fp)
  183d24:	10c00817 	ldw	r3,32(r2)
  183d28:	00bfff84 	movi	r2,-2
  183d2c:	1886703a 	and	r3,r3,r2
  183d30:	e0bffb17 	ldw	r2,-20(fp)
  183d34:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  183d38:	e0bffc17 	ldw	r2,-16(fp)
  183d3c:	10800104 	addi	r2,r2,4
  183d40:	e0fffb17 	ldw	r3,-20(fp)
  183d44:	18c00817 	ldw	r3,32(r3)
  183d48:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  183d4c:	e0bffc17 	ldw	r2,-16(fp)
  183d50:	10800104 	addi	r2,r2,4
  183d54:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  183d58:	e0bffd17 	ldw	r2,-12(fp)
  183d5c:	1080800c 	andi	r2,r2,512
  183d60:	103fbf26 	beq	r2,zero,183c60 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  183d64:	e0bffd17 	ldw	r2,-12(fp)
  183d68:	1004d43a 	srli	r2,r2,16
  183d6c:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  183d70:	00001406 	br	183dc4 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  183d74:	e0bffc17 	ldw	r2,-16(fp)
  183d78:	e0fffb17 	ldw	r3,-20(fp)
  183d7c:	18c00d17 	ldw	r3,52(r3)
  183d80:	e13ffb17 	ldw	r4,-20(fp)
  183d84:	20c7883a 	add	r3,r4,r3
  183d88:	18c20e04 	addi	r3,r3,2104
  183d8c:	18c00003 	ldbu	r3,0(r3)
  183d90:	18c03fcc 	andi	r3,r3,255
  183d94:	18c0201c 	xori	r3,r3,128
  183d98:	18ffe004 	addi	r3,r3,-128
  183d9c:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  183da0:	e0bffb17 	ldw	r2,-20(fp)
  183da4:	10800d17 	ldw	r2,52(r2)
  183da8:	10800044 	addi	r2,r2,1
  183dac:	10c1ffcc 	andi	r3,r2,2047
  183db0:	e0bffb17 	ldw	r2,-20(fp)
  183db4:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
  183db8:	e0bffa17 	ldw	r2,-24(fp)
  183dbc:	10bfffc4 	addi	r2,r2,-1
  183dc0:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
  183dc4:	e0bffa17 	ldw	r2,-24(fp)
  183dc8:	10000526 	beq	r2,zero,183de0 <altera_avalon_jtag_uart_irq+0x1a8>
  183dcc:	e0bffb17 	ldw	r2,-20(fp)
  183dd0:	10c00d17 	ldw	r3,52(r2)
  183dd4:	e0bffb17 	ldw	r2,-20(fp)
  183dd8:	10800c17 	ldw	r2,48(r2)
  183ddc:	18bfe51e 	bne	r3,r2,183d74 <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
  183de0:	e0bffa17 	ldw	r2,-24(fp)
  183de4:	103f9e26 	beq	r2,zero,183c60 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  183de8:	e0bffb17 	ldw	r2,-20(fp)
  183dec:	10c00817 	ldw	r3,32(r2)
  183df0:	00bfff44 	movi	r2,-3
  183df4:	1886703a 	and	r3,r3,r2
  183df8:	e0bffb17 	ldw	r2,-20(fp)
  183dfc:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  183e00:	e0bffb17 	ldw	r2,-20(fp)
  183e04:	10800017 	ldw	r2,0(r2)
  183e08:	10800104 	addi	r2,r2,4
  183e0c:	e0fffb17 	ldw	r3,-20(fp)
  183e10:	18c00817 	ldw	r3,32(r3)
  183e14:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  183e18:	e0bffc17 	ldw	r2,-16(fp)
  183e1c:	10800104 	addi	r2,r2,4
  183e20:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
  183e24:	003f8e06 	br	183c60 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
  183e28:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
  183e2c:	e037883a 	mov	sp,fp
  183e30:	df000017 	ldw	fp,0(sp)
  183e34:	dec00104 	addi	sp,sp,4
  183e38:	f800283a 	ret

00183e3c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  183e3c:	defffc04 	addi	sp,sp,-16
  183e40:	df000315 	stw	fp,12(sp)
  183e44:	df000304 	addi	fp,sp,12
  183e48:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  183e4c:	e0bfff17 	ldw	r2,-4(fp)
  183e50:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  183e54:	e0bffd17 	ldw	r2,-12(fp)
  183e58:	10800017 	ldw	r2,0(r2)
  183e5c:	10800104 	addi	r2,r2,4
  183e60:	10800037 	ldwio	r2,0(r2)
  183e64:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  183e68:	e0bffe17 	ldw	r2,-8(fp)
  183e6c:	1081000c 	andi	r2,r2,1024
  183e70:	10000a26 	beq	r2,zero,183e9c <altera_avalon_jtag_uart_timeout+0x60>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  183e74:	e0bffd17 	ldw	r2,-12(fp)
  183e78:	10800017 	ldw	r2,0(r2)
  183e7c:	10800104 	addi	r2,r2,4
  183e80:	e0fffd17 	ldw	r3,-12(fp)
  183e84:	18c00817 	ldw	r3,32(r3)
  183e88:	18c10014 	ori	r3,r3,1024
  183e8c:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
  183e90:	e0bffd17 	ldw	r2,-12(fp)
  183e94:	10000915 	stw	zero,36(r2)
  183e98:	00000a06 	br	183ec4 <altera_avalon_jtag_uart_timeout+0x88>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  183e9c:	e0bffd17 	ldw	r2,-12(fp)
  183ea0:	10800917 	ldw	r2,36(r2)
  183ea4:	00e00034 	movhi	r3,32768
  183ea8:	18ffff04 	addi	r3,r3,-4
  183eac:	18800536 	bltu	r3,r2,183ec4 <altera_avalon_jtag_uart_timeout+0x88>
    sp->host_inactive++;
  183eb0:	e0bffd17 	ldw	r2,-12(fp)
  183eb4:	10800917 	ldw	r2,36(r2)
  183eb8:	10c00044 	addi	r3,r2,1
  183ebc:	e0bffd17 	ldw	r2,-12(fp)
  183ec0:	10c00915 	stw	r3,36(r2)
  183ec4:	008008b4 	movhi	r2,34
  183ec8:	10862404 	addi	r2,r2,6288
  183ecc:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  183ed0:	e037883a 	mov	sp,fp
  183ed4:	df000017 	ldw	fp,0(sp)
  183ed8:	dec00104 	addi	sp,sp,4
  183edc:	f800283a 	ret

00183ee0 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  183ee0:	defffd04 	addi	sp,sp,-12
  183ee4:	df000215 	stw	fp,8(sp)
  183ee8:	df000204 	addi	fp,sp,8
  183eec:	e13ffe15 	stw	r4,-8(fp)
  183ef0:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  183ef4:	00000506 	br	183f0c <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  183ef8:	e0bfff17 	ldw	r2,-4(fp)
  183efc:	1090000c 	andi	r2,r2,16384
  183f00:	10000226 	beq	r2,zero,183f0c <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  183f04:	00bffd44 	movi	r2,-11
  183f08:	00000b06 	br	183f38 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  183f0c:	e0bffe17 	ldw	r2,-8(fp)
  183f10:	10c00d17 	ldw	r3,52(r2)
  183f14:	e0bffe17 	ldw	r2,-8(fp)
  183f18:	10800c17 	ldw	r2,48(r2)
  183f1c:	18800526 	beq	r3,r2,183f34 <altera_avalon_jtag_uart_close+0x54>
  183f20:	e0bffe17 	ldw	r2,-8(fp)
  183f24:	10c00917 	ldw	r3,36(r2)
  183f28:	e0bffe17 	ldw	r2,-8(fp)
  183f2c:	10800117 	ldw	r2,4(r2)
  183f30:	18bff136 	bltu	r3,r2,183ef8 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  183f34:	0005883a 	mov	r2,zero
}
  183f38:	e037883a 	mov	sp,fp
  183f3c:	df000017 	ldw	fp,0(sp)
  183f40:	dec00104 	addi	sp,sp,4
  183f44:	f800283a 	ret

00183f48 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  183f48:	defffa04 	addi	sp,sp,-24
  183f4c:	df000515 	stw	fp,20(sp)
  183f50:	df000504 	addi	fp,sp,20
  183f54:	e13ffd15 	stw	r4,-12(fp)
  183f58:	e17ffe15 	stw	r5,-8(fp)
  183f5c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
  183f60:	00bff9c4 	movi	r2,-25
  183f64:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
  183f68:	e0bffe17 	ldw	r2,-8(fp)
  183f6c:	10da8060 	cmpeqi	r3,r2,27137
  183f70:	1800031e 	bne	r3,zero,183f80 <altera_avalon_jtag_uart_ioctl+0x38>
  183f74:	109a80a0 	cmpeqi	r2,r2,27138
  183f78:	1000181e 	bne	r2,zero,183fdc <altera_avalon_jtag_uart_ioctl+0x94>
  183f7c:	00002606 	br	184018 <altera_avalon_jtag_uart_ioctl+0xd0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
  183f80:	e0bffd17 	ldw	r2,-12(fp)
  183f84:	10c00117 	ldw	r3,4(r2)
  183f88:	00a00034 	movhi	r2,32768
  183f8c:	10bfffc4 	addi	r2,r2,-1
  183f90:	18802226 	beq	r3,r2,18401c <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      int timeout = *((int *)arg);
  183f94:	e0bfff17 	ldw	r2,-4(fp)
  183f98:	10800017 	ldw	r2,0(r2)
  183f9c:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  183fa0:	e0bffc17 	ldw	r2,-16(fp)
  183fa4:	10800090 	cmplti	r2,r2,2
  183fa8:	1000061e 	bne	r2,zero,183fc4 <altera_avalon_jtag_uart_ioctl+0x7c>
  183fac:	e0fffc17 	ldw	r3,-16(fp)
  183fb0:	00a00034 	movhi	r2,32768
  183fb4:	10bfffc4 	addi	r2,r2,-1
  183fb8:	18800226 	beq	r3,r2,183fc4 <altera_avalon_jtag_uart_ioctl+0x7c>
  183fbc:	e0bffc17 	ldw	r2,-16(fp)
  183fc0:	00000206 	br	183fcc <altera_avalon_jtag_uart_ioctl+0x84>
  183fc4:	00a00034 	movhi	r2,32768
  183fc8:	10bfff84 	addi	r2,r2,-2
  183fcc:	e0fffd17 	ldw	r3,-12(fp)
  183fd0:	18800115 	stw	r2,4(r3)
      rc = 0;
  183fd4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  183fd8:	00001006 	br	18401c <altera_avalon_jtag_uart_ioctl+0xd4>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
  183fdc:	e0bffd17 	ldw	r2,-12(fp)
  183fe0:	10c00117 	ldw	r3,4(r2)
  183fe4:	00a00034 	movhi	r2,32768
  183fe8:	10bfffc4 	addi	r2,r2,-1
  183fec:	18800d26 	beq	r3,r2,184024 <altera_avalon_jtag_uart_ioctl+0xdc>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  183ff0:	e0bffd17 	ldw	r2,-12(fp)
  183ff4:	10c00917 	ldw	r3,36(r2)
  183ff8:	e0bffd17 	ldw	r2,-12(fp)
  183ffc:	10800117 	ldw	r2,4(r2)
  184000:	1885803a 	cmpltu	r2,r3,r2
  184004:	10c03fcc 	andi	r3,r2,255
  184008:	e0bfff17 	ldw	r2,-4(fp)
  18400c:	10c00015 	stw	r3,0(r2)
      rc = 0;
  184010:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  184014:	00000306 	br	184024 <altera_avalon_jtag_uart_ioctl+0xdc>

  default:
    break;
  184018:	00000306 	br	184028 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
  18401c:	0001883a 	nop
  184020:	00000106 	br	184028 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
  184024:	0001883a 	nop

  default:
    break;
  }

  return rc;
  184028:	e0bffb17 	ldw	r2,-20(fp)
}
  18402c:	e037883a 	mov	sp,fp
  184030:	df000017 	ldw	fp,0(sp)
  184034:	dec00104 	addi	sp,sp,4
  184038:	f800283a 	ret

0018403c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  18403c:	defff304 	addi	sp,sp,-52
  184040:	dfc00c15 	stw	ra,48(sp)
  184044:	df000b15 	stw	fp,44(sp)
  184048:	df000b04 	addi	fp,sp,44
  18404c:	e13ffc15 	stw	r4,-16(fp)
  184050:	e17ffd15 	stw	r5,-12(fp)
  184054:	e1bffe15 	stw	r6,-8(fp)
  184058:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
  18405c:	e0bffd17 	ldw	r2,-12(fp)
  184060:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  184064:	00004706 	br	184184 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  184068:	e0bffc17 	ldw	r2,-16(fp)
  18406c:	10800a17 	ldw	r2,40(r2)
  184070:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
  184074:	e0bffc17 	ldw	r2,-16(fp)
  184078:	10800b17 	ldw	r2,44(r2)
  18407c:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
  184080:	e0fff717 	ldw	r3,-36(fp)
  184084:	e0bff817 	ldw	r2,-32(fp)
  184088:	18800536 	bltu	r3,r2,1840a0 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  18408c:	e0fff717 	ldw	r3,-36(fp)
  184090:	e0bff817 	ldw	r2,-32(fp)
  184094:	1885c83a 	sub	r2,r3,r2
  184098:	e0bff615 	stw	r2,-40(fp)
  18409c:	00000406 	br	1840b0 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  1840a0:	00c20004 	movi	r3,2048
  1840a4:	e0bff817 	ldw	r2,-32(fp)
  1840a8:	1885c83a 	sub	r2,r3,r2
  1840ac:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  1840b0:	e0bff617 	ldw	r2,-40(fp)
  1840b4:	10001e26 	beq	r2,zero,184130 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
  1840b8:	e0fffe17 	ldw	r3,-8(fp)
  1840bc:	e0bff617 	ldw	r2,-40(fp)
  1840c0:	1880022e 	bgeu	r3,r2,1840cc <altera_avalon_jtag_uart_read+0x90>
        n = space;
  1840c4:	e0bffe17 	ldw	r2,-8(fp)
  1840c8:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  1840cc:	e0bff817 	ldw	r2,-32(fp)
  1840d0:	10800e04 	addi	r2,r2,56
  1840d4:	e0fffc17 	ldw	r3,-16(fp)
  1840d8:	1885883a 	add	r2,r3,r2
  1840dc:	e13ff517 	ldw	r4,-44(fp)
  1840e0:	100b883a 	mov	r5,r2
  1840e4:	e1bff617 	ldw	r6,-40(fp)
  1840e8:	018524c0 	call	18524c <memcpy>
      ptr   += n;
  1840ec:	e0fff517 	ldw	r3,-44(fp)
  1840f0:	e0bff617 	ldw	r2,-40(fp)
  1840f4:	1885883a 	add	r2,r3,r2
  1840f8:	e0bff515 	stw	r2,-44(fp)
      space -= n;
  1840fc:	e0fffe17 	ldw	r3,-8(fp)
  184100:	e0bff617 	ldw	r2,-40(fp)
  184104:	1885c83a 	sub	r2,r3,r2
  184108:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  18410c:	e0fff817 	ldw	r3,-32(fp)
  184110:	e0bff617 	ldw	r2,-40(fp)
  184114:	1885883a 	add	r2,r3,r2
  184118:	10c1ffcc 	andi	r3,r2,2047
  18411c:	e0bffc17 	ldw	r2,-16(fp)
  184120:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  184124:	e0bffe17 	ldw	r2,-8(fp)
  184128:	00bfcf16 	blt	zero,r2,184068 <altera_avalon_jtag_uart_read+0x2c>
  18412c:	00000106 	br	184134 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
  184130:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
  184134:	e0fff517 	ldw	r3,-44(fp)
  184138:	e0bffd17 	ldw	r2,-12(fp)
  18413c:	1880141e 	bne	r3,r2,184190 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  184140:	e0bfff17 	ldw	r2,-4(fp)
  184144:	1090000c 	andi	r2,r2,16384
  184148:	1000131e 	bne	r2,zero,184198 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  18414c:	0001883a 	nop
  184150:	e0bffc17 	ldw	r2,-16(fp)
  184154:	10c00a17 	ldw	r3,40(r2)
  184158:	e0bff717 	ldw	r2,-36(fp)
  18415c:	1880051e 	bne	r3,r2,184174 <altera_avalon_jtag_uart_read+0x138>
  184160:	e0bffc17 	ldw	r2,-16(fp)
  184164:	10c00917 	ldw	r3,36(r2)
  184168:	e0bffc17 	ldw	r2,-16(fp)
  18416c:	10800117 	ldw	r2,4(r2)
  184170:	18bff736 	bltu	r3,r2,184150 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  184174:	e0bffc17 	ldw	r2,-16(fp)
  184178:	10c00a17 	ldw	r3,40(r2)
  18417c:	e0bff717 	ldw	r2,-36(fp)
  184180:	18800726 	beq	r3,r2,1841a0 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  184184:	e0bffe17 	ldw	r2,-8(fp)
  184188:	00bfb716 	blt	zero,r2,184068 <altera_avalon_jtag_uart_read+0x2c>
  18418c:	00000506 	br	1841a4 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
  184190:	0001883a 	nop
  184194:	00000306 	br	1841a4 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
  184198:	0001883a 	nop
  18419c:	00000106 	br	1841a4 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
  1841a0:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  1841a4:	e0fff517 	ldw	r3,-44(fp)
  1841a8:	e0bffd17 	ldw	r2,-12(fp)
  1841ac:	18801726 	beq	r3,r2,18420c <altera_avalon_jtag_uart_read+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1841b0:	0005303a 	rdctl	r2,status
  1841b4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1841b8:	e0fffa17 	ldw	r3,-24(fp)
  1841bc:	00bfff84 	movi	r2,-2
  1841c0:	1884703a 	and	r2,r3,r2
  1841c4:	1001703a 	wrctl	status,r2
  
  return context;
  1841c8:	e0bffa17 	ldw	r2,-24(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  1841cc:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  1841d0:	e0bffc17 	ldw	r2,-16(fp)
  1841d4:	10800817 	ldw	r2,32(r2)
  1841d8:	10c00054 	ori	r3,r2,1
  1841dc:	e0bffc17 	ldw	r2,-16(fp)
  1841e0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  1841e4:	e0bffc17 	ldw	r2,-16(fp)
  1841e8:	10800017 	ldw	r2,0(r2)
  1841ec:	10800104 	addi	r2,r2,4
  1841f0:	e0fffc17 	ldw	r3,-16(fp)
  1841f4:	18c00817 	ldw	r3,32(r3)
  1841f8:	10c00035 	stwio	r3,0(r2)
  1841fc:	e0bff917 	ldw	r2,-28(fp)
  184200:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  184204:	e0bffb17 	ldw	r2,-20(fp)
  184208:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  18420c:	e0fff517 	ldw	r3,-44(fp)
  184210:	e0bffd17 	ldw	r2,-12(fp)
  184214:	18800426 	beq	r3,r2,184228 <altera_avalon_jtag_uart_read+0x1ec>
    return ptr - buffer;
  184218:	e0fff517 	ldw	r3,-44(fp)
  18421c:	e0bffd17 	ldw	r2,-12(fp)
  184220:	1885c83a 	sub	r2,r3,r2
  184224:	00000606 	br	184240 <altera_avalon_jtag_uart_read+0x204>
  else if (flags & O_NONBLOCK)
  184228:	e0bfff17 	ldw	r2,-4(fp)
  18422c:	1090000c 	andi	r2,r2,16384
  184230:	10000226 	beq	r2,zero,18423c <altera_avalon_jtag_uart_read+0x200>
    return -EWOULDBLOCK;
  184234:	00bffd44 	movi	r2,-11
  184238:	00000106 	br	184240 <altera_avalon_jtag_uart_read+0x204>
  else
    return -EIO;
  18423c:	00bffec4 	movi	r2,-5
}
  184240:	e037883a 	mov	sp,fp
  184244:	dfc00117 	ldw	ra,4(sp)
  184248:	df000017 	ldw	fp,0(sp)
  18424c:	dec00204 	addi	sp,sp,8
  184250:	f800283a 	ret

00184254 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  184254:	defff304 	addi	sp,sp,-52
  184258:	dfc00c15 	stw	ra,48(sp)
  18425c:	df000b15 	stw	fp,44(sp)
  184260:	df000b04 	addi	fp,sp,44
  184264:	e13ffc15 	stw	r4,-16(fp)
  184268:	e17ffd15 	stw	r5,-12(fp)
  18426c:	e1bffe15 	stw	r6,-8(fp)
  184270:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  184274:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  184278:	e0bffd17 	ldw	r2,-12(fp)
  18427c:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  184280:	00003706 	br	184360 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  184284:	e0bffc17 	ldw	r2,-16(fp)
  184288:	10800c17 	ldw	r2,48(r2)
  18428c:	e0bff815 	stw	r2,-32(fp)
      out = sp->tx_out;
  184290:	e0bffc17 	ldw	r2,-16(fp)
  184294:	10800d17 	ldw	r2,52(r2)
  184298:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
  18429c:	e0fff817 	ldw	r3,-32(fp)
  1842a0:	e0bff517 	ldw	r2,-44(fp)
  1842a4:	1880062e 	bgeu	r3,r2,1842c0 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  1842a8:	e0fff517 	ldw	r3,-44(fp)
  1842ac:	e0bff817 	ldw	r2,-32(fp)
  1842b0:	1885c83a 	sub	r2,r3,r2
  1842b4:	10bfffc4 	addi	r2,r2,-1
  1842b8:	e0bff615 	stw	r2,-40(fp)
  1842bc:	00000b06 	br	1842ec <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
  1842c0:	e0bff517 	ldw	r2,-44(fp)
  1842c4:	10000526 	beq	r2,zero,1842dc <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  1842c8:	00c20004 	movi	r3,2048
  1842cc:	e0bff817 	ldw	r2,-32(fp)
  1842d0:	1885c83a 	sub	r2,r3,r2
  1842d4:	e0bff615 	stw	r2,-40(fp)
  1842d8:	00000406 	br	1842ec <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  1842dc:	00c1ffc4 	movi	r3,2047
  1842e0:	e0bff817 	ldw	r2,-32(fp)
  1842e4:	1885c83a 	sub	r2,r3,r2
  1842e8:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  1842ec:	e0bff617 	ldw	r2,-40(fp)
  1842f0:	10001e26 	beq	r2,zero,18436c <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
  1842f4:	e0fffe17 	ldw	r3,-8(fp)
  1842f8:	e0bff617 	ldw	r2,-40(fp)
  1842fc:	1880022e 	bgeu	r3,r2,184308 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
  184300:	e0bffe17 	ldw	r2,-8(fp)
  184304:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  184308:	e0bff817 	ldw	r2,-32(fp)
  18430c:	10820e04 	addi	r2,r2,2104
  184310:	e0fffc17 	ldw	r3,-16(fp)
  184314:	1885883a 	add	r2,r3,r2
  184318:	1009883a 	mov	r4,r2
  18431c:	e17ffd17 	ldw	r5,-12(fp)
  184320:	e1bff617 	ldw	r6,-40(fp)
  184324:	018524c0 	call	18524c <memcpy>
      ptr   += n;
  184328:	e0fffd17 	ldw	r3,-12(fp)
  18432c:	e0bff617 	ldw	r2,-40(fp)
  184330:	1885883a 	add	r2,r3,r2
  184334:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
  184338:	e0fffe17 	ldw	r3,-8(fp)
  18433c:	e0bff617 	ldw	r2,-40(fp)
  184340:	1885c83a 	sub	r2,r3,r2
  184344:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  184348:	e0fff817 	ldw	r3,-32(fp)
  18434c:	e0bff617 	ldw	r2,-40(fp)
  184350:	1885883a 	add	r2,r3,r2
  184354:	10c1ffcc 	andi	r3,r2,2047
  184358:	e0bffc17 	ldw	r2,-16(fp)
  18435c:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  184360:	e0bffe17 	ldw	r2,-8(fp)
  184364:	00bfc716 	blt	zero,r2,184284 <altera_avalon_jtag_uart_write+0x30>
  184368:	00000106 	br	184370 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
  18436c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  184370:	0005303a 	rdctl	r2,status
  184374:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  184378:	e0fffa17 	ldw	r3,-24(fp)
  18437c:	00bfff84 	movi	r2,-2
  184380:	1884703a 	and	r2,r3,r2
  184384:	1001703a 	wrctl	status,r2
  
  return context;
  184388:	e0bffa17 	ldw	r2,-24(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  18438c:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  184390:	e0bffc17 	ldw	r2,-16(fp)
  184394:	10800817 	ldw	r2,32(r2)
  184398:	10c00094 	ori	r3,r2,2
  18439c:	e0bffc17 	ldw	r2,-16(fp)
  1843a0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  1843a4:	e0bffc17 	ldw	r2,-16(fp)
  1843a8:	10800017 	ldw	r2,0(r2)
  1843ac:	10800104 	addi	r2,r2,4
  1843b0:	e0fffc17 	ldw	r3,-16(fp)
  1843b4:	18c00817 	ldw	r3,32(r3)
  1843b8:	10c00035 	stwio	r3,0(r2)
  1843bc:	e0bff917 	ldw	r2,-28(fp)
  1843c0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1843c4:	e0bffb17 	ldw	r2,-20(fp)
  1843c8:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  1843cc:	e0bffe17 	ldw	r2,-8(fp)
  1843d0:	0080110e 	bge	zero,r2,184418 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
  1843d4:	e0bfff17 	ldw	r2,-4(fp)
  1843d8:	1090000c 	andi	r2,r2,16384
  1843dc:	1000111e 	bne	r2,zero,184424 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  1843e0:	0001883a 	nop
  1843e4:	e0bffc17 	ldw	r2,-16(fp)
  1843e8:	10c00d17 	ldw	r3,52(r2)
  1843ec:	e0bff517 	ldw	r2,-44(fp)
  1843f0:	1880051e 	bne	r3,r2,184408 <altera_avalon_jtag_uart_write+0x1b4>
  1843f4:	e0bffc17 	ldw	r2,-16(fp)
  1843f8:	10c00917 	ldw	r3,36(r2)
  1843fc:	e0bffc17 	ldw	r2,-16(fp)
  184400:	10800117 	ldw	r2,4(r2)
  184404:	18bff736 	bltu	r3,r2,1843e4 <altera_avalon_jtag_uart_write+0x190>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
  184408:	e0bffc17 	ldw	r2,-16(fp)
  18440c:	10c00d17 	ldw	r3,52(r2)
  184410:	e0bff517 	ldw	r2,-44(fp)
  184414:	18800526 	beq	r3,r2,18442c <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
  184418:	e0bffe17 	ldw	r2,-8(fp)
  18441c:	00bfd016 	blt	zero,r2,184360 <altera_avalon_jtag_uart_write+0x10c>
  184420:	00000306 	br	184430 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
  184424:	0001883a 	nop
  184428:	00000106 	br	184430 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
         break;
  18442c:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  184430:	e0fffd17 	ldw	r3,-12(fp)
  184434:	e0bff717 	ldw	r2,-36(fp)
  184438:	18800426 	beq	r3,r2,18444c <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
  18443c:	e0fffd17 	ldw	r3,-12(fp)
  184440:	e0bff717 	ldw	r2,-36(fp)
  184444:	1885c83a 	sub	r2,r3,r2
  184448:	00000606 	br	184464 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
  18444c:	e0bfff17 	ldw	r2,-4(fp)
  184450:	1090000c 	andi	r2,r2,16384
  184454:	10000226 	beq	r2,zero,184460 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
  184458:	00bffd44 	movi	r2,-11
  18445c:	00000106 	br	184464 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  184460:	00bffec4 	movi	r2,-5
}
  184464:	e037883a 	mov	sp,fp
  184468:	dfc00117 	ldw	ra,4(sp)
  18446c:	df000017 	ldw	fp,0(sp)
  184470:	dec00204 	addi	sp,sp,8
  184474:	f800283a 	ret

00184478 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  184478:	defff504 	addi	sp,sp,-44
  18447c:	df000a15 	stw	fp,40(sp)
  184480:	df000a04 	addi	fp,sp,40
  184484:	e13ffc15 	stw	r4,-16(fp)
  184488:	e17ffd15 	stw	r5,-12(fp)
  18448c:	e1bffe15 	stw	r6,-8(fp)
  184490:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  184494:	e03ff615 	stw	zero,-40(fp)
  184498:	008008b4 	movhi	r2,34
  18449c:	10862404 	addi	r2,r2,6288
  1844a0:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
  1844a4:	10003f26 	beq	r2,zero,1845a4 <alt_alarm_start+0x12c>
  {
    if (alarm)
  1844a8:	e0bffc17 	ldw	r2,-16(fp)
  1844ac:	10003b26 	beq	r2,zero,18459c <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
  1844b0:	e0bffc17 	ldw	r2,-16(fp)
  1844b4:	e0fffe17 	ldw	r3,-8(fp)
  1844b8:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  1844bc:	e0bffc17 	ldw	r2,-16(fp)
  1844c0:	e0ffff17 	ldw	r3,-4(fp)
  1844c4:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1844c8:	0005303a 	rdctl	r2,status
  1844cc:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1844d0:	e0fff817 	ldw	r3,-32(fp)
  1844d4:	00bfff84 	movi	r2,-2
  1844d8:	1884703a 	and	r2,r3,r2
  1844dc:	1001703a 	wrctl	status,r2
  
  return context;
  1844e0:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
  1844e4:	e0bff715 	stw	r2,-36(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  1844e8:	008008b4 	movhi	r2,34
  1844ec:	10862504 	addi	r2,r2,6292
  1844f0:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
  1844f4:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  1844f8:	e0fffd17 	ldw	r3,-12(fp)
  1844fc:	e0bff617 	ldw	r2,-40(fp)
  184500:	1885883a 	add	r2,r3,r2
  184504:	10c00044 	addi	r3,r2,1
  184508:	e0bffc17 	ldw	r2,-16(fp)
  18450c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  184510:	e0bffc17 	ldw	r2,-16(fp)
  184514:	10c00217 	ldw	r3,8(r2)
  184518:	e0bff617 	ldw	r2,-40(fp)
  18451c:	1880042e 	bgeu	r3,r2,184530 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
  184520:	e0bffc17 	ldw	r2,-16(fp)
  184524:	00c00044 	movi	r3,1
  184528:	10c00405 	stb	r3,16(r2)
  18452c:	00000206 	br	184538 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
  184530:	e0bffc17 	ldw	r2,-16(fp)
  184534:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  184538:	e0bffc17 	ldw	r2,-16(fp)
  18453c:	00c008b4 	movhi	r3,34
  184540:	18c60c04 	addi	r3,r3,6192
  184544:	e0fff915 	stw	r3,-28(fp)
  184548:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  18454c:	e0bffa17 	ldw	r2,-24(fp)
  184550:	e0fff917 	ldw	r3,-28(fp)
  184554:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  184558:	e0bff917 	ldw	r2,-28(fp)
  18455c:	10c00017 	ldw	r3,0(r2)
  184560:	e0bffa17 	ldw	r2,-24(fp)
  184564:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  184568:	e0bff917 	ldw	r2,-28(fp)
  18456c:	10800017 	ldw	r2,0(r2)
  184570:	e0fffa17 	ldw	r3,-24(fp)
  184574:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  184578:	e0bff917 	ldw	r2,-28(fp)
  18457c:	e0fffa17 	ldw	r3,-24(fp)
  184580:	10c00015 	stw	r3,0(r2)
  184584:	e0bff717 	ldw	r2,-36(fp)
  184588:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  18458c:	e0bffb17 	ldw	r2,-20(fp)
  184590:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  184594:	0005883a 	mov	r2,zero
  184598:	00000306 	br	1845a8 <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
  18459c:	00bffa84 	movi	r2,-22
  1845a0:	00000106 	br	1845a8 <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
  1845a4:	00bfde84 	movi	r2,-134
  }
}
  1845a8:	e037883a 	mov	sp,fp
  1845ac:	df000017 	ldw	fp,0(sp)
  1845b0:	dec00104 	addi	sp,sp,4
  1845b4:	f800283a 	ret

001845b8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  1845b8:	defffe04 	addi	sp,sp,-8
  1845bc:	dfc00115 	stw	ra,4(sp)
  1845c0:	df000015 	stw	fp,0(sp)
  1845c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  1845c8:	008008b4 	movhi	r2,34
  1845cc:	10860b04 	addi	r2,r2,6188
  1845d0:	10800017 	ldw	r2,0(r2)
  1845d4:	10000526 	beq	r2,zero,1845ec <alt_get_errno+0x34>
  1845d8:	008008b4 	movhi	r2,34
  1845dc:	10860b04 	addi	r2,r2,6188
  1845e0:	10800017 	ldw	r2,0(r2)
  1845e4:	103ee83a 	callr	r2
  1845e8:	00000206 	br	1845f4 <alt_get_errno+0x3c>
  1845ec:	008008b4 	movhi	r2,34
  1845f0:	10862604 	addi	r2,r2,6296
}
  1845f4:	e037883a 	mov	sp,fp
  1845f8:	dfc00117 	ldw	ra,4(sp)
  1845fc:	df000017 	ldw	fp,0(sp)
  184600:	dec00204 	addi	sp,sp,8
  184604:	f800283a 	ret

00184608 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  184608:	defffb04 	addi	sp,sp,-20
  18460c:	dfc00415 	stw	ra,16(sp)
  184610:	df000315 	stw	fp,12(sp)
  184614:	df000304 	addi	fp,sp,12
  184618:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  18461c:	e0bfff17 	ldw	r2,-4(fp)
  184620:	10000716 	blt	r2,zero,184640 <close+0x38>
  184624:	e13fff17 	ldw	r4,-4(fp)
  184628:	01400304 	movi	r5,12
  18462c:	01832700 	call	183270 <__mulsi3>
  184630:	00c008b4 	movhi	r3,34
  184634:	18c4a304 	addi	r3,r3,4748
  184638:	10c5883a 	add	r2,r2,r3
  18463c:	00000106 	br	184644 <close+0x3c>
  184640:	0005883a 	mov	r2,zero
  184644:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  184648:	e0bffd17 	ldw	r2,-12(fp)
  18464c:	10001826 	beq	r2,zero,1846b0 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  184650:	e0bffd17 	ldw	r2,-12(fp)
  184654:	10800017 	ldw	r2,0(r2)
  184658:	10800417 	ldw	r2,16(r2)
  18465c:	10000626 	beq	r2,zero,184678 <close+0x70>
  184660:	e0bffd17 	ldw	r2,-12(fp)
  184664:	10800017 	ldw	r2,0(r2)
  184668:	10800417 	ldw	r2,16(r2)
  18466c:	e13ffd17 	ldw	r4,-12(fp)
  184670:	103ee83a 	callr	r2
  184674:	00000106 	br	18467c <close+0x74>
  184678:	0005883a 	mov	r2,zero
  18467c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  184680:	e13fff17 	ldw	r4,-4(fp)
  184684:	0184cd00 	call	184cd0 <alt_release_fd>
    if (rval < 0)
  184688:	e0bffe17 	ldw	r2,-8(fp)
  18468c:	1000060e 	bge	r2,zero,1846a8 <close+0xa0>
    {
      ALT_ERRNO = -rval;
  184690:	01845b80 	call	1845b8 <alt_get_errno>
  184694:	e0fffe17 	ldw	r3,-8(fp)
  184698:	00c7c83a 	sub	r3,zero,r3
  18469c:	10c00015 	stw	r3,0(r2)
      return -1;
  1846a0:	00bfffc4 	movi	r2,-1
  1846a4:	00000606 	br	1846c0 <close+0xb8>
    }
    return 0;
  1846a8:	0005883a 	mov	r2,zero
  1846ac:	00000406 	br	1846c0 <close+0xb8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  1846b0:	01845b80 	call	1845b8 <alt_get_errno>
  1846b4:	00c01444 	movi	r3,81
  1846b8:	10c00015 	stw	r3,0(r2)
    return -1;
  1846bc:	00bfffc4 	movi	r2,-1
  }
}
  1846c0:	e037883a 	mov	sp,fp
  1846c4:	dfc00117 	ldw	ra,4(sp)
  1846c8:	df000017 	ldw	fp,0(sp)
  1846cc:	dec00204 	addi	sp,sp,8
  1846d0:	f800283a 	ret

001846d4 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  1846d4:	deffff04 	addi	sp,sp,-4
  1846d8:	df000015 	stw	fp,0(sp)
  1846dc:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  1846e0:	e037883a 	mov	sp,fp
  1846e4:	df000017 	ldw	fp,0(sp)
  1846e8:	dec00104 	addi	sp,sp,4
  1846ec:	f800283a 	ret

001846f0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  1846f0:	defffc04 	addi	sp,sp,-16
  1846f4:	df000315 	stw	fp,12(sp)
  1846f8:	df000304 	addi	fp,sp,12
  1846fc:	e13ffd15 	stw	r4,-12(fp)
  184700:	e17ffe15 	stw	r5,-8(fp)
  184704:	e1bfff15 	stw	r6,-4(fp)
  return len;
  184708:	e0bfff17 	ldw	r2,-4(fp)
}
  18470c:	e037883a 	mov	sp,fp
  184710:	df000017 	ldw	fp,0(sp)
  184714:	dec00104 	addi	sp,sp,4
  184718:	f800283a 	ret

0018471c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  18471c:	defffe04 	addi	sp,sp,-8
  184720:	dfc00115 	stw	ra,4(sp)
  184724:	df000015 	stw	fp,0(sp)
  184728:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  18472c:	008008b4 	movhi	r2,34
  184730:	10860b04 	addi	r2,r2,6188
  184734:	10800017 	ldw	r2,0(r2)
  184738:	10000526 	beq	r2,zero,184750 <alt_get_errno+0x34>
  18473c:	008008b4 	movhi	r2,34
  184740:	10860b04 	addi	r2,r2,6188
  184744:	10800017 	ldw	r2,0(r2)
  184748:	103ee83a 	callr	r2
  18474c:	00000206 	br	184758 <alt_get_errno+0x3c>
  184750:	008008b4 	movhi	r2,34
  184754:	10862604 	addi	r2,r2,6296
}
  184758:	e037883a 	mov	sp,fp
  18475c:	dfc00117 	ldw	ra,4(sp)
  184760:	df000017 	ldw	fp,0(sp)
  184764:	dec00204 	addi	sp,sp,8
  184768:	f800283a 	ret

0018476c <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  18476c:	defffa04 	addi	sp,sp,-24
  184770:	dfc00515 	stw	ra,20(sp)
  184774:	df000415 	stw	fp,16(sp)
  184778:	df000404 	addi	fp,sp,16
  18477c:	e13ffe15 	stw	r4,-8(fp)
  184780:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  184784:	e0bffe17 	ldw	r2,-8(fp)
  184788:	10000326 	beq	r2,zero,184798 <alt_dev_llist_insert+0x2c>
  18478c:	e0bffe17 	ldw	r2,-8(fp)
  184790:	10800217 	ldw	r2,8(r2)
  184794:	1000051e 	bne	r2,zero,1847ac <alt_dev_llist_insert+0x40>
  {
    ALT_ERRNO = EINVAL;
  184798:	018471c0 	call	18471c <alt_get_errno>
  18479c:	00c00584 	movi	r3,22
  1847a0:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  1847a4:	00bffa84 	movi	r2,-22
  1847a8:	00001306 	br	1847f8 <alt_dev_llist_insert+0x8c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  1847ac:	e0bffe17 	ldw	r2,-8(fp)
  1847b0:	e0ffff17 	ldw	r3,-4(fp)
  1847b4:	e0fffc15 	stw	r3,-16(fp)
  1847b8:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  1847bc:	e0bffd17 	ldw	r2,-12(fp)
  1847c0:	e0fffc17 	ldw	r3,-16(fp)
  1847c4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  1847c8:	e0bffc17 	ldw	r2,-16(fp)
  1847cc:	10c00017 	ldw	r3,0(r2)
  1847d0:	e0bffd17 	ldw	r2,-12(fp)
  1847d4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  1847d8:	e0bffc17 	ldw	r2,-16(fp)
  1847dc:	10800017 	ldw	r2,0(r2)
  1847e0:	e0fffd17 	ldw	r3,-12(fp)
  1847e4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  1847e8:	e0bffc17 	ldw	r2,-16(fp)
  1847ec:	e0fffd17 	ldw	r3,-12(fp)
  1847f0:	10c00015 	stw	r3,0(r2)

  return 0;  
  1847f4:	0005883a 	mov	r2,zero
}
  1847f8:	e037883a 	mov	sp,fp
  1847fc:	dfc00117 	ldw	ra,4(sp)
  184800:	df000017 	ldw	fp,0(sp)
  184804:	dec00204 	addi	sp,sp,8
  184808:	f800283a 	ret

0018480c <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  18480c:	defffd04 	addi	sp,sp,-12
  184810:	dfc00215 	stw	ra,8(sp)
  184814:	df000115 	stw	fp,4(sp)
  184818:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  18481c:	00800634 	movhi	r2,24
  184820:	1095c804 	addi	r2,r2,22304
  184824:	e0bfff15 	stw	r2,-4(fp)
  184828:	00000606 	br	184844 <_do_ctors+0x38>
        (*ctor) (); 
  18482c:	e0bfff17 	ldw	r2,-4(fp)
  184830:	10800017 	ldw	r2,0(r2)
  184834:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  184838:	e0bfff17 	ldw	r2,-4(fp)
  18483c:	10bfff04 	addi	r2,r2,-4
  184840:	e0bfff15 	stw	r2,-4(fp)
  184844:	e0ffff17 	ldw	r3,-4(fp)
  184848:	00800634 	movhi	r2,24
  18484c:	1095c904 	addi	r2,r2,22308
  184850:	18bff62e 	bgeu	r3,r2,18482c <_do_ctors+0x20>
        (*ctor) (); 
}
  184854:	e037883a 	mov	sp,fp
  184858:	dfc00117 	ldw	ra,4(sp)
  18485c:	df000017 	ldw	fp,0(sp)
  184860:	dec00204 	addi	sp,sp,8
  184864:	f800283a 	ret

00184868 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  184868:	defffd04 	addi	sp,sp,-12
  18486c:	dfc00215 	stw	ra,8(sp)
  184870:	df000115 	stw	fp,4(sp)
  184874:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  184878:	00800634 	movhi	r2,24
  18487c:	1095c804 	addi	r2,r2,22304
  184880:	e0bfff15 	stw	r2,-4(fp)
  184884:	00000606 	br	1848a0 <_do_dtors+0x38>
        (*dtor) (); 
  184888:	e0bfff17 	ldw	r2,-4(fp)
  18488c:	10800017 	ldw	r2,0(r2)
  184890:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  184894:	e0bfff17 	ldw	r2,-4(fp)
  184898:	10bfff04 	addi	r2,r2,-4
  18489c:	e0bfff15 	stw	r2,-4(fp)
  1848a0:	e0ffff17 	ldw	r3,-4(fp)
  1848a4:	00800634 	movhi	r2,24
  1848a8:	1095c904 	addi	r2,r2,22308
  1848ac:	18bff62e 	bgeu	r3,r2,184888 <_do_dtors+0x20>
        (*dtor) (); 
}
  1848b0:	e037883a 	mov	sp,fp
  1848b4:	dfc00117 	ldw	ra,4(sp)
  1848b8:	df000017 	ldw	fp,0(sp)
  1848bc:	dec00204 	addi	sp,sp,8
  1848c0:	f800283a 	ret

001848c4 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  1848c4:	deffff04 	addi	sp,sp,-4
  1848c8:	df000015 	stw	fp,0(sp)
  1848cc:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
  1848d0:	e037883a 	mov	sp,fp
  1848d4:	df000017 	ldw	fp,0(sp)
  1848d8:	dec00104 	addi	sp,sp,4
  1848dc:	f800283a 	ret

001848e0 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  1848e0:	defff804 	addi	sp,sp,-32
  1848e4:	dfc00715 	stw	ra,28(sp)
  1848e8:	df000615 	stw	fp,24(sp)
  1848ec:	dc000515 	stw	r16,20(sp)
  1848f0:	df000504 	addi	fp,sp,20
  1848f4:	e13ffc15 	stw	r4,-16(fp)
  1848f8:	e17ffd15 	stw	r5,-12(fp)
  1848fc:	e1bffe15 	stw	r6,-8(fp)
  184900:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
  184904:	e13ffd17 	ldw	r4,-12(fp)
  184908:	e17ffe17 	ldw	r5,-8(fp)
  18490c:	e1bfff17 	ldw	r6,-4(fp)
  184910:	0184b780 	call	184b78 <open>
  184914:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
  184918:	e0bffb17 	ldw	r2,-20(fp)
  18491c:	10002216 	blt	r2,zero,1849a8 <alt_open_fd+0xc8>
  {
    fd->dev      = alt_fd_list[old].dev;
  184920:	040008b4 	movhi	r16,34
  184924:	8404a304 	addi	r16,r16,4748
  184928:	e0bffb17 	ldw	r2,-20(fp)
  18492c:	1009883a 	mov	r4,r2
  184930:	01400304 	movi	r5,12
  184934:	01832700 	call	183270 <__mulsi3>
  184938:	8085883a 	add	r2,r16,r2
  18493c:	10c00017 	ldw	r3,0(r2)
  184940:	e0bffc17 	ldw	r2,-16(fp)
  184944:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  184948:	040008b4 	movhi	r16,34
  18494c:	8404a304 	addi	r16,r16,4748
  184950:	e0bffb17 	ldw	r2,-20(fp)
  184954:	1009883a 	mov	r4,r2
  184958:	01400304 	movi	r5,12
  18495c:	01832700 	call	183270 <__mulsi3>
  184960:	8085883a 	add	r2,r16,r2
  184964:	10800104 	addi	r2,r2,4
  184968:	10c00017 	ldw	r3,0(r2)
  18496c:	e0bffc17 	ldw	r2,-16(fp)
  184970:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  184974:	040008b4 	movhi	r16,34
  184978:	8404a304 	addi	r16,r16,4748
  18497c:	e0bffb17 	ldw	r2,-20(fp)
  184980:	1009883a 	mov	r4,r2
  184984:	01400304 	movi	r5,12
  184988:	01832700 	call	183270 <__mulsi3>
  18498c:	8085883a 	add	r2,r16,r2
  184990:	10800204 	addi	r2,r2,8
  184994:	10c00017 	ldw	r3,0(r2)
  184998:	e0bffc17 	ldw	r2,-16(fp)
  18499c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  1849a0:	e13ffb17 	ldw	r4,-20(fp)
  1849a4:	0184cd00 	call	184cd0 <alt_release_fd>
  }
} 
  1849a8:	e037883a 	mov	sp,fp
  1849ac:	dfc00217 	ldw	ra,8(sp)
  1849b0:	df000117 	ldw	fp,4(sp)
  1849b4:	dc000017 	ldw	r16,0(sp)
  1849b8:	dec00304 	addi	sp,sp,12
  1849bc:	f800283a 	ret

001849c0 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  1849c0:	defffb04 	addi	sp,sp,-20
  1849c4:	dfc00415 	stw	ra,16(sp)
  1849c8:	df000315 	stw	fp,12(sp)
  1849cc:	df000304 	addi	fp,sp,12
  1849d0:	e13ffd15 	stw	r4,-12(fp)
  1849d4:	e17ffe15 	stw	r5,-8(fp)
  1849d8:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  1849dc:	010008b4 	movhi	r4,34
  1849e0:	2104a604 	addi	r4,r4,4760
  1849e4:	e17ffd17 	ldw	r5,-12(fp)
  1849e8:	01800044 	movi	r6,1
  1849ec:	01c07fc4 	movi	r7,511
  1849f0:	01848e00 	call	1848e0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  1849f4:	010008b4 	movhi	r4,34
  1849f8:	2104a304 	addi	r4,r4,4748
  1849fc:	e17ffe17 	ldw	r5,-8(fp)
  184a00:	000d883a 	mov	r6,zero
  184a04:	01c07fc4 	movi	r7,511
  184a08:	01848e00 	call	1848e0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  184a0c:	010008b4 	movhi	r4,34
  184a10:	2104a904 	addi	r4,r4,4772
  184a14:	e17fff17 	ldw	r5,-4(fp)
  184a18:	01800044 	movi	r6,1
  184a1c:	01c07fc4 	movi	r7,511
  184a20:	01848e00 	call	1848e0 <alt_open_fd>
}  
  184a24:	e037883a 	mov	sp,fp
  184a28:	dfc00117 	ldw	ra,4(sp)
  184a2c:	df000017 	ldw	fp,0(sp)
  184a30:	dec00204 	addi	sp,sp,8
  184a34:	f800283a 	ret

00184a38 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  184a38:	defffe04 	addi	sp,sp,-8
  184a3c:	dfc00115 	stw	ra,4(sp)
  184a40:	df000015 	stw	fp,0(sp)
  184a44:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  184a48:	008008b4 	movhi	r2,34
  184a4c:	10860b04 	addi	r2,r2,6188
  184a50:	10800017 	ldw	r2,0(r2)
  184a54:	10000526 	beq	r2,zero,184a6c <alt_get_errno+0x34>
  184a58:	008008b4 	movhi	r2,34
  184a5c:	10860b04 	addi	r2,r2,6188
  184a60:	10800017 	ldw	r2,0(r2)
  184a64:	103ee83a 	callr	r2
  184a68:	00000206 	br	184a74 <alt_get_errno+0x3c>
  184a6c:	008008b4 	movhi	r2,34
  184a70:	10862604 	addi	r2,r2,6296
}
  184a74:	e037883a 	mov	sp,fp
  184a78:	dfc00117 	ldw	ra,4(sp)
  184a7c:	df000017 	ldw	fp,0(sp)
  184a80:	dec00204 	addi	sp,sp,8
  184a84:	f800283a 	ret

00184a88 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  184a88:	defffb04 	addi	sp,sp,-20
  184a8c:	dfc00415 	stw	ra,16(sp)
  184a90:	df000315 	stw	fp,12(sp)
  184a94:	dc000215 	stw	r16,8(sp)
  184a98:	df000204 	addi	fp,sp,8
  184a9c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  184aa0:	e0bfff17 	ldw	r2,-4(fp)
  184aa4:	10800217 	ldw	r2,8(r2)
  184aa8:	10d00034 	orhi	r3,r2,16384
  184aac:	e0bfff17 	ldw	r2,-4(fp)
  184ab0:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  184ab4:	e03ffe15 	stw	zero,-8(fp)
  184ab8:	00002206 	br	184b44 <alt_file_locked+0xbc>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  184abc:	040008b4 	movhi	r16,34
  184ac0:	8404a304 	addi	r16,r16,4748
  184ac4:	e0bffe17 	ldw	r2,-8(fp)
  184ac8:	1009883a 	mov	r4,r2
  184acc:	01400304 	movi	r5,12
  184ad0:	01832700 	call	183270 <__mulsi3>
  184ad4:	8085883a 	add	r2,r16,r2
  184ad8:	10c00017 	ldw	r3,0(r2)
  184adc:	e0bfff17 	ldw	r2,-4(fp)
  184ae0:	10800017 	ldw	r2,0(r2)
  184ae4:	1880141e 	bne	r3,r2,184b38 <alt_file_locked+0xb0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  184ae8:	040008b4 	movhi	r16,34
  184aec:	8404a304 	addi	r16,r16,4748
  184af0:	e0bffe17 	ldw	r2,-8(fp)
  184af4:	1009883a 	mov	r4,r2
  184af8:	01400304 	movi	r5,12
  184afc:	01832700 	call	183270 <__mulsi3>
  184b00:	8085883a 	add	r2,r16,r2
  184b04:	10800204 	addi	r2,r2,8
  184b08:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  184b0c:	10000a0e 	bge	r2,zero,184b38 <alt_file_locked+0xb0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  184b10:	e13ffe17 	ldw	r4,-8(fp)
  184b14:	01400304 	movi	r5,12
  184b18:	01832700 	call	183270 <__mulsi3>
  184b1c:	00c008b4 	movhi	r3,34
  184b20:	18c4a304 	addi	r3,r3,4748
  184b24:	10c7883a 	add	r3,r2,r3
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  184b28:	e0bfff17 	ldw	r2,-4(fp)
  184b2c:	18800226 	beq	r3,r2,184b38 <alt_file_locked+0xb0>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  184b30:	00bffcc4 	movi	r2,-13
  184b34:	00000a06 	br	184b60 <alt_file_locked+0xd8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  184b38:	e0bffe17 	ldw	r2,-8(fp)
  184b3c:	10800044 	addi	r2,r2,1
  184b40:	e0bffe15 	stw	r2,-8(fp)
  184b44:	008008b4 	movhi	r2,34
  184b48:	10860a04 	addi	r2,r2,6184
  184b4c:	10800017 	ldw	r2,0(r2)
  184b50:	1007883a 	mov	r3,r2
  184b54:	e0bffe17 	ldw	r2,-8(fp)
  184b58:	18bfd82e 	bgeu	r3,r2,184abc <alt_file_locked+0x34>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  184b5c:	0005883a 	mov	r2,zero
}
  184b60:	e037883a 	mov	sp,fp
  184b64:	dfc00217 	ldw	ra,8(sp)
  184b68:	df000117 	ldw	fp,4(sp)
  184b6c:	dc000017 	ldw	r16,0(sp)
  184b70:	dec00304 	addi	sp,sp,12
  184b74:	f800283a 	ret

00184b78 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  184b78:	defff604 	addi	sp,sp,-40
  184b7c:	dfc00915 	stw	ra,36(sp)
  184b80:	df000815 	stw	fp,32(sp)
  184b84:	df000804 	addi	fp,sp,32
  184b88:	e13ffd15 	stw	r4,-12(fp)
  184b8c:	e17ffe15 	stw	r5,-8(fp)
  184b90:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  184b94:	00bfffc4 	movi	r2,-1
  184b98:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  184b9c:	00bffb44 	movi	r2,-19
  184ba0:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  184ba4:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  184ba8:	e13ffd17 	ldw	r4,-12(fp)
  184bac:	014008b4 	movhi	r5,34
  184bb0:	29460804 	addi	r5,r5,6176
  184bb4:	0184f0c0 	call	184f0c <alt_find_dev>
  184bb8:	e0bff815 	stw	r2,-32(fp)
  184bbc:	e0bff817 	ldw	r2,-32(fp)
  184bc0:	1000051e 	bne	r2,zero,184bd8 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  184bc4:	e13ffd17 	ldw	r4,-12(fp)
  184bc8:	0184f9c0 	call	184f9c <alt_find_file>
  184bcc:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  184bd0:	00800044 	movi	r2,1
  184bd4:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  184bd8:	e0bff817 	ldw	r2,-32(fp)
  184bdc:	10002a26 	beq	r2,zero,184c88 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
  184be0:	e13ff817 	ldw	r4,-32(fp)
  184be4:	01850b00 	call	1850b0 <alt_get_fd>
  184be8:	e0bff915 	stw	r2,-28(fp)
  184bec:	e0bff917 	ldw	r2,-28(fp)
  184bf0:	1000030e 	bge	r2,zero,184c00 <open+0x88>
    {
      status = index;
  184bf4:	e0bff917 	ldw	r2,-28(fp)
  184bf8:	e0bffa15 	stw	r2,-24(fp)
  184bfc:	00002406 	br	184c90 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
  184c00:	e13ff917 	ldw	r4,-28(fp)
  184c04:	01400304 	movi	r5,12
  184c08:	01832700 	call	183270 <__mulsi3>
  184c0c:	00c008b4 	movhi	r3,34
  184c10:	18c4a304 	addi	r3,r3,4748
  184c14:	10c5883a 	add	r2,r2,r3
  184c18:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  184c1c:	e0fffe17 	ldw	r3,-8(fp)
  184c20:	00900034 	movhi	r2,16384
  184c24:	10bfffc4 	addi	r2,r2,-1
  184c28:	1886703a 	and	r3,r3,r2
  184c2c:	e0bffc17 	ldw	r2,-16(fp)
  184c30:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  184c34:	e0bffb17 	ldw	r2,-20(fp)
  184c38:	1000051e 	bne	r2,zero,184c50 <open+0xd8>
  184c3c:	e13ffc17 	ldw	r4,-16(fp)
  184c40:	0184a880 	call	184a88 <alt_file_locked>
  184c44:	e0bffa15 	stw	r2,-24(fp)
  184c48:	e0bffa17 	ldw	r2,-24(fp)
  184c4c:	10001016 	blt	r2,zero,184c90 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  184c50:	e0bff817 	ldw	r2,-32(fp)
  184c54:	10800317 	ldw	r2,12(r2)
  184c58:	10000826 	beq	r2,zero,184c7c <open+0x104>
  184c5c:	e0bff817 	ldw	r2,-32(fp)
  184c60:	10800317 	ldw	r2,12(r2)
  184c64:	e13ffc17 	ldw	r4,-16(fp)
  184c68:	e17ffd17 	ldw	r5,-12(fp)
  184c6c:	e1bffe17 	ldw	r6,-8(fp)
  184c70:	e1ffff17 	ldw	r7,-4(fp)
  184c74:	103ee83a 	callr	r2
  184c78:	00000106 	br	184c80 <open+0x108>
  184c7c:	0005883a 	mov	r2,zero
  184c80:	e0bffa15 	stw	r2,-24(fp)
  184c84:	00000206 	br	184c90 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
  184c88:	00bffb44 	movi	r2,-19
  184c8c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  184c90:	e0bffa17 	ldw	r2,-24(fp)
  184c94:	1000080e 	bge	r2,zero,184cb8 <open+0x140>
  {
    alt_release_fd (index);  
  184c98:	e13ff917 	ldw	r4,-28(fp)
  184c9c:	0184cd00 	call	184cd0 <alt_release_fd>
    ALT_ERRNO = -status;
  184ca0:	0184a380 	call	184a38 <alt_get_errno>
  184ca4:	e0fffa17 	ldw	r3,-24(fp)
  184ca8:	00c7c83a 	sub	r3,zero,r3
  184cac:	10c00015 	stw	r3,0(r2)
    return -1;
  184cb0:	00bfffc4 	movi	r2,-1
  184cb4:	00000106 	br	184cbc <open+0x144>
  }
  
  /* return the reference upon success */

  return index;
  184cb8:	e0bff917 	ldw	r2,-28(fp)
}
  184cbc:	e037883a 	mov	sp,fp
  184cc0:	dfc00117 	ldw	ra,4(sp)
  184cc4:	df000017 	ldw	fp,0(sp)
  184cc8:	dec00204 	addi	sp,sp,8
  184ccc:	f800283a 	ret

00184cd0 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  184cd0:	defffc04 	addi	sp,sp,-16
  184cd4:	dfc00315 	stw	ra,12(sp)
  184cd8:	df000215 	stw	fp,8(sp)
  184cdc:	dc000115 	stw	r16,4(sp)
  184ce0:	df000104 	addi	fp,sp,4
  184ce4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  184ce8:	e0bfff17 	ldw	r2,-4(fp)
  184cec:	108000d0 	cmplti	r2,r2,3
  184cf0:	1000111e 	bne	r2,zero,184d38 <alt_release_fd+0x68>
  {
    alt_fd_list[fd].fd_flags = 0;
  184cf4:	040008b4 	movhi	r16,34
  184cf8:	8404a304 	addi	r16,r16,4748
  184cfc:	e0bfff17 	ldw	r2,-4(fp)
  184d00:	1009883a 	mov	r4,r2
  184d04:	01400304 	movi	r5,12
  184d08:	01832700 	call	183270 <__mulsi3>
  184d0c:	8085883a 	add	r2,r16,r2
  184d10:	10800204 	addi	r2,r2,8
  184d14:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  184d18:	040008b4 	movhi	r16,34
  184d1c:	8404a304 	addi	r16,r16,4748
  184d20:	e0bfff17 	ldw	r2,-4(fp)
  184d24:	1009883a 	mov	r4,r2
  184d28:	01400304 	movi	r5,12
  184d2c:	01832700 	call	183270 <__mulsi3>
  184d30:	8085883a 	add	r2,r16,r2
  184d34:	10000015 	stw	zero,0(r2)
  }
}
  184d38:	e037883a 	mov	sp,fp
  184d3c:	dfc00217 	ldw	ra,8(sp)
  184d40:	df000117 	ldw	fp,4(sp)
  184d44:	dc000017 	ldw	r16,0(sp)
  184d48:	dec00304 	addi	sp,sp,12
  184d4c:	f800283a 	ret

00184d50 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  184d50:	defffa04 	addi	sp,sp,-24
  184d54:	df000515 	stw	fp,20(sp)
  184d58:	df000504 	addi	fp,sp,20
  184d5c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  184d60:	0005303a 	rdctl	r2,status
  184d64:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  184d68:	e0fffc17 	ldw	r3,-16(fp)
  184d6c:	00bfff84 	movi	r2,-2
  184d70:	1884703a 	and	r2,r3,r2
  184d74:	1001703a 	wrctl	status,r2
  
  return context;
  184d78:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  184d7c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  184d80:	e0bfff17 	ldw	r2,-4(fp)
  184d84:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  184d88:	e0bffd17 	ldw	r2,-12(fp)
  184d8c:	10800017 	ldw	r2,0(r2)
  184d90:	e0fffd17 	ldw	r3,-12(fp)
  184d94:	18c00117 	ldw	r3,4(r3)
  184d98:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  184d9c:	e0bffd17 	ldw	r2,-12(fp)
  184da0:	10800117 	ldw	r2,4(r2)
  184da4:	e0fffd17 	ldw	r3,-12(fp)
  184da8:	18c00017 	ldw	r3,0(r3)
  184dac:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  184db0:	e0bffd17 	ldw	r2,-12(fp)
  184db4:	e0fffd17 	ldw	r3,-12(fp)
  184db8:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  184dbc:	e0bffd17 	ldw	r2,-12(fp)
  184dc0:	e0fffd17 	ldw	r3,-12(fp)
  184dc4:	10c00015 	stw	r3,0(r2)
  184dc8:	e0bffb17 	ldw	r2,-20(fp)
  184dcc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  184dd0:	e0bffe17 	ldw	r2,-8(fp)
  184dd4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  184dd8:	e037883a 	mov	sp,fp
  184ddc:	df000017 	ldw	fp,0(sp)
  184de0:	dec00104 	addi	sp,sp,4
  184de4:	f800283a 	ret

00184de8 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  184de8:	defffb04 	addi	sp,sp,-20
  184dec:	dfc00415 	stw	ra,16(sp)
  184df0:	df000315 	stw	fp,12(sp)
  184df4:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  184df8:	d0a00917 	ldw	r2,-32732(gp)
  184dfc:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  184e00:	d0a02217 	ldw	r2,-32632(gp)
  184e04:	10800044 	addi	r2,r2,1
  184e08:	d0a02215 	stw	r2,-32632(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  184e0c:	00002e06 	br	184ec8 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  184e10:	e0bffd17 	ldw	r2,-12(fp)
  184e14:	10800017 	ldw	r2,0(r2)
  184e18:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  184e1c:	e0bffd17 	ldw	r2,-12(fp)
  184e20:	10800403 	ldbu	r2,16(r2)
  184e24:	10803fcc 	andi	r2,r2,255
  184e28:	10000426 	beq	r2,zero,184e3c <alt_tick+0x54>
  184e2c:	d0a02217 	ldw	r2,-32632(gp)
  184e30:	1000021e 	bne	r2,zero,184e3c <alt_tick+0x54>
    {
      alarm->rollover = 0;
  184e34:	e0bffd17 	ldw	r2,-12(fp)
  184e38:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  184e3c:	e0bffd17 	ldw	r2,-12(fp)
  184e40:	10800217 	ldw	r2,8(r2)
  184e44:	d0e02217 	ldw	r3,-32632(gp)
  184e48:	18801d36 	bltu	r3,r2,184ec0 <alt_tick+0xd8>
  184e4c:	e0bffd17 	ldw	r2,-12(fp)
  184e50:	10800403 	ldbu	r2,16(r2)
  184e54:	10803fcc 	andi	r2,r2,255
  184e58:	1000191e 	bne	r2,zero,184ec0 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  184e5c:	e0bffd17 	ldw	r2,-12(fp)
  184e60:	10c00317 	ldw	r3,12(r2)
  184e64:	e0bffd17 	ldw	r2,-12(fp)
  184e68:	10800517 	ldw	r2,20(r2)
  184e6c:	1009883a 	mov	r4,r2
  184e70:	183ee83a 	callr	r3
  184e74:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  184e78:	e0bfff17 	ldw	r2,-4(fp)
  184e7c:	1000031e 	bne	r2,zero,184e8c <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  184e80:	e13ffd17 	ldw	r4,-12(fp)
  184e84:	0184d500 	call	184d50 <alt_alarm_stop>
  184e88:	00000d06 	br	184ec0 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  184e8c:	e0bffd17 	ldw	r2,-12(fp)
  184e90:	10c00217 	ldw	r3,8(r2)
  184e94:	e0bfff17 	ldw	r2,-4(fp)
  184e98:	1887883a 	add	r3,r3,r2
  184e9c:	e0bffd17 	ldw	r2,-12(fp)
  184ea0:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  184ea4:	e0bffd17 	ldw	r2,-12(fp)
  184ea8:	10c00217 	ldw	r3,8(r2)
  184eac:	d0a02217 	ldw	r2,-32632(gp)
  184eb0:	1880032e 	bgeu	r3,r2,184ec0 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  184eb4:	e0bffd17 	ldw	r2,-12(fp)
  184eb8:	00c00044 	movi	r3,1
  184ebc:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  184ec0:	e0bffe17 	ldw	r2,-8(fp)
  184ec4:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  184ec8:	e0fffd17 	ldw	r3,-12(fp)
  184ecc:	d0a00904 	addi	r2,gp,-32732
  184ed0:	18bfcf1e 	bne	r3,r2,184e10 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  184ed4:	0001883a 	nop
}
  184ed8:	e037883a 	mov	sp,fp
  184edc:	dfc00117 	ldw	ra,4(sp)
  184ee0:	df000017 	ldw	fp,0(sp)
  184ee4:	dec00204 	addi	sp,sp,8
  184ee8:	f800283a 	ret

00184eec <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
  184eec:	deffff04 	addi	sp,sp,-4
  184ef0:	df000015 	stw	fp,0(sp)
  184ef4:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  184ef8:	000170fa 	wrctl	ienable,zero
}
  184efc:	e037883a 	mov	sp,fp
  184f00:	df000017 	ldw	fp,0(sp)
  184f04:	dec00104 	addi	sp,sp,4
  184f08:	f800283a 	ret

00184f0c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  184f0c:	defffa04 	addi	sp,sp,-24
  184f10:	dfc00515 	stw	ra,20(sp)
  184f14:	df000415 	stw	fp,16(sp)
  184f18:	df000404 	addi	fp,sp,16
  184f1c:	e13ffe15 	stw	r4,-8(fp)
  184f20:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  184f24:	e0bfff17 	ldw	r2,-4(fp)
  184f28:	10800017 	ldw	r2,0(r2)
  184f2c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  184f30:	e13ffe17 	ldw	r4,-8(fp)
  184f34:	018538c0 	call	18538c <strlen>
  184f38:	10800044 	addi	r2,r2,1
  184f3c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  184f40:	00000d06 	br	184f78 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  184f44:	e0bffc17 	ldw	r2,-16(fp)
  184f48:	10c00217 	ldw	r3,8(r2)
  184f4c:	e0bffd17 	ldw	r2,-12(fp)
  184f50:	1809883a 	mov	r4,r3
  184f54:	e17ffe17 	ldw	r5,-8(fp)
  184f58:	100d883a 	mov	r6,r2
  184f5c:	01851d00 	call	1851d0 <memcmp>
  184f60:	1000021e 	bne	r2,zero,184f6c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  184f64:	e0bffc17 	ldw	r2,-16(fp)
  184f68:	00000706 	br	184f88 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  184f6c:	e0bffc17 	ldw	r2,-16(fp)
  184f70:	10800017 	ldw	r2,0(r2)
  184f74:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  184f78:	e0fffc17 	ldw	r3,-16(fp)
  184f7c:	e0bfff17 	ldw	r2,-4(fp)
  184f80:	18bff01e 	bne	r3,r2,184f44 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  184f84:	0005883a 	mov	r2,zero
}
  184f88:	e037883a 	mov	sp,fp
  184f8c:	dfc00117 	ldw	ra,4(sp)
  184f90:	df000017 	ldw	fp,0(sp)
  184f94:	dec00204 	addi	sp,sp,8
  184f98:	f800283a 	ret

00184f9c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  184f9c:	defffb04 	addi	sp,sp,-20
  184fa0:	dfc00415 	stw	ra,16(sp)
  184fa4:	df000315 	stw	fp,12(sp)
  184fa8:	df000304 	addi	fp,sp,12
  184fac:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  184fb0:	008008b4 	movhi	r2,34
  184fb4:	10860604 	addi	r2,r2,6168
  184fb8:	10800017 	ldw	r2,0(r2)
  184fbc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  184fc0:	00003106 	br	185088 <alt_find_file+0xec>
  {
    len = strlen(next->name);
  184fc4:	e0bffd17 	ldw	r2,-12(fp)
  184fc8:	10800217 	ldw	r2,8(r2)
  184fcc:	1009883a 	mov	r4,r2
  184fd0:	018538c0 	call	18538c <strlen>
  184fd4:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  184fd8:	e0bffd17 	ldw	r2,-12(fp)
  184fdc:	10c00217 	ldw	r3,8(r2)
  184fe0:	e0bffe17 	ldw	r2,-8(fp)
  184fe4:	10bfffc4 	addi	r2,r2,-1
  184fe8:	1885883a 	add	r2,r3,r2
  184fec:	10800003 	ldbu	r2,0(r2)
  184ff0:	10803fcc 	andi	r2,r2,255
  184ff4:	1080201c 	xori	r2,r2,128
  184ff8:	10bfe004 	addi	r2,r2,-128
  184ffc:	10800bd8 	cmpnei	r2,r2,47
  185000:	1000031e 	bne	r2,zero,185010 <alt_find_file+0x74>
    {
      len -= 1;
  185004:	e0bffe17 	ldw	r2,-8(fp)
  185008:	10bfffc4 	addi	r2,r2,-1
  18500c:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  185010:	e0bffe17 	ldw	r2,-8(fp)
  185014:	e0ffff17 	ldw	r3,-4(fp)
  185018:	1885883a 	add	r2,r3,r2
  18501c:	10800003 	ldbu	r2,0(r2)
  185020:	10803fcc 	andi	r2,r2,255
  185024:	1080201c 	xori	r2,r2,128
  185028:	10bfe004 	addi	r2,r2,-128
  18502c:	10800be0 	cmpeqi	r2,r2,47
  185030:	1000081e 	bne	r2,zero,185054 <alt_find_file+0xb8>
  185034:	e0bffe17 	ldw	r2,-8(fp)
  185038:	e0ffff17 	ldw	r3,-4(fp)
  18503c:	1885883a 	add	r2,r3,r2
  185040:	10800003 	ldbu	r2,0(r2)
  185044:	10803fcc 	andi	r2,r2,255
  185048:	1080201c 	xori	r2,r2,128
  18504c:	10bfe004 	addi	r2,r2,-128
  185050:	10000a1e 	bne	r2,zero,18507c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
  185054:	e0bffd17 	ldw	r2,-12(fp)
  185058:	10c00217 	ldw	r3,8(r2)
  18505c:	e0bffe17 	ldw	r2,-8(fp)
  185060:	1809883a 	mov	r4,r3
  185064:	e17fff17 	ldw	r5,-4(fp)
  185068:	100d883a 	mov	r6,r2
  18506c:	01851d00 	call	1851d0 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  185070:	1000021e 	bne	r2,zero,18507c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  185074:	e0bffd17 	ldw	r2,-12(fp)
  185078:	00000806 	br	18509c <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
  18507c:	e0bffd17 	ldw	r2,-12(fp)
  185080:	10800017 	ldw	r2,0(r2)
  185084:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  185088:	e0fffd17 	ldw	r3,-12(fp)
  18508c:	008008b4 	movhi	r2,34
  185090:	10860604 	addi	r2,r2,6168
  185094:	18bfcb1e 	bne	r3,r2,184fc4 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  185098:	0005883a 	mov	r2,zero
}
  18509c:	e037883a 	mov	sp,fp
  1850a0:	dfc00117 	ldw	ra,4(sp)
  1850a4:	df000017 	ldw	fp,0(sp)
  1850a8:	dec00204 	addi	sp,sp,8
  1850ac:	f800283a 	ret

001850b0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  1850b0:	defffa04 	addi	sp,sp,-24
  1850b4:	dfc00515 	stw	ra,20(sp)
  1850b8:	df000415 	stw	fp,16(sp)
  1850bc:	dc000315 	stw	r16,12(sp)
  1850c0:	df000304 	addi	fp,sp,12
  1850c4:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
  1850c8:	00bffa04 	movi	r2,-24
  1850cc:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  1850d0:	e03ffd15 	stw	zero,-12(fp)
  1850d4:	00002106 	br	18515c <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
  1850d8:	040008b4 	movhi	r16,34
  1850dc:	8404a304 	addi	r16,r16,4748
  1850e0:	e0bffd17 	ldw	r2,-12(fp)
  1850e4:	1009883a 	mov	r4,r2
  1850e8:	01400304 	movi	r5,12
  1850ec:	01832700 	call	183270 <__mulsi3>
  1850f0:	8085883a 	add	r2,r16,r2
  1850f4:	10800017 	ldw	r2,0(r2)
  1850f8:	1000151e 	bne	r2,zero,185150 <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
  1850fc:	040008b4 	movhi	r16,34
  185100:	8404a304 	addi	r16,r16,4748
  185104:	e0bffd17 	ldw	r2,-12(fp)
  185108:	1009883a 	mov	r4,r2
  18510c:	01400304 	movi	r5,12
  185110:	01832700 	call	183270 <__mulsi3>
  185114:	8085883a 	add	r2,r16,r2
  185118:	e0ffff17 	ldw	r3,-4(fp)
  18511c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  185120:	008008b4 	movhi	r2,34
  185124:	10860a04 	addi	r2,r2,6184
  185128:	10c00017 	ldw	r3,0(r2)
  18512c:	e0bffd17 	ldw	r2,-12(fp)
  185130:	1880040e 	bge	r3,r2,185144 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
  185134:	008008b4 	movhi	r2,34
  185138:	10860a04 	addi	r2,r2,6184
  18513c:	e0fffd17 	ldw	r3,-12(fp)
  185140:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
  185144:	e0bffd17 	ldw	r2,-12(fp)
  185148:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
  18514c:	00000606 	br	185168 <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  185150:	e0bffd17 	ldw	r2,-12(fp)
  185154:	10800044 	addi	r2,r2,1
  185158:	e0bffd15 	stw	r2,-12(fp)
  18515c:	e0bffd17 	ldw	r2,-12(fp)
  185160:	10800810 	cmplti	r2,r2,32
  185164:	103fdc1e 	bne	r2,zero,1850d8 <alt_get_fd+0x28>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  185168:	e0bffe17 	ldw	r2,-8(fp)
}
  18516c:	e037883a 	mov	sp,fp
  185170:	dfc00217 	ldw	ra,8(sp)
  185174:	df000117 	ldw	fp,4(sp)
  185178:	dc000017 	ldw	r16,0(sp)
  18517c:	dec00304 	addi	sp,sp,12
  185180:	f800283a 	ret

00185184 <atexit>:
  185184:	200b883a 	mov	r5,r4
  185188:	000d883a 	mov	r6,zero
  18518c:	0009883a 	mov	r4,zero
  185190:	000f883a 	mov	r7,zero
  185194:	01854181 	jmpi	185418 <__register_exitproc>

00185198 <exit>:
  185198:	defffe04 	addi	sp,sp,-8
  18519c:	000b883a 	mov	r5,zero
  1851a0:	dc000015 	stw	r16,0(sp)
  1851a4:	dfc00115 	stw	ra,4(sp)
  1851a8:	2021883a 	mov	r16,r4
  1851ac:	01855480 	call	185548 <__call_exitprocs>
  1851b0:	008008b4 	movhi	r2,34
  1851b4:	10860e04 	addi	r2,r2,6200
  1851b8:	11000017 	ldw	r4,0(r2)
  1851bc:	20800f17 	ldw	r2,60(r4)
  1851c0:	10000126 	beq	r2,zero,1851c8 <exit+0x30>
  1851c4:	103ee83a 	callr	r2
  1851c8:	8009883a 	mov	r4,r16
  1851cc:	01856e80 	call	1856e8 <_exit>

001851d0 <memcmp>:
  1851d0:	01c000c4 	movi	r7,3
  1851d4:	3980192e 	bgeu	r7,r6,18523c <memcmp+0x6c>
  1851d8:	2904b03a 	or	r2,r5,r4
  1851dc:	11c4703a 	and	r2,r2,r7
  1851e0:	10000f26 	beq	r2,zero,185220 <memcmp+0x50>
  1851e4:	20c00003 	ldbu	r3,0(r4)
  1851e8:	28800003 	ldbu	r2,0(r5)
  1851ec:	1880151e 	bne	r3,r2,185244 <memcmp+0x74>
  1851f0:	31bfff84 	addi	r6,r6,-2
  1851f4:	01ffffc4 	movi	r7,-1
  1851f8:	00000406 	br	18520c <memcmp+0x3c>
  1851fc:	20c00003 	ldbu	r3,0(r4)
  185200:	28800003 	ldbu	r2,0(r5)
  185204:	31bfffc4 	addi	r6,r6,-1
  185208:	18800e1e 	bne	r3,r2,185244 <memcmp+0x74>
  18520c:	21000044 	addi	r4,r4,1
  185210:	29400044 	addi	r5,r5,1
  185214:	31fff91e 	bne	r6,r7,1851fc <memcmp+0x2c>
  185218:	0005883a 	mov	r2,zero
  18521c:	f800283a 	ret
  185220:	20c00017 	ldw	r3,0(r4)
  185224:	28800017 	ldw	r2,0(r5)
  185228:	1880041e 	bne	r3,r2,18523c <memcmp+0x6c>
  18522c:	31bfff04 	addi	r6,r6,-4
  185230:	21000104 	addi	r4,r4,4
  185234:	29400104 	addi	r5,r5,4
  185238:	39bff936 	bltu	r7,r6,185220 <memcmp+0x50>
  18523c:	303fe91e 	bne	r6,zero,1851e4 <memcmp+0x14>
  185240:	003ff506 	br	185218 <memcmp+0x48>
  185244:	1885c83a 	sub	r2,r3,r2
  185248:	f800283a 	ret

0018524c <memcpy>:
  18524c:	defffb04 	addi	sp,sp,-20
  185250:	dc000015 	stw	r16,0(sp)
  185254:	dfc00415 	stw	ra,16(sp)
  185258:	dcc00315 	stw	r19,12(sp)
  18525c:	dc800215 	stw	r18,8(sp)
  185260:	dc400115 	stw	r17,4(sp)
  185264:	00c003c4 	movi	r3,15
  185268:	2021883a 	mov	r16,r4
  18526c:	3005883a 	mov	r2,r6
  185270:	1980032e 	bgeu	r3,r6,185280 <memcpy+0x34>
  185274:	2906b03a 	or	r3,r5,r4
  185278:	18c000cc 	andi	r3,r3,3
  18527c:	18001026 	beq	r3,zero,1852c0 <memcpy+0x74>
  185280:	8007883a 	mov	r3,r16
  185284:	288f883a 	add	r7,r5,r2
  185288:	10000526 	beq	r2,zero,1852a0 <memcpy+0x54>
  18528c:	29800003 	ldbu	r6,0(r5)
  185290:	18c00044 	addi	r3,r3,1
  185294:	29400044 	addi	r5,r5,1
  185298:	19bfffc5 	stb	r6,-1(r3)
  18529c:	29fffb1e 	bne	r5,r7,18528c <memcpy+0x40>
  1852a0:	8005883a 	mov	r2,r16
  1852a4:	dfc00417 	ldw	ra,16(sp)
  1852a8:	dcc00317 	ldw	r19,12(sp)
  1852ac:	dc800217 	ldw	r18,8(sp)
  1852b0:	dc400117 	ldw	r17,4(sp)
  1852b4:	dc000017 	ldw	r16,0(sp)
  1852b8:	dec00504 	addi	sp,sp,20
  1852bc:	f800283a 	ret
  1852c0:	32bffc04 	addi	r10,r6,-16
  1852c4:	5014d13a 	srli	r10,r10,4
  1852c8:	20800404 	addi	r2,r4,16
  1852cc:	2007883a 	mov	r3,r4
  1852d0:	5008913a 	slli	r4,r10,4
  1852d4:	280f883a 	mov	r7,r5
  1852d8:	1105883a 	add	r2,r2,r4
  1852dc:	3a000017 	ldw	r8,0(r7)
  1852e0:	18c00404 	addi	r3,r3,16
  1852e4:	39c00404 	addi	r7,r7,16
  1852e8:	1a3ffc15 	stw	r8,-16(r3)
  1852ec:	3a3ffd17 	ldw	r8,-12(r7)
  1852f0:	1a3ffd15 	stw	r8,-12(r3)
  1852f4:	3a3ffe17 	ldw	r8,-8(r7)
  1852f8:	1a3ffe15 	stw	r8,-8(r3)
  1852fc:	3a3fff17 	ldw	r8,-4(r7)
  185300:	1a3fff15 	stw	r8,-4(r3)
  185304:	18bff51e 	bne	r3,r2,1852dc <memcpy+0x90>
  185308:	52800044 	addi	r10,r10,1
  18530c:	5014913a 	slli	r10,r10,4
  185310:	308003cc 	andi	r2,r6,15
  185314:	010000c4 	movi	r4,3
  185318:	8287883a 	add	r3,r16,r10
  18531c:	2a95883a 	add	r10,r5,r10
  185320:	2080182e 	bgeu	r4,r2,185384 <memcpy+0x138>
  185324:	147fff04 	addi	r17,r2,-4
  185328:	8808d0ba 	srli	r4,r17,2
  18532c:	1a400104 	addi	r9,r3,4
  185330:	180d883a 	mov	r6,r3
  185334:	2105883a 	add	r2,r4,r4
  185338:	1085883a 	add	r2,r2,r2
  18533c:	4893883a 	add	r9,r9,r2
  185340:	500f883a 	mov	r7,r10
  185344:	3a000017 	ldw	r8,0(r7)
  185348:	31800104 	addi	r6,r6,4
  18534c:	39c00104 	addi	r7,r7,4
  185350:	323fff15 	stw	r8,-4(r6)
  185354:	327ffb1e 	bne	r6,r9,185344 <memcpy+0xf8>
  185358:	20800044 	addi	r2,r4,1
  18535c:	1085883a 	add	r2,r2,r2
  185360:	1085883a 	add	r2,r2,r2
  185364:	017fff04 	movi	r5,-4
  185368:	18a5883a 	add	r18,r3,r2
  18536c:	50a7883a 	add	r19,r10,r2
  185370:	01832700 	call	183270 <__mulsi3>
  185374:	1445883a 	add	r2,r2,r17
  185378:	980b883a 	mov	r5,r19
  18537c:	9007883a 	mov	r3,r18
  185380:	003fc006 	br	185284 <memcpy+0x38>
  185384:	500b883a 	mov	r5,r10
  185388:	003fbe06 	br	185284 <memcpy+0x38>

0018538c <strlen>:
  18538c:	208000cc 	andi	r2,r4,3
  185390:	10001f1e 	bne	r2,zero,185410 <strlen+0x84>
  185394:	20800017 	ldw	r2,0(r4)
  185398:	01ffbff4 	movhi	r7,65279
  18539c:	39ffbfc4 	addi	r7,r7,-257
  1853a0:	01a02074 	movhi	r6,32897
  1853a4:	31a02004 	addi	r6,r6,-32640
  1853a8:	11c7883a 	add	r3,r2,r7
  1853ac:	0084303a 	nor	r2,zero,r2
  1853b0:	1886703a 	and	r3,r3,r2
  1853b4:	1986703a 	and	r3,r3,r6
  1853b8:	2005883a 	mov	r2,r4
  1853bc:	1800101e 	bne	r3,zero,185400 <strlen+0x74>
  1853c0:	10800104 	addi	r2,r2,4
  1853c4:	10c00017 	ldw	r3,0(r2)
  1853c8:	19cb883a 	add	r5,r3,r7
  1853cc:	00c6303a 	nor	r3,zero,r3
  1853d0:	28c6703a 	and	r3,r5,r3
  1853d4:	1986703a 	and	r3,r3,r6
  1853d8:	1800091e 	bne	r3,zero,185400 <strlen+0x74>
  1853dc:	10800104 	addi	r2,r2,4
  1853e0:	10c00017 	ldw	r3,0(r2)
  1853e4:	19cb883a 	add	r5,r3,r7
  1853e8:	00c6303a 	nor	r3,zero,r3
  1853ec:	28c6703a 	and	r3,r5,r3
  1853f0:	1986703a 	and	r3,r3,r6
  1853f4:	183ff226 	beq	r3,zero,1853c0 <strlen+0x34>
  1853f8:	00000106 	br	185400 <strlen+0x74>
  1853fc:	10800044 	addi	r2,r2,1
  185400:	10c00007 	ldb	r3,0(r2)
  185404:	183ffd1e 	bne	r3,zero,1853fc <strlen+0x70>
  185408:	1105c83a 	sub	r2,r2,r4
  18540c:	f800283a 	ret
  185410:	2005883a 	mov	r2,r4
  185414:	003ffa06 	br	185400 <strlen+0x74>

00185418 <__register_exitproc>:
  185418:	defffa04 	addi	sp,sp,-24
  18541c:	008008b4 	movhi	r2,34
  185420:	10860e04 	addi	r2,r2,6200
  185424:	dc000315 	stw	r16,12(sp)
  185428:	14000017 	ldw	r16,0(r2)
  18542c:	dc400415 	stw	r17,16(sp)
  185430:	dfc00515 	stw	ra,20(sp)
  185434:	80805217 	ldw	r2,328(r16)
  185438:	2023883a 	mov	r17,r4
  18543c:	10003e26 	beq	r2,zero,185538 <__register_exitproc+0x120>
  185440:	10c00117 	ldw	r3,4(r2)
  185444:	020007c4 	movi	r8,31
  185448:	40c0180e 	bge	r8,r3,1854ac <__register_exitproc+0x94>
  18544c:	00800034 	movhi	r2,0
  185450:	10800004 	addi	r2,r2,0
  185454:	1000061e 	bne	r2,zero,185470 <__register_exitproc+0x58>
  185458:	00bfffc4 	movi	r2,-1
  18545c:	dfc00517 	ldw	ra,20(sp)
  185460:	dc400417 	ldw	r17,16(sp)
  185464:	dc000317 	ldw	r16,12(sp)
  185468:	dec00604 	addi	sp,sp,24
  18546c:	f800283a 	ret
  185470:	01006404 	movi	r4,400
  185474:	d9400015 	stw	r5,0(sp)
  185478:	d9800115 	stw	r6,4(sp)
  18547c:	d9c00215 	stw	r7,8(sp)
  185480:	00000000 	call	0 <__alt_mem_vram>
  185484:	d9400017 	ldw	r5,0(sp)
  185488:	d9800117 	ldw	r6,4(sp)
  18548c:	d9c00217 	ldw	r7,8(sp)
  185490:	103ff126 	beq	r2,zero,185458 <__register_exitproc+0x40>
  185494:	80c05217 	ldw	r3,328(r16)
  185498:	10000115 	stw	zero,4(r2)
  18549c:	10c00015 	stw	r3,0(r2)
  1854a0:	80805215 	stw	r2,328(r16)
  1854a4:	10006215 	stw	zero,392(r2)
  1854a8:	10006315 	stw	zero,396(r2)
  1854ac:	10c00117 	ldw	r3,4(r2)
  1854b0:	88000d1e 	bne	r17,zero,1854e8 <__register_exitproc+0xd0>
  1854b4:	19000084 	addi	r4,r3,2
  1854b8:	2109883a 	add	r4,r4,r4
  1854bc:	18c00044 	addi	r3,r3,1
  1854c0:	2109883a 	add	r4,r4,r4
  1854c4:	1109883a 	add	r4,r2,r4
  1854c8:	10c00115 	stw	r3,4(r2)
  1854cc:	0005883a 	mov	r2,zero
  1854d0:	21400015 	stw	r5,0(r4)
  1854d4:	dfc00517 	ldw	ra,20(sp)
  1854d8:	dc400417 	ldw	r17,16(sp)
  1854dc:	dc000317 	ldw	r16,12(sp)
  1854e0:	dec00604 	addi	sp,sp,24
  1854e4:	f800283a 	ret
  1854e8:	02400044 	movi	r9,1
  1854ec:	12806217 	ldw	r10,392(r2)
  1854f0:	48d2983a 	sll	r9,r9,r3
  1854f4:	19000804 	addi	r4,r3,32
  1854f8:	18d1883a 	add	r8,r3,r3
  1854fc:	2109883a 	add	r4,r4,r4
  185500:	4211883a 	add	r8,r8,r8
  185504:	2109883a 	add	r4,r4,r4
  185508:	1109883a 	add	r4,r2,r4
  18550c:	1211883a 	add	r8,r2,r8
  185510:	5254b03a 	or	r10,r10,r9
  185514:	21c02215 	stw	r7,136(r4)
  185518:	41802215 	stw	r6,136(r8)
  18551c:	12806215 	stw	r10,392(r2)
  185520:	01000084 	movi	r4,2
  185524:	893fe31e 	bne	r17,r4,1854b4 <__register_exitproc+0x9c>
  185528:	11006317 	ldw	r4,396(r2)
  18552c:	2252b03a 	or	r9,r4,r9
  185530:	12406315 	stw	r9,396(r2)
  185534:	003fdf06 	br	1854b4 <__register_exitproc+0x9c>
  185538:	008008b4 	movhi	r2,34
  18553c:	1089d404 	addi	r2,r2,10064
  185540:	80805215 	stw	r2,328(r16)
  185544:	003fbe06 	br	185440 <__register_exitproc+0x28>

00185548 <__call_exitprocs>:
  185548:	008008b4 	movhi	r2,34
  18554c:	10860e04 	addi	r2,r2,6200
  185550:	10800017 	ldw	r2,0(r2)
  185554:	defff304 	addi	sp,sp,-52
  185558:	df000b15 	stw	fp,44(sp)
  18555c:	d8800015 	stw	r2,0(sp)
  185560:	10805204 	addi	r2,r2,328
  185564:	dd400815 	stw	r21,32(sp)
  185568:	dfc00c15 	stw	ra,48(sp)
  18556c:	ddc00a15 	stw	r23,40(sp)
  185570:	dd800915 	stw	r22,36(sp)
  185574:	dd000715 	stw	r20,28(sp)
  185578:	dcc00615 	stw	r19,24(sp)
  18557c:	dc800515 	stw	r18,20(sp)
  185580:	dc400415 	stw	r17,16(sp)
  185584:	dc000315 	stw	r16,12(sp)
  185588:	d9000115 	stw	r4,4(sp)
  18558c:	2839883a 	mov	fp,r5
  185590:	d8800215 	stw	r2,8(sp)
  185594:	057fffc4 	movi	r21,-1
  185598:	d8800017 	ldw	r2,0(sp)
  18559c:	ddc00217 	ldw	r23,8(sp)
  1855a0:	14805217 	ldw	r18,328(r2)
  1855a4:	90001726 	beq	r18,zero,185604 <__call_exitprocs+0xbc>
  1855a8:	94400117 	ldw	r17,4(r18)
  1855ac:	8c3fffc4 	addi	r16,r17,-1
  1855b0:	80001116 	blt	r16,zero,1855f8 <__call_exitprocs+0xb0>
  1855b4:	8c400044 	addi	r17,r17,1
  1855b8:	8427883a 	add	r19,r16,r16
  1855bc:	8c63883a 	add	r17,r17,r17
  1855c0:	95802204 	addi	r22,r18,136
  1855c4:	9ce7883a 	add	r19,r19,r19
  1855c8:	8c63883a 	add	r17,r17,r17
  1855cc:	b4e7883a 	add	r19,r22,r19
  1855d0:	9463883a 	add	r17,r18,r17
  1855d4:	e0001726 	beq	fp,zero,185634 <__call_exitprocs+0xec>
  1855d8:	8c87c83a 	sub	r3,r17,r18
  1855dc:	b0c7883a 	add	r3,r22,r3
  1855e0:	18c01e17 	ldw	r3,120(r3)
  1855e4:	1f001326 	beq	r3,fp,185634 <__call_exitprocs+0xec>
  1855e8:	843fffc4 	addi	r16,r16,-1
  1855ec:	9cffff04 	addi	r19,r19,-4
  1855f0:	8c7fff04 	addi	r17,r17,-4
  1855f4:	857ff71e 	bne	r16,r21,1855d4 <__call_exitprocs+0x8c>
  1855f8:	00800034 	movhi	r2,0
  1855fc:	10800004 	addi	r2,r2,0
  185600:	10002a1e 	bne	r2,zero,1856ac <__call_exitprocs+0x164>
  185604:	dfc00c17 	ldw	ra,48(sp)
  185608:	df000b17 	ldw	fp,44(sp)
  18560c:	ddc00a17 	ldw	r23,40(sp)
  185610:	dd800917 	ldw	r22,36(sp)
  185614:	dd400817 	ldw	r21,32(sp)
  185618:	dd000717 	ldw	r20,28(sp)
  18561c:	dcc00617 	ldw	r19,24(sp)
  185620:	dc800517 	ldw	r18,20(sp)
  185624:	dc400417 	ldw	r17,16(sp)
  185628:	dc000317 	ldw	r16,12(sp)
  18562c:	dec00d04 	addi	sp,sp,52
  185630:	f800283a 	ret
  185634:	91000117 	ldw	r4,4(r18)
  185638:	88c00017 	ldw	r3,0(r17)
  18563c:	213fffc4 	addi	r4,r4,-1
  185640:	24001526 	beq	r4,r16,185698 <__call_exitprocs+0x150>
  185644:	88000015 	stw	zero,0(r17)
  185648:	183fe726 	beq	r3,zero,1855e8 <__call_exitprocs+0xa0>
  18564c:	00800044 	movi	r2,1
  185650:	1408983a 	sll	r4,r2,r16
  185654:	91406217 	ldw	r5,392(r18)
  185658:	95000117 	ldw	r20,4(r18)
  18565c:	214a703a 	and	r5,r4,r5
  185660:	28000b26 	beq	r5,zero,185690 <__call_exitprocs+0x148>
  185664:	91406317 	ldw	r5,396(r18)
  185668:	2148703a 	and	r4,r4,r5
  18566c:	20000c1e 	bne	r4,zero,1856a0 <__call_exitprocs+0x158>
  185670:	99400017 	ldw	r5,0(r19)
  185674:	d9000117 	ldw	r4,4(sp)
  185678:	183ee83a 	callr	r3
  18567c:	90c00117 	ldw	r3,4(r18)
  185680:	1d3fc51e 	bne	r3,r20,185598 <__call_exitprocs+0x50>
  185684:	b8c00017 	ldw	r3,0(r23)
  185688:	1cbfd726 	beq	r3,r18,1855e8 <__call_exitprocs+0xa0>
  18568c:	003fc206 	br	185598 <__call_exitprocs+0x50>
  185690:	183ee83a 	callr	r3
  185694:	003ff906 	br	18567c <__call_exitprocs+0x134>
  185698:	94000115 	stw	r16,4(r18)
  18569c:	003fea06 	br	185648 <__call_exitprocs+0x100>
  1856a0:	99000017 	ldw	r4,0(r19)
  1856a4:	183ee83a 	callr	r3
  1856a8:	003ff406 	br	18567c <__call_exitprocs+0x134>
  1856ac:	90c00117 	ldw	r3,4(r18)
  1856b0:	1800071e 	bne	r3,zero,1856d0 <__call_exitprocs+0x188>
  1856b4:	90c00017 	ldw	r3,0(r18)
  1856b8:	18000926 	beq	r3,zero,1856e0 <__call_exitprocs+0x198>
  1856bc:	9009883a 	mov	r4,r18
  1856c0:	b8c00015 	stw	r3,0(r23)
  1856c4:	00000000 	call	0 <__alt_mem_vram>
  1856c8:	bc800017 	ldw	r18,0(r23)
  1856cc:	003fb506 	br	1855a4 <__call_exitprocs+0x5c>
  1856d0:	90c00017 	ldw	r3,0(r18)
  1856d4:	902f883a 	mov	r23,r18
  1856d8:	1825883a 	mov	r18,r3
  1856dc:	003fb106 	br	1855a4 <__call_exitprocs+0x5c>
  1856e0:	0007883a 	mov	r3,zero
  1856e4:	003ffb06 	br	1856d4 <__call_exitprocs+0x18c>

001856e8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  1856e8:	defffc04 	addi	sp,sp,-16
  1856ec:	df000315 	stw	fp,12(sp)
  1856f0:	df000304 	addi	fp,sp,12
  1856f4:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  1856f8:	0001883a 	nop
  1856fc:	e0bfff17 	ldw	r2,-4(fp)
  185700:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
  185704:	e0bffd17 	ldw	r2,-12(fp)
  185708:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  18570c:	e0bffe17 	ldw	r2,-8(fp)
  185710:	10000226 	beq	r2,zero,18571c <_exit+0x34>
    ALT_SIM_FAIL();
  185714:	002af070 	cmpltui	zero,zero,43969
  185718:	00000106 	br	185720 <_exit+0x38>
  } else {
    ALT_SIM_PASS();
  18571c:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  185720:	003fff06 	br	185720 <_exit+0x38>
