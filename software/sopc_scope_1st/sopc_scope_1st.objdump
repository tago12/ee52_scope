
sopc_scope_1st.elf:     file format elf32-littlenios2
sopc_scope_1st.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x000101b8

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00010020 paddr 0x00010020 align 2**12
         filesz 0x00005658 memsz 0x00005658 flags r-x
    LOAD off    0x00006678 vaddr 0x00015678 paddr 0x00016cb4 align 2**12
         filesz 0x0000163c memsz 0x0000163c flags rw-
    LOAD off    0x000082f0 vaddr 0x000182f0 paddr 0x000182f0 align 2**12
         filesz 0x00000000 memsz 0x000007e0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00010000  00010000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000198  00010020  00010020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00004c10  000101b8  000101b8  000011b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000008b0  00014dc8  00014dc8  00005dc8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000163c  00015678  00016cb4  00006678  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000007e0  000182f0  000182f0  000082f0  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  00007cb4  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000006a8  00000000  00000000  00007cd8  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00009324  00000000  00000000  00008380  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00003126  00000000  00000000  000116a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000032a7  00000000  00000000  000147ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00001128  00000000  00000000  00017a74  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00001cd2  00000000  00000000  00018b9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00001f56  00000000  00000000  0001a86e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000030  00000000  00000000  0001c7c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000118  00000000  00000000  0001c7f8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000003  00000000  00000000  0001f00c  2**0
                  CONTENTS, READONLY
 17 .cpu          00000004  00000000  00000000  0001f00f  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  0001f013  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  0001f014  2**0
                  CONTENTS, READONLY
 20 .stderr_dev   00000004  00000000  00000000  0001f015  2**0
                  CONTENTS, READONLY
 21 .stdin_dev    00000004  00000000  00000000  0001f019  2**0
                  CONTENTS, READONLY
 22 .stdout_dev   00000004  00000000  00000000  0001f01d  2**0
                  CONTENTS, READONLY
 23 .sopc_system_name 0000000e  00000000  00000000  0001f021  2**0
                  CONTENTS, READONLY
 24 .quartus_project_dir 00000026  00000000  00000000  0001f02f  2**0
                  CONTENTS, READONLY
 25 .sopcinfo     00026d4a  00000000  00000000  0001f055  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00010000 l    d  .entry	00000000 .entry
00010020 l    d  .exceptions	00000000 .exceptions
000101b8 l    d  .text	00000000 .text
00014dc8 l    d  .rodata	00000000 .rodata
00015678 l    d  .rwdata	00000000 .rwdata
000182f0 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 C:/Users/tago/Dropbox/OUT/EE52/software/sopc_scope_1st_bsp//obj/HAL/src/crt0.o
00010200 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00010094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 char58.c
00000000 l    df *ABS*	00000000 keyproc.c
00000000 l    df *ABS*	00000000 lcdout.c
00000000 l    df *ABS*	00000000 mainloop.c
000107dc l     F .text	0000008c key_lookup
000151f4 l     O .rodata	00000030 process_key.1648
000151c8 l     O .rodata	00000014 keys.1653
000151dc l     O .rodata	00000018 keycodes.1652
00000000 l    df *ABS*	00000000 menu.c
000182f0 l     O .bss	00000004 menu_display
0001525c l     O .rodata	00000070 menu
000182f4 l     O .bss	00000004 menu_entry
00010c34 l     F .text	000000d0 display_entry
000152e8 l     O .rodata	0000001c process.1663
000152cc l     O .rodata	0000001c process.1668
00000000 l    df *ABS*	00000000 menuact.c
000182f8 l     O .bss	00000004 trigger_mode
000182fc l     O .bss	00000004 scale
00018300 l     O .bss	00000004 sweep
00018304 l     O .bss	00000004 level
00018308 l     O .bss	00000004 slope
0001830c l     O .bss	00000004 delay
0001538c l     O .rodata	00000088 sweep_rates
00015464 l     O .rodata	0000000c modes.1636
00015434 l     O .rodata	0000000c scale_stat.1649
00011578 l     F .text	000000c0 adjust_trg_delay
00011854 l     F .text	00000198 cvt_num_field
00016c80 l     O .rwdata	00000008 slopes.1689
00000000 l    df *ABS*	00000000 stubfncs.c
00000000 l    df *ABS*	00000000 testcode.c
00015470 l     O .rodata	000001e0 waveform.1500
00000000 l    df *ABS*	00000000 tracutil.c
00018310 l     O .bss	00000004 trace_status
00018314 l     O .bss	00000004 sampling
00018318 l     O .bss	00000004 sample_size
0001831c l     O .bss	00000004 cur_scale
0001834c l     O .bss	000000b4 saved_axis_x
00018400 l     O .bss	000000b0 saved_axis_y
000184b0 l     O .bss	000002a0 saved_menu
00018750 l     O .bss	000000f0 saved_area
00018320 l     O .bss	00000004 saved_pos_x
00018324 l     O .bss	00000004 saved_pos_y
00018328 l     O .bss	00000004 saved_end_x
0001832c l     O .bss	00000004 saved_end_y
00000000 l    df *ABS*	00000000 lib2-divmod.c
00012ab8 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 alt_load.c
00012be8 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00012d4c l     F .text	00000038 alt_dev_reg
00015678 l     O .rwdata	00001060 jtag
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00013020 l     F .text	00000204 altera_avalon_jtag_uart_irq
00013224 l     F .text	000000a4 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
000139a0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
00013afc l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00013b28 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00013fc8 l     F .text	000000c0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
00014100 l     F .text	00000050 alt_get_errno
00014150 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 impure.c
00016880 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
00012cd4 g     F .text	00000078 alt_main
00018840 g     O .bss	00000100 alt_irq
000114e4 g     F .text	00000048 trg_delay_down
00016cb4 g       *ABS*	00000000 __flash_rwdata_start
00010fe8 g     F .text	00000068 display_scale
00011d8c g     F .text	00000028 trace_rearm
00011b0c g     F .text	00000020 sample_done
00010d90 g     F .text	00000020 get_trigger_mode
00010d04 g     F .text	00000020 no_menu_action
00011ac4 g     F .text	00000024 set_delay
00000000  w      *UND*	00000000 __errno
00010000 g     F .entry	0000001c __reset
00010020 g       *ABS*	00000000 __flash_exceptions_start
00010204 g     F .text	00000024 no_action
00018348 g     O .bss	00000004 errno
00010308 g     F .text	00000030 menu_right
0001121c g     F .text	00000048 set_trg_level
00018334 g     O .bss	00000004 alt_argv
00010868 g     F .text	00000064 init_menu
0001ec80 g       *ABS*	00000000 _gp
00011cf4 g     F .text	00000020 is_sampling
000102d8 g     F .text	00000030 menu_left
00016700 g     O .rwdata	00000180 alt_fd_list
0001458c g     F .text	00000090 alt_find_dev
00014938 g     F .text	000000f8 memcpy
00010000 g       *ABS*	00000000 __alt_mem_temp_ram
00014088 g     F .text	00000078 alt_io_redirect
000112b4 g     F .text	00000054 trg_level_up
00014dc8 g       *ABS*	00000000 __DTOR_END__
00010d50 g     F .text	00000040 set_trigger_mode
00011a4c g     F .text	0000002c plot_pixel
00013424 g     F .text	00000218 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
00012bd8 g     F .text	00000008 __udivsi3
00012510 g     F .text	00000110 restore_trace
000147e4 g     F .text	0000008c alt_icache_flush
00012450 g     F .text	000000c0 set_save_area
00011ae8 g     F .text	00000024 start_sample
00010f20 g     F .text	00000064 scale_down
00016c98 g     O .rwdata	00000004 alt_max_fd
000119ec g     F .text	00000020 key_available
000111b4 g     F .text	00000068 display_sweep
00011de0 g     F .text	000003cc set_display_scale
00012620 g     F .text	00000048 do_trace
00016cac g     O .rwdata	00000004 _global_impure_ptr
00018ad0 g       *ABS*	00000000 __bss_end
00013ed8 g     F .text	000000f0 alt_iic_isr_register
00014468 g     F .text	00000104 alt_tick
00011c58 g     F .text	00000064 init_trace
00013e8c g     F .text	0000004c alt_ic_irq_enabled
000114a4 g     F .text	00000040 set_trg_delay
000143d0 g     F .text	00000098 alt_alarm_stop
000102a8 g     F .text	00000030 menu_down
0001833c g     O .bss	00000004 alt_irq_active
00011b2c g     F .text	0000012c get_test_sample
000100ec g     F .exceptions	000000cc alt_irq_handler
000166d8 g     O .rwdata	00000028 alt_dev_null
00010338 g     F .text	000000a8 clear_region
00014dc8 g     O .rodata	00000400 char_patterns
00013ab8 g     F .text	00000044 alt_dcache_flush_all
00010a88 g     F .text	0000006c previous_entry
00016cb4 g       *ABS*	00000000 __ram_rwdata_end
00016c90 g     O .rwdata	00000008 alt_dev_list
00011cbc g     F .text	00000038 set_mode
00015678 g       *ABS*	00000000 __ram_rodata_end
00012be0 g     F .text	00000008 __umodsi3
00010e78 g     F .text	00000068 display_mode
00018ad0 g       *ABS*	00000000 end
00010d24 g     F .text	0000002c no_display
00011308 g     F .text	0000009c display_trg_level
00011130 g     F .text	00000084 sweep_up
000109bc g     F .text	0000005c reset_menu
000108cc g     F .text	00000038 clear_menu
00012f60 g     F .text	000000c0 altera_avalon_jtag_uart_init
0001152c g     F .text	0000004c trg_delay_up
00014dc8 g       *ABS*	00000000 __CTOR_LIST__
00019ca0 g       *ABS*	00000000 __alt_stack_pointer
0001363c g     F .text	00000224 altera_avalon_jtag_uart_write
00014bec g     F .text	000001a0 __call_exitprocs
000101b8 g     F .text	0000004c _start
00018340 g     O .bss	00000004 _alt_tick_rate
00018344 g     O .bss	00000004 _alt_nticks
000113ec g     F .text	00000054 trg_slope_toggle
00012db8 g     F .text	00000044 alt_sys_init
00014abc g     F .text	00000130 __register_exitproc
000132c8 g     F .text	00000068 altera_avalon_jtag_uart_close
00015678 g       *ABS*	00000000 __ram_rwdata_start
00014dc8 g       *ABS*	00000000 __ram_rodata_start
00012dfc g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00014730 g     F .text	000000b4 alt_get_fd
00011a2c g     F .text	00000020 clear_display
000148bc g     F .text	0000007c memcmp
00012ebc g     F .text	00000050 altera_avalon_jtag_uart_close_fd
00018ad0 g       *ABS*	00000000 __alt_stack_base
00012f0c g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0001234c g     F .text	00000104 restore_menu_trace
0001461c g     F .text	00000114 alt_find_file
00013b78 g     F .text	000000a0 alt_dev_llist_insert
00011db4 g     F .text	0000002c set_trace_size
000106a0 g     F .text	00000098 plot_string
000182f0 g       *ABS*	00000000 __bss_start
00010738 g     F .text	000000a4 main
00018338 g     O .bss	00000004 alt_envp
00012e5c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00012668 g     F .text	00000450 plot_trace
00018940 g     O .bss	00000190 _atexit0
000110b0 g     F .text	00000080 sweep_down
00016c9c g     O .rwdata	00000004 alt_errno
00010db0 g     F .text	00000064 mode_down
00011a78 g     F .text	00000024 set_sample_rate
00012b2c g     F .text	00000050 __divsi3
00011a9c g     F .text	00000028 set_trigger
00014dc8 g       *ABS*	00000000 __CTOR_END__
00010984 g     F .text	00000038 refresh_menu
00014dc8 g       *ABS*	00000000 __flash_rodata_start
00014dc8 g       *ABS*	00000000 __DTOR_LIST__
00010278 g     F .text	00000030 menu_up
00010b94 g     F .text	000000a0 menu_entry_right
00012d84 g     F .text	00000034 alt_irq_init
00014370 g     F .text	00000060 alt_release_fd
00014870 g     F .text	00000014 atexit
00011d4c g     F .text	00000040 trace_done
00016cb0 g     O .rwdata	00000004 _impure_ptr
00018330 g     O .bss	00000004 alt_argc
000113a4 g     F .text	00000048 set_trg_slope
00011264 g     F .text	00000050 trg_level_down
00013c74 g     F .text	0000005c _do_dtors
00011a0c g     F .text	00000020 getkey
00010538 g     F .text	00000168 plot_char
00010020 g       .exceptions	00000000 alt_irq_entry
00010af4 g     F .text	000000a0 menu_entry_left
00016c88 g     O .rwdata	00000008 alt_fs_list
000121ac g     F .text	000001a0 clear_saved_areas
000103e0 g     F .text	000000ac plot_hline
00010020 g       *ABS*	00000000 __ram_exceptions_start
00010ee0 g     F .text	00000040 set_scale
00013d00 g     F .text	00000050 alt_ic_isr_register
00016cb4 g       *ABS*	00000000 _edata
00018ad0 g       *ABS*	00000000 _end
00010e14 g     F .text	00000064 mode_up
000101b8 g       *ABS*	00000000 __ram_exceptions_end
00013330 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
00013dec g     F .text	000000a0 alt_ic_irq_disable
0001456c g     F .text	00000020 altera_nios2_qsys_irq_init
00014884 g     F .text	00000038 exit
00011638 g     F .text	0000021c display_trg_delay
00012b7c g     F .text	0000005c __modsi3
00019ca0 g       *ABS*	00000000 __alt_data_end
00010020 g     F .exceptions	00000000 alt_exception
00011440 g     F .text	00000064 display_trg_slope
00014d8c g     F .text	0000003c _exit
00013860 g     F .text	00000140 alt_alarm_start
00014a30 g     F .text	0000008c strlen
0001421c g     F .text	00000154 open
00013cd0 g     F .text	00000030 alt_icache_flush_all
00016ca0 g     O .rwdata	00000004 alt_priority_mask
00013d50 g     F .text	0000009c alt_ic_irq_enable
0001048c g     F .text	000000ac plot_vline
00010904 g     F .text	00000080 display_menu
00016ca4 g     O .rwdata	00000008 alt_alarm_list
00013c18 g     F .text	0000005c _do_ctors
00010a18 g     F .text	00000070 next_entry
000139f0 g     F .text	000000c8 close
00011d14 g     F .text	00000038 trace_rdy
00012c54 g     F .text	00000080 alt_load
00011050 g     F .text	00000060 set_sweep
00010f84 g     F .text	00000064 scale_up
00010228 g     F .text	00000050 menu_key
00000000  w      *UND*	00000000 free



Disassembly of section .entry:

00010000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   10000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
   10004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   10008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   1000c:	00bffd16 	blt	zero,r2,10004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   10010:	00400074 	movhi	at,1
    ori r1, r1, %lo(_start)
   10014:	08406e14 	ori	at,at,440
    jmp r1
   10018:	0800683a 	jmp	at
   1001c:	00000000 	call	0 <__reset-0x10000>

Disassembly of section .exceptions:

00010020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   10020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   10024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   10028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   1002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   10030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   10034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   10038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   1003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   10040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   10044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   10048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   1004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   10050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   10054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   10058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   1005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   10060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   10064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   10068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   1006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   10070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   10074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   10078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   1007c:	10000326 	beq	r2,zero,1008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   10080:	20000226 	beq	r4,zero,1008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   10084:	00100ec0 	call	100ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   10088:	00000306 	br	10098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
   1008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
   10090:	e8bfff17 	ldw	r2,-4(ea)

00010094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
   10094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   10098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   1009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   100a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   100a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   100a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   100ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   100b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   100b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   100b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   100bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   100c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   100c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   100c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   100cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   100d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   100d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   100d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   100dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   100e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   100e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   100e8:	ef80083a 	eret

000100ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   100ec:	defff904 	addi	sp,sp,-28
   100f0:	dfc00615 	stw	ra,24(sp)
   100f4:	df000515 	stw	fp,20(sp)
   100f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
   100fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   10100:	0005313a 	rdctl	r2,ipending
   10104:	e0bffe15 	stw	r2,-8(fp)

  return active;
   10108:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
   1010c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
   10110:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
   10114:	00800044 	movi	r2,1
   10118:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   1011c:	e0fffb17 	ldw	r3,-20(fp)
   10120:	e0bffc17 	ldw	r2,-16(fp)
   10124:	1884703a 	and	r2,r3,r2
   10128:	10001726 	beq	r2,zero,10188 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   1012c:	00c000b4 	movhi	r3,2
   10130:	18e21004 	addi	r3,r3,-30656
   10134:	e0bffd17 	ldw	r2,-12(fp)
   10138:	100490fa 	slli	r2,r2,3
   1013c:	1885883a 	add	r2,r3,r2
   10140:	10c00017 	ldw	r3,0(r2)
   10144:	010000b4 	movhi	r4,2
   10148:	21221004 	addi	r4,r4,-30656
   1014c:	e0bffd17 	ldw	r2,-12(fp)
   10150:	100490fa 	slli	r2,r2,3
   10154:	2085883a 	add	r2,r4,r2
   10158:	10800104 	addi	r2,r2,4
   1015c:	10800017 	ldw	r2,0(r2)
   10160:	1009883a 	mov	r4,r2
   10164:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
   10168:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   1016c:	0005313a 	rdctl	r2,ipending
   10170:	e0bfff15 	stw	r2,-4(fp)

  return active;
   10174:	e0bfff17 	ldw	r2,-4(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
   10178:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
   1017c:	e0bffb17 	ldw	r2,-20(fp)
   10180:	103fe31e 	bne	r2,zero,10110 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
   10184:	00000706 	br	101a4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
   10188:	e0bffc17 	ldw	r2,-16(fp)
   1018c:	1085883a 	add	r2,r2,r2
   10190:	e0bffc15 	stw	r2,-16(fp)
      i++;
   10194:	e0bffd17 	ldw	r2,-12(fp)
   10198:	10800044 	addi	r2,r2,1
   1019c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
   101a0:	003fde06 	br	1011c <alt_irq_handler+0x30>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
   101a4:	e037883a 	mov	sp,fp
   101a8:	dfc00117 	ldw	ra,4(sp)
   101ac:	df000017 	ldw	fp,0(sp)
   101b0:	dec00204 	addi	sp,sp,8
   101b4:	f800283a 	ret

Disassembly of section .text:

000101b8 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
   101b8:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
   101bc:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
   101c0:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
   101c4:	00bffd16 	blt	zero,r2,101bc <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   101c8:	06c00074 	movhi	sp,1
    ori sp, sp, %lo(__alt_stack_pointer)
   101cc:	dee72814 	ori	sp,sp,40096
    movhi gp, %hi(_gp)
   101d0:	06800074 	movhi	gp,1
    ori gp, gp, %lo(_gp)
   101d4:	d6bb2014 	ori	gp,gp,60544
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   101d8:	00800074 	movhi	r2,1
    ori r2, r2, %lo(__bss_start)
   101dc:	10a0bc14 	ori	r2,r2,33520

    movhi r3, %hi(__bss_end)
   101e0:	00c00074 	movhi	r3,1
    ori r3, r3, %lo(__bss_end)
   101e4:	18e2b414 	ori	r3,r3,35536

    beq r2, r3, 1f
   101e8:	10c00326 	beq	r2,r3,101f8 <_start+0x40>

0:
    stw zero, (r2)
   101ec:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   101f0:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   101f4:	10fffd36 	bltu	r2,r3,101ec <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   101f8:	0012c540 	call	12c54 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   101fc:	0012cd40 	call	12cd4 <alt_main>

00010200 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   10200:	003fff06 	br	10200 <alt_after_alt_main>

00010204 <no_action>:
   Last Modified:    Mar. 8, 1994

*/

enum status  no_action(enum status cur_state)
{
   10204:	defffe04 	addi	sp,sp,-8
   10208:	df000115 	stw	fp,4(sp)
   1020c:	df000104 	addi	fp,sp,4
   10210:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* return the current state */
    return  cur_state;
   10214:	e0bfff17 	ldw	r2,-4(fp)

}
   10218:	e037883a 	mov	sp,fp
   1021c:	df000017 	ldw	fp,0(sp)
   10220:	dec00104 	addi	sp,sp,4
   10224:	f800283a 	ret

00010228 <menu_key>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_key(enum status cur_state)
{
   10228:	defffd04 	addi	sp,sp,-12
   1022c:	dfc00215 	stw	ra,8(sp)
   10230:	df000115 	stw	fp,4(sp)
   10234:	df000104 	addi	fp,sp,4
   10238:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* check if need to turn the menu on or off */
    if (cur_state == MENU_ON)
   1023c:	e0bfff17 	ldw	r2,-4(fp)
   10240:	1000021e 	bne	r2,zero,1024c <menu_key+0x24>
        /* currently the menu is on, turn it off */
	clear_menu();
   10244:	00108cc0 	call	108cc <clear_menu>
   10248:	00000106 	br	10250 <menu_key+0x28>
    else
        /* currently the menu is off, turn it on */
	display_menu();
   1024c:	00109040 	call	10904 <display_menu>


    /* all done, return the "opposite" of the current state */
    if (cur_state == MENU_ON)
   10250:	e0bfff17 	ldw	r2,-4(fp)
   10254:	1000021e 	bne	r2,zero,10260 <menu_key+0x38>
        /* state was MENU_ON, change it to MENU_OFF */
        return  MENU_OFF;
   10258:	00800044 	movi	r2,1
   1025c:	00000106 	br	10264 <menu_key+0x3c>
    else
        /* state was MENU_OFF, change it to MENU_ON */
        return  MENU_ON;
   10260:	0005883a 	mov	r2,zero

}
   10264:	e037883a 	mov	sp,fp
   10268:	dfc00117 	ldw	ra,4(sp)
   1026c:	df000017 	ldw	fp,0(sp)
   10270:	dec00204 	addi	sp,sp,8
   10274:	f800283a 	ret

00010278 <menu_up>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_up(enum status cur_state)
{
   10278:	defffd04 	addi	sp,sp,-12
   1027c:	dfc00215 	stw	ra,8(sp)
   10280:	df000115 	stw	fp,4(sp)
   10284:	df000104 	addi	fp,sp,4
   10288:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* go to the previous menu entry */
    previous_entry();
   1028c:	0010a880 	call	10a88 <previous_entry>


    /* return the current state */
    return  cur_state;
   10290:	e0bfff17 	ldw	r2,-4(fp)

}
   10294:	e037883a 	mov	sp,fp
   10298:	dfc00117 	ldw	ra,4(sp)
   1029c:	df000017 	ldw	fp,0(sp)
   102a0:	dec00204 	addi	sp,sp,8
   102a4:	f800283a 	ret

000102a8 <menu_down>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_down(enum status cur_state)
{
   102a8:	defffd04 	addi	sp,sp,-12
   102ac:	dfc00215 	stw	ra,8(sp)
   102b0:	df000115 	stw	fp,4(sp)
   102b4:	df000104 	addi	fp,sp,4
   102b8:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* go to the next menu entry */
    next_entry();
   102bc:	0010a180 	call	10a18 <next_entry>


    /* return the current state */
    return  cur_state;
   102c0:	e0bfff17 	ldw	r2,-4(fp)

}
   102c4:	e037883a 	mov	sp,fp
   102c8:	dfc00117 	ldw	ra,4(sp)
   102cc:	df000017 	ldw	fp,0(sp)
   102d0:	dec00204 	addi	sp,sp,8
   102d4:	f800283a 	ret

000102d8 <menu_left>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_left(enum status cur_state)
{
   102d8:	defffd04 	addi	sp,sp,-12
   102dc:	dfc00215 	stw	ra,8(sp)
   102e0:	df000115 	stw	fp,4(sp)
   102e4:	df000104 	addi	fp,sp,4
   102e8:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* invoke the <Left> key function for the current menu entry */
    menu_entry_left();
   102ec:	0010af40 	call	10af4 <menu_entry_left>


    /* return the current state */
    return  cur_state;
   102f0:	e0bfff17 	ldw	r2,-4(fp)

}
   102f4:	e037883a 	mov	sp,fp
   102f8:	dfc00117 	ldw	ra,4(sp)
   102fc:	df000017 	ldw	fp,0(sp)
   10300:	dec00204 	addi	sp,sp,8
   10304:	f800283a 	ret

00010308 <menu_right>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_right(enum status cur_state)
{
   10308:	defffd04 	addi	sp,sp,-12
   1030c:	dfc00215 	stw	ra,8(sp)
   10310:	df000115 	stw	fp,4(sp)
   10314:	df000104 	addi	fp,sp,4
   10318:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* invoke the <Right> key function for the current menu entry */
    menu_entry_right();
   1031c:	0010b940 	call	10b94 <menu_entry_right>


    /* return the current state */
    return  cur_state;
   10320:	e0bfff17 	ldw	r2,-4(fp)

}
   10324:	e037883a 	mov	sp,fp
   10328:	dfc00117 	ldw	ra,4(sp)
   1032c:	df000017 	ldw	fp,0(sp)
   10330:	dec00204 	addi	sp,sp,8
   10334:	f800283a 	ret

00010338 <clear_region>:
   Last Modified:    Mar. 8, 1994

*/

void  clear_region(int x_ul, int y_ul, int x_size, int y_size)
{
   10338:	defff804 	addi	sp,sp,-32
   1033c:	dfc00715 	stw	ra,28(sp)
   10340:	df000615 	stw	fp,24(sp)
   10344:	df000604 	addi	fp,sp,24
   10348:	e13ffc15 	stw	r4,-16(fp)
   1034c:	e17ffd15 	stw	r5,-12(fp)
   10350:	e1bffe15 	stw	r6,-8(fp)
   10354:	e1ffff15 	stw	r7,-4(fp)
    int  y;		/* y coordinate to clear */



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
   10358:	e0bffc17 	ldw	r2,-16(fp)
   1035c:	e0bffa15 	stw	r2,-24(fp)
   10360:	00001406 	br	103b4 <clear_region+0x7c>
        for (y = y_ul; y < (y_ul + y_size); y++)  {
   10364:	e0bffd17 	ldw	r2,-12(fp)
   10368:	e0bffb15 	stw	r2,-20(fp)
   1036c:	00000906 	br	10394 <clear_region+0x5c>

	    /* clear this pixel */
	    plot_pixel(x, y, PIXEL_WHITE);
   10370:	e0fffa17 	ldw	r3,-24(fp)
   10374:	e0bffb17 	ldw	r2,-20(fp)
   10378:	1809883a 	mov	r4,r3
   1037c:	100b883a 	mov	r5,r2
   10380:	000d883a 	mov	r6,zero
   10384:	0011a4c0 	call	11a4c <plot_pixel>



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
        for (y = y_ul; y < (y_ul + y_size); y++)  {
   10388:	e0bffb17 	ldw	r2,-20(fp)
   1038c:	10800044 	addi	r2,r2,1
   10390:	e0bffb15 	stw	r2,-20(fp)
   10394:	e0fffd17 	ldw	r3,-12(fp)
   10398:	e0bfff17 	ldw	r2,-4(fp)
   1039c:	1885883a 	add	r2,r3,r2
   103a0:	e0fffb17 	ldw	r3,-20(fp)
   103a4:	18bff216 	blt	r3,r2,10370 <clear_region+0x38>
    int  y;		/* y coordinate to clear */



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
   103a8:	e0bffa17 	ldw	r2,-24(fp)
   103ac:	10800044 	addi	r2,r2,1
   103b0:	e0bffa15 	stw	r2,-24(fp)
   103b4:	e0fffc17 	ldw	r3,-16(fp)
   103b8:	e0bffe17 	ldw	r2,-8(fp)
   103bc:	1885883a 	add	r2,r3,r2
   103c0:	e0fffa17 	ldw	r3,-24(fp)
   103c4:	18bfe716 	blt	r3,r2,10364 <clear_region+0x2c>
        }
    }


    /* done clearing the display region - return */
    return;
   103c8:	0001883a 	nop

}
   103cc:	e037883a 	mov	sp,fp
   103d0:	dfc00117 	ldw	ra,4(sp)
   103d4:	df000017 	ldw	fp,0(sp)
   103d8:	dec00204 	addi	sp,sp,8
   103dc:	f800283a 	ret

000103e0 <plot_hline>:
   Last Modified:    Mar. 7, 1994

*/

void  plot_hline(int start_x, int start_y, int length)
{
   103e0:	defff804 	addi	sp,sp,-32
   103e4:	dfc00715 	stw	ra,28(sp)
   103e8:	df000615 	stw	fp,24(sp)
   103ec:	df000604 	addi	fp,sp,24
   103f0:	e13ffd15 	stw	r4,-12(fp)
   103f4:	e17ffe15 	stw	r5,-8(fp)
   103f8:	e1bfff15 	stw	r6,-4(fp)
    int  end_x;		/* ending x position to plot */



    /* check if a line to the "right" or "left" */
    if (length > 0)  {
   103fc:	e0bfff17 	ldw	r2,-4(fp)
   10400:	0080070e 	bge	zero,r2,10420 <plot_hline+0x40>

        /* line to the "right" - start at start_x, end at start_x + length */
	init_x = start_x;
   10404:	e0bffd17 	ldw	r2,-12(fp)
   10408:	e0bffb15 	stw	r2,-20(fp)
	end_x = start_x + length;
   1040c:	e0fffd17 	ldw	r3,-12(fp)
   10410:	e0bfff17 	ldw	r2,-4(fp)
   10414:	1885883a 	add	r2,r3,r2
   10418:	e0bffc15 	stw	r2,-16(fp)
   1041c:	00000606 	br	10438 <plot_hline+0x58>
    }
    else  {

        /* line to the "left" - start at start_x + length, end at start_x */
	init_x = start_x + length;
   10420:	e0fffd17 	ldw	r3,-12(fp)
   10424:	e0bfff17 	ldw	r2,-4(fp)
   10428:	1885883a 	add	r2,r3,r2
   1042c:	e0bffb15 	stw	r2,-20(fp)
	end_x = start_x;
   10430:	e0bffd17 	ldw	r2,-12(fp)
   10434:	e0bffc15 	stw	r2,-16(fp)
    }


    /* loop, outputting points for the line (always draw to the "right") */
    for (x = init_x; x < end_x; x++)
   10438:	e0bffb17 	ldw	r2,-20(fp)
   1043c:	e0bffa15 	stw	r2,-24(fp)
   10440:	00000906 	br	10468 <plot_hline+0x88>
        /* plot a point of the line */
	plot_pixel(x, start_y, PIXEL_BLACK);
   10444:	e0fffa17 	ldw	r3,-24(fp)
   10448:	e0bffe17 	ldw	r2,-8(fp)
   1044c:	1809883a 	mov	r4,r3
   10450:	100b883a 	mov	r5,r2
   10454:	01800044 	movi	r6,1
   10458:	0011a4c0 	call	11a4c <plot_pixel>
	end_x = start_x;
    }


    /* loop, outputting points for the line (always draw to the "right") */
    for (x = init_x; x < end_x; x++)
   1045c:	e0bffa17 	ldw	r2,-24(fp)
   10460:	10800044 	addi	r2,r2,1
   10464:	e0bffa15 	stw	r2,-24(fp)
   10468:	e0fffa17 	ldw	r3,-24(fp)
   1046c:	e0bffc17 	ldw	r2,-16(fp)
   10470:	18bff416 	blt	r3,r2,10444 <plot_hline+0x64>
        /* plot a point of the line */
	plot_pixel(x, start_y, PIXEL_BLACK);


    /* done plotting the line - return */
    return;
   10474:	0001883a 	nop

}
   10478:	e037883a 	mov	sp,fp
   1047c:	dfc00117 	ldw	ra,4(sp)
   10480:	df000017 	ldw	fp,0(sp)
   10484:	dec00204 	addi	sp,sp,8
   10488:	f800283a 	ret

0001048c <plot_vline>:
   Last Modified:    Mar. 7, 1994

*/

void  plot_vline(int start_x, int start_y, int length)
{
   1048c:	defff804 	addi	sp,sp,-32
   10490:	dfc00715 	stw	ra,28(sp)
   10494:	df000615 	stw	fp,24(sp)
   10498:	df000604 	addi	fp,sp,24
   1049c:	e13ffd15 	stw	r4,-12(fp)
   104a0:	e17ffe15 	stw	r5,-8(fp)
   104a4:	e1bfff15 	stw	r6,-4(fp)
    int  end_y;		/* ending y position to plot */



    /* check if an "up" or "down" line */
    if (length > 0)  {
   104a8:	e0bfff17 	ldw	r2,-4(fp)
   104ac:	0080070e 	bge	zero,r2,104cc <plot_vline+0x40>

        /* line going "down" - start at start_y, end at start_y + length */
	init_y = start_y;
   104b0:	e0bffe17 	ldw	r2,-8(fp)
   104b4:	e0bffb15 	stw	r2,-20(fp)
	end_y = start_y + length;
   104b8:	e0fffe17 	ldw	r3,-8(fp)
   104bc:	e0bfff17 	ldw	r2,-4(fp)
   104c0:	1885883a 	add	r2,r3,r2
   104c4:	e0bffc15 	stw	r2,-16(fp)
   104c8:	00000606 	br	104e4 <plot_vline+0x58>
    }
    else  {

        /* line going "up" - start at start_y + length, end at start_y */
	init_y = start_y + length;
   104cc:	e0fffe17 	ldw	r3,-8(fp)
   104d0:	e0bfff17 	ldw	r2,-4(fp)
   104d4:	1885883a 	add	r2,r3,r2
   104d8:	e0bffb15 	stw	r2,-20(fp)
	end_y = start_y;
   104dc:	e0bffe17 	ldw	r2,-8(fp)
   104e0:	e0bffc15 	stw	r2,-16(fp)
    }


    /* loop, outputting points for the line (always draw "down") */
    for (y = init_y; y < end_y; y++)
   104e4:	e0bffb17 	ldw	r2,-20(fp)
   104e8:	e0bffa15 	stw	r2,-24(fp)
   104ec:	00000906 	br	10514 <plot_vline+0x88>
        /* plot a point of the line */
	plot_pixel(start_x, y, PIXEL_BLACK);
   104f0:	e0fffd17 	ldw	r3,-12(fp)
   104f4:	e0bffa17 	ldw	r2,-24(fp)
   104f8:	1809883a 	mov	r4,r3
   104fc:	100b883a 	mov	r5,r2
   10500:	01800044 	movi	r6,1
   10504:	0011a4c0 	call	11a4c <plot_pixel>
	end_y = start_y;
    }


    /* loop, outputting points for the line (always draw "down") */
    for (y = init_y; y < end_y; y++)
   10508:	e0bffa17 	ldw	r2,-24(fp)
   1050c:	10800044 	addi	r2,r2,1
   10510:	e0bffa15 	stw	r2,-24(fp)
   10514:	e0fffa17 	ldw	r3,-24(fp)
   10518:	e0bffc17 	ldw	r2,-16(fp)
   1051c:	18bff416 	blt	r3,r2,104f0 <plot_vline+0x64>
        /* plot a point of the line */
	plot_pixel(start_x, y, PIXEL_BLACK);


    /* done plotting the line - return */
    return;
   10520:	0001883a 	nop

}
   10524:	e037883a 	mov	sp,fp
   10528:	dfc00117 	ldw	ra,4(sp)
   1052c:	df000017 	ldw	fp,0(sp)
   10530:	dec00204 	addi	sp,sp,8
   10534:	f800283a 	ret

00010538 <plot_char>:
   Last Modified:    May 27, 2008

*/

void  plot_char(int pos_x, int pos_y, char c, enum char_style style)
{
   10538:	defff504 	addi	sp,sp,-44
   1053c:	dfc00a15 	stw	ra,40(sp)
   10540:	df000915 	stw	fp,36(sp)
   10544:	df000904 	addi	fp,sp,36
   10548:	e13ffc15 	stw	r4,-16(fp)
   1054c:	e17ffd15 	stw	r5,-12(fp)
   10550:	3005883a 	mov	r2,r6
   10554:	e1ffff15 	stw	r7,-4(fp)
   10558:	e0bffe05 	stb	r2,-8(fp)
    int  y;		/* y pixel position for the character */



    /* setup the pixel positions for the character */
    x = pos_x * HORIZ_SIZE;
   1055c:	e0bffc17 	ldw	r2,-16(fp)
   10560:	108001a4 	muli	r2,r2,6
   10564:	e0bffb15 	stw	r2,-20(fp)
    y = pos_y * VERT_SIZE;
   10568:	e0bffd17 	ldw	r2,-12(fp)
   1056c:	100490fa 	slli	r2,r2,3
   10570:	e0bffa15 	stw	r2,-24(fp)


    /* loop outputting the bits to the screen */
    for (row = 0; row < VERT_SIZE; row++)  {
   10574:	e03ff915 	stw	zero,-28(fp)
   10578:	00004006 	br	1067c <plot_char+0x144>

        /* get the character bits for this row from the character table */
	if (row == (VERT_SIZE - 1))
   1057c:	e0bff917 	ldw	r2,-28(fp)
   10580:	108001d8 	cmpnei	r2,r2,7
   10584:	1000021e 	bne	r2,zero,10590 <plot_char+0x58>
	    /* last row - blank it */
	    bits = 0;
   10588:	e03ff715 	stw	zero,-36(fp)
   1058c:	00000a06 	br	105b8 <plot_char+0x80>
	else
	    /* in middle of character, get the row from the bit patterns */
            bits = char_patterns[(c * (VERT_SIZE - 1)) + row];
   10590:	e0bffe07 	ldb	r2,-8(fp)
   10594:	10c001e4 	muli	r3,r2,7
   10598:	e0bff917 	ldw	r2,-28(fp)
   1059c:	1885883a 	add	r2,r3,r2
   105a0:	00c00074 	movhi	r3,1
   105a4:	18d37204 	addi	r3,r3,19912
   105a8:	1885883a 	add	r2,r3,r2
   105ac:	10800003 	ldbu	r2,0(r2)
   105b0:	10803fcc 	andi	r2,r2,255
   105b4:	e0bff715 	stw	r2,-36(fp)

	/* take care of "normal/reverse video" */
	if (style == REVERSE)
   105b8:	e0bfff17 	ldw	r2,-4(fp)
   105bc:	10800058 	cmpnei	r2,r2,1
   105c0:	1000031e 	bne	r2,zero,105d0 <plot_char+0x98>
	    /* invert the bits for "reverse video" */
	    bits = ~bits;
   105c4:	e0bff717 	ldw	r2,-36(fp)
   105c8:	0084303a 	nor	r2,zero,r2
   105cc:	e0bff715 	stw	r2,-36(fp)

        /* get the bits "in position" (high bit is output first */
	bits <<= (8 - HORIZ_SIZE);
   105d0:	e0bff717 	ldw	r2,-36(fp)
   105d4:	1085883a 	add	r2,r2,r2
   105d8:	1085883a 	add	r2,r2,r2
   105dc:	e0bff715 	stw	r2,-36(fp)


	/* now output the row of the character, pixel by pixel */
	for (col = 0; col < HORIZ_SIZE; col++)  {
   105e0:	e03ff815 	stw	zero,-32(fp)
   105e4:	00001c06 	br	10658 <plot_char+0x120>

            /* output this pixel in the appropriate color */
	    if ((bits & 0x80) == 0)
   105e8:	e0bff717 	ldw	r2,-36(fp)
   105ec:	1080200c 	andi	r2,r2,128
   105f0:	10000a1e 	bne	r2,zero,1061c <plot_char+0xe4>
	        /* blank pixel - output in PIXEL_WHITE */
		plot_pixel(x + col, y, PIXEL_WHITE);
   105f4:	e0fffb17 	ldw	r3,-20(fp)
   105f8:	e0bff817 	ldw	r2,-32(fp)
   105fc:	1885883a 	add	r2,r3,r2
   10600:	1007883a 	mov	r3,r2
   10604:	e0bffa17 	ldw	r2,-24(fp)
   10608:	1809883a 	mov	r4,r3
   1060c:	100b883a 	mov	r5,r2
   10610:	000d883a 	mov	r6,zero
   10614:	0011a4c0 	call	11a4c <plot_pixel>
   10618:	00000906 	br	10640 <plot_char+0x108>
	    else
	        /* black pixel - output in PIXEL_BLACK */
		plot_pixel(x + col, y, PIXEL_BLACK);
   1061c:	e0fffb17 	ldw	r3,-20(fp)
   10620:	e0bff817 	ldw	r2,-32(fp)
   10624:	1885883a 	add	r2,r3,r2
   10628:	1007883a 	mov	r3,r2
   1062c:	e0bffa17 	ldw	r2,-24(fp)
   10630:	1809883a 	mov	r4,r3
   10634:	100b883a 	mov	r5,r2
   10638:	01800044 	movi	r6,1
   1063c:	0011a4c0 	call	11a4c <plot_pixel>

	    /* shift the next bit into position */
	    bits <<= 1;
   10640:	e0bff717 	ldw	r2,-36(fp)
   10644:	1085883a 	add	r2,r2,r2
   10648:	e0bff715 	stw	r2,-36(fp)
        /* get the bits "in position" (high bit is output first */
	bits <<= (8 - HORIZ_SIZE);


	/* now output the row of the character, pixel by pixel */
	for (col = 0; col < HORIZ_SIZE; col++)  {
   1064c:	e0bff817 	ldw	r2,-32(fp)
   10650:	10800044 	addi	r2,r2,1
   10654:	e0bff815 	stw	r2,-32(fp)
   10658:	e0bff817 	ldw	r2,-32(fp)
   1065c:	10800190 	cmplti	r2,r2,6
   10660:	103fe11e 	bne	r2,zero,105e8 <plot_char+0xb0>
	    bits <<= 1;
        }


	/* next row - update the y position */
	y++;
   10664:	e0bffa17 	ldw	r2,-24(fp)
   10668:	10800044 	addi	r2,r2,1
   1066c:	e0bffa15 	stw	r2,-24(fp)
    x = pos_x * HORIZ_SIZE;
    y = pos_y * VERT_SIZE;


    /* loop outputting the bits to the screen */
    for (row = 0; row < VERT_SIZE; row++)  {
   10670:	e0bff917 	ldw	r2,-28(fp)
   10674:	10800044 	addi	r2,r2,1
   10678:	e0bff915 	stw	r2,-28(fp)
   1067c:	e0bff917 	ldw	r2,-28(fp)
   10680:	10800210 	cmplti	r2,r2,8
   10684:	103fbd1e 	bne	r2,zero,1057c <plot_char+0x44>
	y++;
    }


    /* all done, return */
    return;
   10688:	0001883a 	nop

}
   1068c:	e037883a 	mov	sp,fp
   10690:	dfc00117 	ldw	ra,4(sp)
   10694:	df000017 	ldw	fp,0(sp)
   10698:	dec00204 	addi	sp,sp,8
   1069c:	f800283a 	ret

000106a0 <plot_string>:
   Last Modified:    Mar. 17, 1997

*/

void  plot_string(int pos_x, int pos_y, const char *s, enum char_style style)
{
   106a0:	defffa04 	addi	sp,sp,-24
   106a4:	dfc00515 	stw	ra,20(sp)
   106a8:	df000415 	stw	fp,16(sp)
   106ac:	df000404 	addi	fp,sp,16
   106b0:	e13ffc15 	stw	r4,-16(fp)
   106b4:	e17ffd15 	stw	r5,-12(fp)
   106b8:	e1bffe15 	stw	r6,-8(fp)
   106bc:	e1ffff15 	stw	r7,-4(fp)
      /* none */



    /* loop, outputting characters from string s */
    while (*s != '\0')
   106c0:	00001106 	br	10708 <plot_string+0x68>

        /* output this character and move to the next character and screen position */
	plot_char(pos_x++, pos_y, *s++, style);
   106c4:	e0fffc17 	ldw	r3,-16(fp)
   106c8:	e0bffc17 	ldw	r2,-16(fp)
   106cc:	10800044 	addi	r2,r2,1
   106d0:	e0bffc15 	stw	r2,-16(fp)
   106d4:	e0bffe17 	ldw	r2,-8(fp)
   106d8:	10800003 	ldbu	r2,0(r2)
   106dc:	10803fcc 	andi	r2,r2,255
   106e0:	1080201c 	xori	r2,r2,128
   106e4:	10bfe004 	addi	r2,r2,-128
   106e8:	e13ffe17 	ldw	r4,-8(fp)
   106ec:	21000044 	addi	r4,r4,1
   106f0:	e13ffe15 	stw	r4,-8(fp)
   106f4:	1809883a 	mov	r4,r3
   106f8:	e17ffd17 	ldw	r5,-12(fp)
   106fc:	100d883a 	mov	r6,r2
   10700:	e1ffff17 	ldw	r7,-4(fp)
   10704:	00105380 	call	10538 <plot_char>
      /* none */



    /* loop, outputting characters from string s */
    while (*s != '\0')
   10708:	e0bffe17 	ldw	r2,-8(fp)
   1070c:	10800003 	ldbu	r2,0(r2)
   10710:	10803fcc 	andi	r2,r2,255
   10714:	1080201c 	xori	r2,r2,128
   10718:	10bfe004 	addi	r2,r2,-128
   1071c:	103fe91e 	bne	r2,zero,106c4 <plot_string+0x24>
        /* output this character and move to the next character and screen position */
	plot_char(pos_x++, pos_y, *s++, style);


    /* all done, return */
    return;
   10720:	0001883a 	nop

}
   10724:	e037883a 	mov	sp,fp
   10728:	dfc00117 	ldw	ra,4(sp)
   1072c:	df000017 	ldw	fp,0(sp)
   10730:	dec00204 	addi	sp,sp,8
   10734:	f800283a 	ret

00010738 <main>:
   Last Modified:    May 27, 2008

*/

int  main()
{
   10738:	defffb04 	addi	sp,sp,-20
   1073c:	dfc00415 	stw	ra,16(sp)
   10740:	df000315 	stw	fp,12(sp)
   10744:	df000304 	addi	fp,sp,12
    /* variables */
    enum keycode        key;		    /* an input key */

    enum status         state = MENU_ON;    /* current program state */
   10748:	e03ffd15 	stw	zero,-12(fp)
        {  no_action,   no_action   } }; /* illegal key */



    /* first initialize everything */
    clear_display();		/* clear the display */
   1074c:	0011a2c0 	call	11a2c <clear_display>

    init_trace();		/* initialize the trace routines */
   10750:	0011c580 	call	11c58 <init_trace>
    init_menu();		/* initialize the menu system */
   10754:	00108680 	call	10868 <init_menu>
   10758:	00000106 	br	10760 <main+0x28>
	    key = key_lookup();

	    /* execute processing routine for that key */
	    state = process_key[key][state](state);
	}
    }
   1075c:	0001883a 	nop

    /* infinite loop processing input */
    while(TRUE)  {

        /* check if ready to do a trace */
	if (trace_rdy())
   10760:	0011d140 	call	11d14 <trace_rdy>
   10764:	10000126 	beq	r2,zero,1076c <main+0x34>
	    /* ready for a trace - do it */
	    do_trace();
   10768:	00126200 	call	12620 <do_trace>


	/* check if have a trace to display */
	if (is_sampling() && ((sample = sample_done()) != NULL))  {
   1076c:	0011cf40 	call	11cf4 <is_sampling>
   10770:	10000726 	beq	r2,zero,10790 <main+0x58>
   10774:	0011b0c0 	call	11b0c <sample_done>
   10778:	e0bffe15 	stw	r2,-8(fp)
   1077c:	e0bffe17 	ldw	r2,-8(fp)
   10780:	10000326 	beq	r2,zero,10790 <main+0x58>

	    /* have a trace - output it */
	    plot_trace(sample);
   10784:	e13ffe17 	ldw	r4,-8(fp)
   10788:	00126680 	call	12668 <plot_trace>
	    /* done processing this trace */
	    trace_done();
   1078c:	0011d4c0 	call	11d4c <trace_done>
	}


	/* now check for keypad input */
	if (key_available())  {
   10790:	00119ec0 	call	119ec <key_available>
   10794:	10803fcc 	andi	r2,r2,255
   10798:	103ff026 	beq	r2,zero,1075c <main+0x24>

	    /* have keypad input - get the key */
	    key = key_lookup();
   1079c:	00107dc0 	call	107dc <key_lookup>
   107a0:	e0bfff15 	stw	r2,-4(fp)

	    /* execute processing routine for that key */
	    state = process_key[key][state](state);
   107a4:	00c00074 	movhi	r3,1
   107a8:	18d47d04 	addi	r3,r3,20980
   107ac:	e0bfff17 	ldw	r2,-4(fp)
   107b0:	1089883a 	add	r4,r2,r2
   107b4:	e0bffd17 	ldw	r2,-12(fp)
   107b8:	2085883a 	add	r2,r4,r2
   107bc:	1085883a 	add	r2,r2,r2
   107c0:	1085883a 	add	r2,r2,r2
   107c4:	1885883a 	add	r2,r3,r2
   107c8:	10800017 	ldw	r2,0(r2)
   107cc:	e13ffd17 	ldw	r4,-12(fp)
   107d0:	103ee83a 	callr	r2
   107d4:	e0bffd15 	stw	r2,-12(fp)
	}
    }
   107d8:	003fe006 	br	1075c <main+0x24>

000107dc <key_lookup>:
   Last Modified:    Mar. 17, 1997

*/

static  enum keycode  key_lookup()
{
   107dc:	defffc04 	addi	sp,sp,-16
   107e0:	dfc00315 	stw	ra,12(sp)
   107e4:	df000215 	stw	fp,8(sp)
   107e8:	df000204 	addi	fp,sp,8
    int  i;           	/* general loop index */



    /* get a key */
    key = getkey();
   107ec:	0011a0c0 	call	11a0c <getkey>
   107f0:	e0bfff15 	stw	r2,-4(fp)


    /* lookup key in keys array */
    for (i = 0; ((i < (sizeof(keys)/sizeof(int))) && (key != keys[i])); i++);
   107f4:	e03ffe15 	stw	zero,-8(fp)
   107f8:	00000306 	br	10808 <key_lookup+0x2c>
   107fc:	e0bffe17 	ldw	r2,-8(fp)
   10800:	10800044 	addi	r2,r2,1
   10804:	e0bffe15 	stw	r2,-8(fp)
   10808:	e0bffe17 	ldw	r2,-8(fp)
   1080c:	10800168 	cmpgeui	r2,r2,5
   10810:	1000091e 	bne	r2,zero,10838 <key_lookup+0x5c>
   10814:	00c00074 	movhi	r3,1
   10818:	18d47204 	addi	r3,r3,20936
   1081c:	e0bffe17 	ldw	r2,-8(fp)
   10820:	1085883a 	add	r2,r2,r2
   10824:	1085883a 	add	r2,r2,r2
   10828:	1885883a 	add	r2,r3,r2
   1082c:	10c00017 	ldw	r3,0(r2)
   10830:	e0bfff17 	ldw	r2,-4(fp)
   10834:	18bff11e 	bne	r3,r2,107fc <key_lookup+0x20>


    /* return the appropriate key type */
    return  keycodes[i];
   10838:	00c00074 	movhi	r3,1
   1083c:	18d47704 	addi	r3,r3,20956
   10840:	e0bffe17 	ldw	r2,-8(fp)
   10844:	1085883a 	add	r2,r2,r2
   10848:	1085883a 	add	r2,r2,r2
   1084c:	1885883a 	add	r2,r3,r2
   10850:	10800017 	ldw	r2,0(r2)

}
   10854:	e037883a 	mov	sp,fp
   10858:	dfc00117 	ldw	ra,4(sp)
   1085c:	df000017 	ldw	fp,0(sp)
   10860:	dec00204 	addi	sp,sp,8
   10864:	f800283a 	ret

00010868 <init_menu>:
   Last Modified:    Mar. 17, 1997

*/

void  init_menu(void)
{
   10868:	defffe04 	addi	sp,sp,-8
   1086c:	dfc00115 	stw	ra,4(sp)
   10870:	df000015 	stw	fp,0(sp)
   10874:	d839883a 	mov	fp,sp
      /* none */



    /* set the menu parameters */
    menu_entry = 0;		/* first menu entry */
   10878:	d0259d15 	stw	zero,-27020(gp)
    menu_display = FALSE;	/* menu is not currently displayed (but it will be shortly) */
   1087c:	d0259c15 	stw	zero,-27024(gp)


    /* set the scope (option) parameters */
    set_trigger_mode(NORMAL_TRIGGER);	/* normal triggering */
   10880:	0009883a 	mov	r4,zero
   10884:	0010d500 	call	10d50 <set_trigger_mode>
    set_scale(SCALE_AXES);		/* scale is axes */
   10888:	01000044 	movi	r4,1
   1088c:	0010ee00 	call	10ee0 <set_scale>
    set_sweep(0);			/* first sweep rate */
   10890:	0009883a 	mov	r4,zero
   10894:	00110500 	call	11050 <set_sweep>
    set_trg_level((MIN_TRG_LEVEL_SET + MAX_TRG_LEVEL_SET) / 2);	/* middle trigger level */
   10898:	01000fc4 	movi	r4,63
   1089c:	001121c0 	call	1121c <set_trg_level>
    set_trg_slope(SLOPE_POSITIVE);	/* positive slope */
   108a0:	0009883a 	mov	r4,zero
   108a4:	00113a40 	call	113a4 <set_trg_slope>
    set_trg_delay(MIN_DELAY);		/* minimum delay */
   108a8:	0009883a 	mov	r4,zero
   108ac:	00114a40 	call	114a4 <set_trg_delay>


    /* now display the menu */
    display_menu();
   108b0:	00109040 	call	10904 <display_menu>


    /* done initializing, return */
    return;
   108b4:	0001883a 	nop

}
   108b8:	e037883a 	mov	sp,fp
   108bc:	dfc00117 	ldw	ra,4(sp)
   108c0:	df000017 	ldw	fp,0(sp)
   108c4:	dec00204 	addi	sp,sp,8
   108c8:	f800283a 	ret

000108cc <clear_menu>:
   Last Modified:    Mar. 13, 1994

*/

void  clear_menu(void)
{
   108cc:	defffe04 	addi	sp,sp,-8
   108d0:	dfc00115 	stw	ra,4(sp)
   108d4:	df000015 	stw	fp,0(sp)
   108d8:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
   108dc:	d0a59c17 	ldw	r2,-27024(gp)
   108e0:	10000126 	beq	r2,zero,108e8 <clear_menu+0x1c>

        /* menu is being displayed - turn it off and restore the trace in that area */
	restore_menu_trace();
   108e4:	001234c0 	call	1234c <restore_menu_trace>
    }


    /* no longer displaying the menu */
    menu_display = FALSE;
   108e8:	d0259c15 	stw	zero,-27024(gp)


    /* all done, return */
    return;
   108ec:	0001883a 	nop

}
   108f0:	e037883a 	mov	sp,fp
   108f4:	dfc00117 	ldw	ra,4(sp)
   108f8:	df000017 	ldw	fp,0(sp)
   108fc:	dec00204 	addi	sp,sp,8
   10900:	f800283a 	ret

00010904 <display_menu>:
   Last Modified:    Mar. 13, 1994

*/

void  display_menu(void)
{
   10904:	defffd04 	addi	sp,sp,-12
   10908:	dfc00215 	stw	ra,8(sp)
   1090c:	df000115 	stw	fp,4(sp)
   10910:	df000104 	addi	fp,sp,4
    int  i;		/* loop index */



    /* check if the menu is currently being displayed */
    if (!menu_display)  {
   10914:	d0a59c17 	ldw	r2,-27024(gp)
   10918:	1000121e 	bne	r2,zero,10964 <display_menu+0x60>

        /* menu is not being displayed - turn it on */
	/* display it entry by entry */
	for (i = 0; i < NO_MENU_ENTRIES; i++)  {
   1091c:	e03fff15 	stw	zero,-4(fp)
   10920:	00000d06 	br	10958 <display_menu+0x54>

	    /* display this entry - check if it should be highlighted */
	    if (i == menu_entry)
   10924:	d0a59d17 	ldw	r2,-27020(gp)
   10928:	e0ffff17 	ldw	r3,-4(fp)
   1092c:	1880041e 	bne	r3,r2,10940 <display_menu+0x3c>
	        /* currently selected entry - highlight it */
	        display_entry(i, TRUE);
   10930:	e13fff17 	ldw	r4,-4(fp)
   10934:	01400044 	movi	r5,1
   10938:	0010c340 	call	10c34 <display_entry>
   1093c:	00000306 	br	1094c <display_menu+0x48>
	    else
	        /* not the currently selected entry - "normal video" */
	        display_entry(i, FALSE);
   10940:	e13fff17 	ldw	r4,-4(fp)
   10944:	000b883a 	mov	r5,zero
   10948:	0010c340 	call	10c34 <display_entry>
    /* check if the menu is currently being displayed */
    if (!menu_display)  {

        /* menu is not being displayed - turn it on */
	/* display it entry by entry */
	for (i = 0; i < NO_MENU_ENTRIES; i++)  {
   1094c:	e0bfff17 	ldw	r2,-4(fp)
   10950:	10800044 	addi	r2,r2,1
   10954:	e0bfff15 	stw	r2,-4(fp)
   10958:	e0bfff17 	ldw	r2,-4(fp)
   1095c:	108001f0 	cmpltui	r2,r2,7
   10960:	103ff01e 	bne	r2,zero,10924 <display_menu+0x20>
        }
    }


    /* now are displaying the menu */
    menu_display = TRUE;
   10964:	00800044 	movi	r2,1
   10968:	d0a59c15 	stw	r2,-27024(gp)


    /* all done, return */
    return;
   1096c:	0001883a 	nop

}
   10970:	e037883a 	mov	sp,fp
   10974:	dfc00117 	ldw	ra,4(sp)
   10978:	df000017 	ldw	fp,0(sp)
   1097c:	dec00204 	addi	sp,sp,8
   10980:	f800283a 	ret

00010984 <refresh_menu>:
   Last Modified:    Mar. 8, 1994

*/

void  refresh_menu(void)
{
   10984:	defffe04 	addi	sp,sp,-8
   10988:	dfc00115 	stw	ra,4(sp)
   1098c:	df000015 	stw	fp,0(sp)
   10990:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
   10994:	d0a59c17 	ldw	r2,-27024(gp)
   10998:	10000226 	beq	r2,zero,109a4 <refresh_menu+0x20>

    	/* menu is currently being displayed - need to refresh it */
	/* do this by turning off the display, then forcing it back on */
	menu_display = FALSE;
   1099c:	d0259c15 	stw	zero,-27024(gp)
	display_menu();
   109a0:	00109040 	call	10904 <display_menu>
    }


    /* refreshed the menu if it was displayed, now return */
    return;
   109a4:	0001883a 	nop

}
   109a8:	e037883a 	mov	sp,fp
   109ac:	dfc00117 	ldw	ra,4(sp)
   109b0:	df000017 	ldw	fp,0(sp)
   109b4:	dec00204 	addi	sp,sp,8
   109b8:	f800283a 	ret

000109bc <reset_menu>:
   Last Modified:    Mar. 17, 1997

*/

void  reset_menu(void)
{
   109bc:	defffe04 	addi	sp,sp,-8
   109c0:	dfc00115 	stw	ra,4(sp)
   109c4:	df000015 	stw	fp,0(sp)
   109c8:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
   109cc:	d0a59c17 	ldw	r2,-27024(gp)
   109d0:	10000426 	beq	r2,zero,109e4 <reset_menu+0x28>

        /* menu is being displayed */
	/* remove highlight from currently selected entry */
	display_entry(menu_entry, FALSE);
   109d4:	d0a59d17 	ldw	r2,-27020(gp)
   109d8:	1009883a 	mov	r4,r2
   109dc:	000b883a 	mov	r5,zero
   109e0:	0010c340 	call	10c34 <display_entry>
    }


    /* reset the currently selected entry */
    menu_entry = 0;
   109e4:	d0259d15 	stw	zero,-27020(gp)


    /* finally, highlight the first entry if the menu is being displayed */
    if (menu_display)
   109e8:	d0a59c17 	ldw	r2,-27024(gp)
   109ec:	10000426 	beq	r2,zero,10a00 <reset_menu+0x44>
	display_entry(menu_entry, TRUE);
   109f0:	d0a59d17 	ldw	r2,-27020(gp)
   109f4:	1009883a 	mov	r4,r2
   109f8:	01400044 	movi	r5,1
   109fc:	0010c340 	call	10c34 <display_entry>



    /* all done, return */
    return;
   10a00:	0001883a 	nop

}
   10a04:	e037883a 	mov	sp,fp
   10a08:	dfc00117 	ldw	ra,4(sp)
   10a0c:	df000017 	ldw	fp,0(sp)
   10a10:	dec00204 	addi	sp,sp,8
   10a14:	f800283a 	ret

00010a18 <next_entry>:
   Last Modified:    Mar. 13, 1994

*/

void  next_entry(void)
{
   10a18:	defffe04 	addi	sp,sp,-8
   10a1c:	dfc00115 	stw	ra,4(sp)
   10a20:	df000015 	stw	fp,0(sp)
   10a24:	d839883a 	mov	fp,sp
      /* none */



    /* only update if not at end of the menu */
    if (menu_entry < (NO_MENU_ENTRIES - 1))  {
   10a28:	d0a59d17 	ldw	r2,-27020(gp)
   10a2c:	108001a8 	cmpgeui	r2,r2,6
   10a30:	10000f1e 	bne	r2,zero,10a70 <next_entry+0x58>

        /* not at the end of the menu */

	/* turn off current entry if displaying */
	if (menu_display)
   10a34:	d0a59c17 	ldw	r2,-27024(gp)
   10a38:	10000426 	beq	r2,zero,10a4c <next_entry+0x34>
            /* displaying menu - turn off currently selected entry */
	    display_entry(menu_entry, FALSE);
   10a3c:	d0a59d17 	ldw	r2,-27020(gp)
   10a40:	1009883a 	mov	r4,r2
   10a44:	000b883a 	mov	r5,zero
   10a48:	0010c340 	call	10c34 <display_entry>

	/* update the menu entry to the next one */
	menu_entry++;
   10a4c:	d0a59d17 	ldw	r2,-27020(gp)
   10a50:	10800044 	addi	r2,r2,1
   10a54:	d0a59d15 	stw	r2,-27020(gp)

	/* now highlight this entry if displaying the menu */
	if (menu_display)
   10a58:	d0a59c17 	ldw	r2,-27024(gp)
   10a5c:	10000426 	beq	r2,zero,10a70 <next_entry+0x58>
            /* displaying menu - highlight newly selected entry */
	    display_entry(menu_entry, TRUE);
   10a60:	d0a59d17 	ldw	r2,-27020(gp)
   10a64:	1009883a 	mov	r4,r2
   10a68:	01400044 	movi	r5,1
   10a6c:	0010c340 	call	10c34 <display_entry>
    }


    /* all done, return */
    return;
   10a70:	0001883a 	nop

}
   10a74:	e037883a 	mov	sp,fp
   10a78:	dfc00117 	ldw	ra,4(sp)
   10a7c:	df000017 	ldw	fp,0(sp)
   10a80:	dec00204 	addi	sp,sp,8
   10a84:	f800283a 	ret

00010a88 <previous_entry>:
   Last Modified:    Mar. 13, 1994

*/

void  previous_entry(void)
{
   10a88:	defffe04 	addi	sp,sp,-8
   10a8c:	dfc00115 	stw	ra,4(sp)
   10a90:	df000015 	stw	fp,0(sp)
   10a94:	d839883a 	mov	fp,sp
      /* none */



    /* only update if not at the start of the menu */
    if (menu_entry > 0)  {
   10a98:	d0a59d17 	ldw	r2,-27020(gp)
   10a9c:	00800f0e 	bge	zero,r2,10adc <previous_entry+0x54>

        /* not at the start of the menu */

	/* turn off current entry if displaying */
	if (menu_display)
   10aa0:	d0a59c17 	ldw	r2,-27024(gp)
   10aa4:	10000426 	beq	r2,zero,10ab8 <previous_entry+0x30>
            /* displaying menu - turn off currently selected entry */
	    display_entry(menu_entry, FALSE);
   10aa8:	d0a59d17 	ldw	r2,-27020(gp)
   10aac:	1009883a 	mov	r4,r2
   10ab0:	000b883a 	mov	r5,zero
   10ab4:	0010c340 	call	10c34 <display_entry>

	/* update the menu entry to the previous one */
	menu_entry--;
   10ab8:	d0a59d17 	ldw	r2,-27020(gp)
   10abc:	10bfffc4 	addi	r2,r2,-1
   10ac0:	d0a59d15 	stw	r2,-27020(gp)

	/* now highlight this entry if displaying the menu */
	if (menu_display)
   10ac4:	d0a59c17 	ldw	r2,-27024(gp)
   10ac8:	10000426 	beq	r2,zero,10adc <previous_entry+0x54>
            /* displaying menu - highlight newly selected entry */
	    display_entry(menu_entry, TRUE);
   10acc:	d0a59d17 	ldw	r2,-27020(gp)
   10ad0:	1009883a 	mov	r4,r2
   10ad4:	01400044 	movi	r5,1
   10ad8:	0010c340 	call	10c34 <display_entry>

    }


    /* all done, return */
    return;
   10adc:	0001883a 	nop

}
   10ae0:	e037883a 	mov	sp,fp
   10ae4:	dfc00117 	ldw	ra,4(sp)
   10ae8:	df000017 	ldw	fp,0(sp)
   10aec:	dec00204 	addi	sp,sp,8
   10af0:	f800283a 	ret

00010af4 <menu_entry_left>:
   Last Modified:    May 9, 2006

*/

void  menu_entry_left(void)
{
   10af4:	defffe04 	addi	sp,sp,-8
   10af8:	dfc00115 	stw	ra,4(sp)
   10afc:	df000015 	stw	fp,0(sp)
   10b00:	d839883a 	mov	fp,sp
       /*  Level           Slope             Delay                        */



    /* invoke the appropriate <Left> key function */
    process[menu_entry]();
   10b04:	d0a59d17 	ldw	r2,-27020(gp)
   10b08:	00c00074 	movhi	r3,1
   10b0c:	18d4ba04 	addi	r3,r3,21224
   10b10:	1085883a 	add	r2,r2,r2
   10b14:	1085883a 	add	r2,r2,r2
   10b18:	1885883a 	add	r2,r3,r2
   10b1c:	10800017 	ldw	r2,0(r2)
   10b20:	103ee83a 	callr	r2

    /* if displaying menu entries, display the new value */
    /* note: since it is being changed - know this option is selected */
    if (menu_display)  {
   10b24:	d0a59c17 	ldw	r2,-27024(gp)
   10b28:	10001426 	beq	r2,zero,10b7c <menu_entry_left+0x88>
        menu[menu_entry].display((MENU_X + menu[menu_entry].opt_off),
   10b2c:	d0a59d17 	ldw	r2,-27020(gp)
   10b30:	00c00074 	movhi	r3,1
   10b34:	18d49704 	addi	r3,r3,21084
   10b38:	1004913a 	slli	r2,r2,4
   10b3c:	1885883a 	add	r2,r3,r2
   10b40:	10800304 	addi	r2,r2,12
   10b44:	11c00017 	ldw	r7,0(r2)
   10b48:	d0a59d17 	ldw	r2,-27020(gp)
   10b4c:	00c00074 	movhi	r3,1
   10b50:	18d49704 	addi	r3,r3,21084
   10b54:	1004913a 	slli	r2,r2,4
   10b58:	1885883a 	add	r2,r3,r2
   10b5c:	10800204 	addi	r2,r2,8
   10b60:	10800017 	ldw	r2,0(r2)
   10b64:	10c00fc4 	addi	r3,r2,63
   10b68:	d0a59d17 	ldw	r2,-27020(gp)
   10b6c:	1809883a 	mov	r4,r3
   10b70:	100b883a 	mov	r5,r2
   10b74:	000d883a 	mov	r6,zero
   10b78:	383ee83a 	callr	r7
    			         (MENU_Y + menu_entry), OPTION_SELECTED);
    }


    /* all done, return */
    return;
   10b7c:	0001883a 	nop

}
   10b80:	e037883a 	mov	sp,fp
   10b84:	dfc00117 	ldw	ra,4(sp)
   10b88:	df000017 	ldw	fp,0(sp)
   10b8c:	dec00204 	addi	sp,sp,8
   10b90:	f800283a 	ret

00010b94 <menu_entry_right>:
   Last Modified:    May 9, 2006

*/

void  menu_entry_right(void)
{
   10b94:	defffe04 	addi	sp,sp,-8
   10b98:	dfc00115 	stw	ra,4(sp)
   10b9c:	df000015 	stw	fp,0(sp)
   10ba0:	d839883a 	mov	fp,sp
       /*  Level         Slope             Delay                        */



    /* invoke the appropriate <Right> key function */
    process[menu_entry]();
   10ba4:	d0a59d17 	ldw	r2,-27020(gp)
   10ba8:	00c00074 	movhi	r3,1
   10bac:	18d4b304 	addi	r3,r3,21196
   10bb0:	1085883a 	add	r2,r2,r2
   10bb4:	1085883a 	add	r2,r2,r2
   10bb8:	1885883a 	add	r2,r3,r2
   10bbc:	10800017 	ldw	r2,0(r2)
   10bc0:	103ee83a 	callr	r2

    /* if displaying menu entries, display the new value */
    /* note: since it is being changed - know this option is selected */
    if (menu_display)  {
   10bc4:	d0a59c17 	ldw	r2,-27024(gp)
   10bc8:	10001426 	beq	r2,zero,10c1c <menu_entry_right+0x88>
        menu[menu_entry].display((MENU_X + menu[menu_entry].opt_off),
   10bcc:	d0a59d17 	ldw	r2,-27020(gp)
   10bd0:	00c00074 	movhi	r3,1
   10bd4:	18d49704 	addi	r3,r3,21084
   10bd8:	1004913a 	slli	r2,r2,4
   10bdc:	1885883a 	add	r2,r3,r2
   10be0:	10800304 	addi	r2,r2,12
   10be4:	11c00017 	ldw	r7,0(r2)
   10be8:	d0a59d17 	ldw	r2,-27020(gp)
   10bec:	00c00074 	movhi	r3,1
   10bf0:	18d49704 	addi	r3,r3,21084
   10bf4:	1004913a 	slli	r2,r2,4
   10bf8:	1885883a 	add	r2,r3,r2
   10bfc:	10800204 	addi	r2,r2,8
   10c00:	10800017 	ldw	r2,0(r2)
   10c04:	10c00fc4 	addi	r3,r2,63
   10c08:	d0a59d17 	ldw	r2,-27020(gp)
   10c0c:	1809883a 	mov	r4,r3
   10c10:	100b883a 	mov	r5,r2
   10c14:	000d883a 	mov	r6,zero
   10c18:	383ee83a 	callr	r7
    			         (MENU_Y + menu_entry), OPTION_SELECTED);
    }


    /* all done, return */
    return;
   10c1c:	0001883a 	nop

}
   10c20:	e037883a 	mov	sp,fp
   10c24:	dfc00117 	ldw	ra,4(sp)
   10c28:	df000017 	ldw	fp,0(sp)
   10c2c:	dec00204 	addi	sp,sp,8
   10c30:	f800283a 	ret

00010c34 <display_entry>:
   Last Modified:    Aug. 13, 2004

*/

static void  display_entry(int entry, int selected)
{
   10c34:	defffc04 	addi	sp,sp,-16
   10c38:	dfc00315 	stw	ra,12(sp)
   10c3c:	df000215 	stw	fp,8(sp)
   10c40:	df000204 	addi	fp,sp,8
   10c44:	e13ffe15 	stw	r4,-8(fp)
   10c48:	e17fff15 	stw	r5,-4(fp)
      /* none */



    /* output the menu entry with the appropriate color */
    plot_string((MENU_X + menu[entry].h_off), (MENU_Y + entry), menu[entry].s,
   10c4c:	00c00074 	movhi	r3,1
   10c50:	18d49704 	addi	r3,r3,21084
   10c54:	e0bffe17 	ldw	r2,-8(fp)
   10c58:	1004913a 	slli	r2,r2,4
   10c5c:	1885883a 	add	r2,r3,r2
   10c60:	10800104 	addi	r2,r2,4
   10c64:	10800017 	ldw	r2,0(r2)
   10c68:	11000fc4 	addi	r4,r2,63
   10c6c:	00c00074 	movhi	r3,1
   10c70:	18d49704 	addi	r3,r3,21084
   10c74:	e0bffe17 	ldw	r2,-8(fp)
   10c78:	1004913a 	slli	r2,r2,4
   10c7c:	1885883a 	add	r2,r3,r2
   10c80:	10c00017 	ldw	r3,0(r2)
   10c84:	e0bfff17 	ldw	r2,-4(fp)
   10c88:	1004c03a 	cmpne	r2,r2,zero
   10c8c:	10803fcc 	andi	r2,r2,255
   10c90:	e17ffe17 	ldw	r5,-8(fp)
   10c94:	180d883a 	mov	r6,r3
   10c98:	100f883a 	mov	r7,r2
   10c9c:	00106a00 	call	106a0 <plot_string>
    		(selected ? SELECTED : NORMAL));
    /* also output the menu option with the appropriate color */
    menu[entry].display((MENU_X + menu[entry].opt_off), (MENU_Y + entry),
   10ca0:	00c00074 	movhi	r3,1
   10ca4:	18d49704 	addi	r3,r3,21084
   10ca8:	e0bffe17 	ldw	r2,-8(fp)
   10cac:	1004913a 	slli	r2,r2,4
   10cb0:	1885883a 	add	r2,r3,r2
   10cb4:	10800304 	addi	r2,r2,12
   10cb8:	10c00017 	ldw	r3,0(r2)
   10cbc:	01000074 	movhi	r4,1
   10cc0:	21149704 	addi	r4,r4,21084
   10cc4:	e0bffe17 	ldw	r2,-8(fp)
   10cc8:	1004913a 	slli	r2,r2,4
   10ccc:	2085883a 	add	r2,r4,r2
   10cd0:	10800204 	addi	r2,r2,8
   10cd4:	10800017 	ldw	r2,0(r2)
   10cd8:	10800fc4 	addi	r2,r2,63
   10cdc:	1009883a 	mov	r4,r2
   10ce0:	e17ffe17 	ldw	r5,-8(fp)
   10ce4:	000d883a 	mov	r6,zero
   10ce8:	183ee83a 	callr	r3
    			(selected ? OPTION_SELECTED : OPTION_NORMAL));


    /* all done outputting this menu entry - return */
    return;
   10cec:	0001883a 	nop

}
   10cf0:	e037883a 	mov	sp,fp
   10cf4:	dfc00117 	ldw	ra,4(sp)
   10cf8:	df000017 	ldw	fp,0(sp)
   10cfc:	dec00204 	addi	sp,sp,8
   10d00:	f800283a 	ret

00010d04 <no_menu_action>:
   Last Modified:    Mar. 8, 1994

*/

void  no_menu_action()
{
   10d04:	deffff04 	addi	sp,sp,-4
   10d08:	df000015 	stw	fp,0(sp)
   10d0c:	d839883a 	mov	fp,sp
      /* none */



    /* nothing to do - return */
    return;
   10d10:	0001883a 	nop

}
   10d14:	e037883a 	mov	sp,fp
   10d18:	df000017 	ldw	fp,0(sp)
   10d1c:	dec00104 	addi	sp,sp,4
   10d20:	f800283a 	ret

00010d24 <no_display>:
   Last Modified:    Mar. 8, 1994

*/

void  no_display(int x_pos, int y_pos, int style)
{
   10d24:	defffc04 	addi	sp,sp,-16
   10d28:	df000315 	stw	fp,12(sp)
   10d2c:	df000304 	addi	fp,sp,12
   10d30:	e13ffd15 	stw	r4,-12(fp)
   10d34:	e17ffe15 	stw	r5,-8(fp)
   10d38:	e1bfff15 	stw	r6,-4(fp)
      /* none */



    /* nothing to do - return */
    return;
   10d3c:	0001883a 	nop

}
   10d40:	e037883a 	mov	sp,fp
   10d44:	df000017 	ldw	fp,0(sp)
   10d48:	dec00104 	addi	sp,sp,4
   10d4c:	f800283a 	ret

00010d50 <set_trigger_mode>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trigger_mode(enum trigger_type m)
{
   10d50:	defffd04 	addi	sp,sp,-12
   10d54:	dfc00215 	stw	ra,8(sp)
   10d58:	df000115 	stw	fp,4(sp)
   10d5c:	df000104 	addi	fp,sp,4
   10d60:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger mode */
    trigger_mode = m;
   10d64:	e0bfff17 	ldw	r2,-4(fp)
   10d68:	d0a59e15 	stw	r2,-27016(gp)

    /* set the new mode */
    set_mode(trigger_mode);
   10d6c:	d0a59e17 	ldw	r2,-27016(gp)
   10d70:	1009883a 	mov	r4,r2
   10d74:	0011cbc0 	call	11cbc <set_mode>


    /* all done setting the trigger mode - return */
    return;
   10d78:	0001883a 	nop

}
   10d7c:	e037883a 	mov	sp,fp
   10d80:	dfc00117 	ldw	ra,4(sp)
   10d84:	df000017 	ldw	fp,0(sp)
   10d88:	dec00204 	addi	sp,sp,8
   10d8c:	f800283a 	ret

00010d90 <get_trigger_mode>:
   Last Modified:    May 9, 2006

*/

enum trigger_type  get_trigger_mode()
{
   10d90:	deffff04 	addi	sp,sp,-4
   10d94:	df000015 	stw	fp,0(sp)
   10d98:	d839883a 	mov	fp,sp
      /* none */



    /* return the current trigger mode */
    return  trigger_mode;
   10d9c:	d0a59e17 	ldw	r2,-27016(gp)

}
   10da0:	e037883a 	mov	sp,fp
   10da4:	df000017 	ldw	fp,0(sp)
   10da8:	dec00104 	addi	sp,sp,4
   10dac:	f800283a 	ret

00010db0 <mode_down>:
   Last Modified:    May 9, 2006

*/

void  mode_down()
{
   10db0:	defffe04 	addi	sp,sp,-8
   10db4:	dfc00115 	stw	ra,4(sp)
   10db8:	df000015 	stw	fp,0(sp)
   10dbc:	d839883a 	mov	fp,sp
      /* none */



    /* move to the "next" triggering mode */
    if (trigger_mode == NORMAL_TRIGGER)
   10dc0:	d0a59e17 	ldw	r2,-27016(gp)
   10dc4:	1000031e 	bne	r2,zero,10dd4 <mode_down+0x24>
        trigger_mode = AUTO_TRIGGER;
   10dc8:	00800044 	movi	r2,1
   10dcc:	d0a59e15 	stw	r2,-27016(gp)
   10dd0:	00000706 	br	10df0 <mode_down+0x40>
    else if (trigger_mode == AUTO_TRIGGER)
   10dd4:	d0a59e17 	ldw	r2,-27016(gp)
   10dd8:	10800058 	cmpnei	r2,r2,1
   10ddc:	1000031e 	bne	r2,zero,10dec <mode_down+0x3c>
        trigger_mode = ONESHOT_TRIGGER;
   10de0:	00800084 	movi	r2,2
   10de4:	d0a59e15 	stw	r2,-27016(gp)
   10de8:	00000106 	br	10df0 <mode_down+0x40>
    else
        trigger_mode = NORMAL_TRIGGER;
   10dec:	d0259e15 	stw	zero,-27016(gp)

    /* set the new mode */
    set_mode(trigger_mode);
   10df0:	d0a59e17 	ldw	r2,-27016(gp)
   10df4:	1009883a 	mov	r4,r2
   10df8:	0011cbc0 	call	11cbc <set_mode>


    /* all done with the trigger mode - return */
    return;
   10dfc:	0001883a 	nop

}
   10e00:	e037883a 	mov	sp,fp
   10e04:	dfc00117 	ldw	ra,4(sp)
   10e08:	df000017 	ldw	fp,0(sp)
   10e0c:	dec00204 	addi	sp,sp,8
   10e10:	f800283a 	ret

00010e14 <mode_up>:
   Last Modified:    May 9, 2006

*/

void  mode_up()
{
   10e14:	defffe04 	addi	sp,sp,-8
   10e18:	dfc00115 	stw	ra,4(sp)
   10e1c:	df000015 	stw	fp,0(sp)
   10e20:	d839883a 	mov	fp,sp
      /* none */



    /* move to the "previous" triggering mode */
    if (trigger_mode == NORMAL_TRIGGER)
   10e24:	d0a59e17 	ldw	r2,-27016(gp)
   10e28:	1000031e 	bne	r2,zero,10e38 <mode_up+0x24>
        trigger_mode = ONESHOT_TRIGGER;
   10e2c:	00800084 	movi	r2,2
   10e30:	d0a59e15 	stw	r2,-27016(gp)
   10e34:	00000706 	br	10e54 <mode_up+0x40>
    else if (trigger_mode == AUTO_TRIGGER)
   10e38:	d0a59e17 	ldw	r2,-27016(gp)
   10e3c:	10800058 	cmpnei	r2,r2,1
   10e40:	1000021e 	bne	r2,zero,10e4c <mode_up+0x38>
        trigger_mode = NORMAL_TRIGGER;
   10e44:	d0259e15 	stw	zero,-27016(gp)
   10e48:	00000206 	br	10e54 <mode_up+0x40>
    else
        trigger_mode = AUTO_TRIGGER;
   10e4c:	00800044 	movi	r2,1
   10e50:	d0a59e15 	stw	r2,-27016(gp)

    /* set the new mode */
    set_mode(trigger_mode);
   10e54:	d0a59e17 	ldw	r2,-27016(gp)
   10e58:	1009883a 	mov	r4,r2
   10e5c:	0011cbc0 	call	11cbc <set_mode>


    /* all done with the trigger mode - return */
    return;
   10e60:	0001883a 	nop

}
   10e64:	e037883a 	mov	sp,fp
   10e68:	dfc00117 	ldw	ra,4(sp)
   10e6c:	df000017 	ldw	fp,0(sp)
   10e70:	dec00204 	addi	sp,sp,8
   10e74:	f800283a 	ret

00010e78 <display_mode>:
   Last Modified:    May 9, 2006

*/

void  display_mode(int x_pos, int y_pos, int style)
{
   10e78:	defffb04 	addi	sp,sp,-20
   10e7c:	dfc00415 	stw	ra,16(sp)
   10e80:	df000315 	stw	fp,12(sp)
   10e84:	df000304 	addi	fp,sp,12
   10e88:	e13ffd15 	stw	r4,-12(fp)
   10e8c:	e17ffe15 	stw	r5,-8(fp)
   10e90:	e1bfff15 	stw	r6,-4(fp)
                                             " One-Shot "  };



    /* display the trigger mode */
    plot_string(x_pos, y_pos, modes[trigger_mode], style);
   10e94:	d0a59e17 	ldw	r2,-27016(gp)
   10e98:	00c00074 	movhi	r3,1
   10e9c:	18d51904 	addi	r3,r3,21604
   10ea0:	1085883a 	add	r2,r2,r2
   10ea4:	1085883a 	add	r2,r2,r2
   10ea8:	1885883a 	add	r2,r3,r2
   10eac:	10c00017 	ldw	r3,0(r2)
   10eb0:	e0bfff17 	ldw	r2,-4(fp)
   10eb4:	e13ffd17 	ldw	r4,-12(fp)
   10eb8:	e17ffe17 	ldw	r5,-8(fp)
   10ebc:	180d883a 	mov	r6,r3
   10ec0:	100f883a 	mov	r7,r2
   10ec4:	00106a00 	call	106a0 <plot_string>


    /* all done displaying the trigger mode - return */
    return;
   10ec8:	0001883a 	nop

}
   10ecc:	e037883a 	mov	sp,fp
   10ed0:	dfc00117 	ldw	ra,4(sp)
   10ed4:	df000017 	ldw	fp,0(sp)
   10ed8:	dec00204 	addi	sp,sp,8
   10edc:	f800283a 	ret

00010ee0 <set_scale>:
   Last Modified:    Mar. 13, 1994

*/

void  set_scale(enum scale_type s)
{
   10ee0:	defffd04 	addi	sp,sp,-12
   10ee4:	dfc00215 	stw	ra,8(sp)
   10ee8:	df000115 	stw	fp,4(sp)
   10eec:	df000104 	addi	fp,sp,4
   10ef0:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the scale type */
    scale = s;
   10ef4:	e0bfff17 	ldw	r2,-4(fp)
   10ef8:	d0a59f15 	stw	r2,-27012(gp)

    /* output the scale appropriately */
    set_display_scale(scale);
   10efc:	d0a59f17 	ldw	r2,-27012(gp)
   10f00:	1009883a 	mov	r4,r2
   10f04:	0011de00 	call	11de0 <set_display_scale>


    /* all done setting the scale type - return */
    return;
   10f08:	0001883a 	nop

}
   10f0c:	e037883a 	mov	sp,fp
   10f10:	dfc00117 	ldw	ra,4(sp)
   10f14:	df000017 	ldw	fp,0(sp)
   10f18:	dec00204 	addi	sp,sp,8
   10f1c:	f800283a 	ret

00010f20 <scale_down>:
   Last Modified:    May 9, 2006

*/

void  scale_down()
{
   10f20:	defffe04 	addi	sp,sp,-8
   10f24:	dfc00115 	stw	ra,4(sp)
   10f28:	df000015 	stw	fp,0(sp)
   10f2c:	d839883a 	mov	fp,sp
      /* none */



    /* change to the "next" scale type */
    if (scale == SCALE_NONE)
   10f30:	d0a59f17 	ldw	r2,-27012(gp)
   10f34:	1000031e 	bne	r2,zero,10f44 <scale_down+0x24>
        scale = SCALE_AXES;
   10f38:	00800044 	movi	r2,1
   10f3c:	d0a59f15 	stw	r2,-27012(gp)
   10f40:	00000706 	br	10f60 <scale_down+0x40>
    else if (scale == SCALE_AXES)
   10f44:	d0a59f17 	ldw	r2,-27012(gp)
   10f48:	10800058 	cmpnei	r2,r2,1
   10f4c:	1000031e 	bne	r2,zero,10f5c <scale_down+0x3c>
        scale = SCALE_GRID;
   10f50:	00800084 	movi	r2,2
   10f54:	d0a59f15 	stw	r2,-27012(gp)
   10f58:	00000106 	br	10f60 <scale_down+0x40>
    else
        scale = SCALE_NONE;
   10f5c:	d0259f15 	stw	zero,-27012(gp)

    /* set the scale type */
    set_display_scale(scale);
   10f60:	d0a59f17 	ldw	r2,-27012(gp)
   10f64:	1009883a 	mov	r4,r2
   10f68:	0011de00 	call	11de0 <set_display_scale>


    /* all done with toggling the scale type - return */
    return;
   10f6c:	0001883a 	nop

}
   10f70:	e037883a 	mov	sp,fp
   10f74:	dfc00117 	ldw	ra,4(sp)
   10f78:	df000017 	ldw	fp,0(sp)
   10f7c:	dec00204 	addi	sp,sp,8
   10f80:	f800283a 	ret

00010f84 <scale_up>:
   Last Modified:    May 9, 2006

*/

void  scale_up()
{
   10f84:	defffe04 	addi	sp,sp,-8
   10f88:	dfc00115 	stw	ra,4(sp)
   10f8c:	df000015 	stw	fp,0(sp)
   10f90:	d839883a 	mov	fp,sp
      /* none */



    /* change to the "previous" scale type */
    if (scale == SCALE_NONE)
   10f94:	d0a59f17 	ldw	r2,-27012(gp)
   10f98:	1000031e 	bne	r2,zero,10fa8 <scale_up+0x24>
        scale = SCALE_GRID;
   10f9c:	00800084 	movi	r2,2
   10fa0:	d0a59f15 	stw	r2,-27012(gp)
   10fa4:	00000706 	br	10fc4 <scale_up+0x40>
    else if (scale == SCALE_AXES)
   10fa8:	d0a59f17 	ldw	r2,-27012(gp)
   10fac:	10800058 	cmpnei	r2,r2,1
   10fb0:	1000021e 	bne	r2,zero,10fbc <scale_up+0x38>
        scale = SCALE_NONE;
   10fb4:	d0259f15 	stw	zero,-27012(gp)
   10fb8:	00000206 	br	10fc4 <scale_up+0x40>
    else
        scale = SCALE_AXES;
   10fbc:	00800044 	movi	r2,1
   10fc0:	d0a59f15 	stw	r2,-27012(gp)

    /* set the scale type */
    set_display_scale(scale);
   10fc4:	d0a59f17 	ldw	r2,-27012(gp)
   10fc8:	1009883a 	mov	r4,r2
   10fcc:	0011de00 	call	11de0 <set_display_scale>


    /* all done with toggling the scale type - return */
    return;
   10fd0:	0001883a 	nop

}
   10fd4:	e037883a 	mov	sp,fp
   10fd8:	dfc00117 	ldw	ra,4(sp)
   10fdc:	df000017 	ldw	fp,0(sp)
   10fe0:	dec00204 	addi	sp,sp,8
   10fe4:	f800283a 	ret

00010fe8 <display_scale>:
   Last Modified:    Mar. 13, 1994

*/

void  display_scale(int x_pos, int y_pos, int style)
{
   10fe8:	defffb04 	addi	sp,sp,-20
   10fec:	dfc00415 	stw	ra,16(sp)
   10ff0:	df000315 	stw	fp,12(sp)
   10ff4:	df000304 	addi	fp,sp,12
   10ff8:	e13ffd15 	stw	r4,-12(fp)
   10ffc:	e17ffe15 	stw	r5,-8(fp)
   11000:	e1bfff15 	stw	r6,-4(fp)
                                                  " Grid"  };



    /* display the scale status */
    plot_string(x_pos, y_pos, scale_stat[scale], style);
   11004:	d0a59f17 	ldw	r2,-27012(gp)
   11008:	00c00074 	movhi	r3,1
   1100c:	18d50d04 	addi	r3,r3,21556
   11010:	1085883a 	add	r2,r2,r2
   11014:	1085883a 	add	r2,r2,r2
   11018:	1885883a 	add	r2,r3,r2
   1101c:	10c00017 	ldw	r3,0(r2)
   11020:	e0bfff17 	ldw	r2,-4(fp)
   11024:	e13ffd17 	ldw	r4,-12(fp)
   11028:	e17ffe17 	ldw	r5,-8(fp)
   1102c:	180d883a 	mov	r6,r3
   11030:	100f883a 	mov	r7,r2
   11034:	00106a00 	call	106a0 <plot_string>


    /* all done displaying the scale status - return */
    return;
   11038:	0001883a 	nop

}
   1103c:	e037883a 	mov	sp,fp
   11040:	dfc00117 	ldw	ra,4(sp)
   11044:	df000017 	ldw	fp,0(sp)
   11048:	dec00204 	addi	sp,sp,8
   1104c:	f800283a 	ret

00011050 <set_sweep>:
   Last Modified:    Mar. 8, 1994

*/

void  set_sweep(int s)
{
   11050:	defffc04 	addi	sp,sp,-16
   11054:	dfc00315 	stw	ra,12(sp)
   11058:	df000215 	stw	fp,8(sp)
   1105c:	df000204 	addi	fp,sp,8
   11060:	e13fff15 	stw	r4,-4(fp)
    int  sample_size;		/* sample size for this sweep rate */



    /* set the new sweep rate */
    sweep = s;
   11064:	e0bfff17 	ldw	r2,-4(fp)
   11068:	d0a5a015 	stw	r2,-27008(gp)

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
   1106c:	d0a5a017 	ldw	r2,-27008(gp)
   11070:	00c00074 	movhi	r3,1
   11074:	18d4e304 	addi	r3,r3,21388
   11078:	100490fa 	slli	r2,r2,3
   1107c:	1885883a 	add	r2,r3,r2
   11080:	10800017 	ldw	r2,0(r2)
   11084:	1009883a 	mov	r4,r2
   11088:	0011a780 	call	11a78 <set_sample_rate>
   1108c:	e0bffe15 	stw	r2,-8(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
   11090:	e13ffe17 	ldw	r4,-8(fp)
   11094:	0011db40 	call	11db4 <set_trace_size>


    /* all done initializing the sweep rate - return */
    return;
   11098:	0001883a 	nop

}
   1109c:	e037883a 	mov	sp,fp
   110a0:	dfc00117 	ldw	ra,4(sp)
   110a4:	df000017 	ldw	fp,0(sp)
   110a8:	dec00204 	addi	sp,sp,8
   110ac:	f800283a 	ret

000110b0 <sweep_down>:
   Last Modified:    Mar. 8, 1994

*/

void  sweep_down()
{
   110b0:	defffd04 	addi	sp,sp,-12
   110b4:	dfc00215 	stw	ra,8(sp)
   110b8:	df000115 	stw	fp,4(sp)
   110bc:	df000104 	addi	fp,sp,4
    int  sample_size;		/* sample size for the new sweep rate */



    /* decrease the sweep rate, if not already the minimum */
    if (sweep > 0)  {
   110c0:	d0a5a017 	ldw	r2,-27008(gp)
   110c4:	0080090e 	bge	zero,r2,110ec <sweep_down+0x3c>
        /* not at minimum, adjust delay for new sweep */
	adjust_trg_delay(sweep, (sweep - 1));
   110c8:	d0e5a017 	ldw	r3,-27008(gp)
   110cc:	d0a5a017 	ldw	r2,-27008(gp)
   110d0:	10bfffc4 	addi	r2,r2,-1
   110d4:	1809883a 	mov	r4,r3
   110d8:	100b883a 	mov	r5,r2
   110dc:	00115780 	call	11578 <adjust_trg_delay>
	/* now set new sweep rate */
        sweep--;
   110e0:	d0a5a017 	ldw	r2,-27008(gp)
   110e4:	10bfffc4 	addi	r2,r2,-1
   110e8:	d0a5a015 	stw	r2,-27008(gp)
    }

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
   110ec:	d0a5a017 	ldw	r2,-27008(gp)
   110f0:	00c00074 	movhi	r3,1
   110f4:	18d4e304 	addi	r3,r3,21388
   110f8:	100490fa 	slli	r2,r2,3
   110fc:	1885883a 	add	r2,r3,r2
   11100:	10800017 	ldw	r2,0(r2)
   11104:	1009883a 	mov	r4,r2
   11108:	0011a780 	call	11a78 <set_sample_rate>
   1110c:	e0bfff15 	stw	r2,-4(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
   11110:	e13fff17 	ldw	r4,-4(fp)
   11114:	0011db40 	call	11db4 <set_trace_size>


    /* all done with lowering the sweep rate - return */
    return;
   11118:	0001883a 	nop

}
   1111c:	e037883a 	mov	sp,fp
   11120:	dfc00117 	ldw	ra,4(sp)
   11124:	df000017 	ldw	fp,0(sp)
   11128:	dec00204 	addi	sp,sp,8
   1112c:	f800283a 	ret

00011130 <sweep_up>:
   Last Modified:    Mar. 8, 1994

*/

void  sweep_up()
{
   11130:	defffd04 	addi	sp,sp,-12
   11134:	dfc00215 	stw	ra,8(sp)
   11138:	df000115 	stw	fp,4(sp)
   1113c:	df000104 	addi	fp,sp,4
    int  sample_size;		/* sample size for the new sweep rate */



    /* increase the sweep rate, if not already the maximum */
    if (sweep < (NO_SWEEP_RATES - 1))  {
   11140:	d0a5a017 	ldw	r2,-27008(gp)
   11144:	10800428 	cmpgeui	r2,r2,16
   11148:	1000091e 	bne	r2,zero,11170 <sweep_up+0x40>
        /* not at maximum, adjust delay for new sweep */
	adjust_trg_delay(sweep, (sweep + 1));
   1114c:	d0e5a017 	ldw	r3,-27008(gp)
   11150:	d0a5a017 	ldw	r2,-27008(gp)
   11154:	10800044 	addi	r2,r2,1
   11158:	1809883a 	mov	r4,r3
   1115c:	100b883a 	mov	r5,r2
   11160:	00115780 	call	11578 <adjust_trg_delay>
	/* now set new sweep rate */
        sweep++;
   11164:	d0a5a017 	ldw	r2,-27008(gp)
   11168:	10800044 	addi	r2,r2,1
   1116c:	d0a5a015 	stw	r2,-27008(gp)
    }

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
   11170:	d0a5a017 	ldw	r2,-27008(gp)
   11174:	00c00074 	movhi	r3,1
   11178:	18d4e304 	addi	r3,r3,21388
   1117c:	100490fa 	slli	r2,r2,3
   11180:	1885883a 	add	r2,r3,r2
   11184:	10800017 	ldw	r2,0(r2)
   11188:	1009883a 	mov	r4,r2
   1118c:	0011a780 	call	11a78 <set_sample_rate>
   11190:	e0bfff15 	stw	r2,-4(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
   11194:	e13fff17 	ldw	r4,-4(fp)
   11198:	0011db40 	call	11db4 <set_trace_size>


    /* all done with raising the sweep rate - return */
    return;
   1119c:	0001883a 	nop

}
   111a0:	e037883a 	mov	sp,fp
   111a4:	dfc00117 	ldw	ra,4(sp)
   111a8:	df000017 	ldw	fp,0(sp)
   111ac:	dec00204 	addi	sp,sp,8
   111b0:	f800283a 	ret

000111b4 <display_sweep>:
   Last Modified:    Mar. 8, 1994

*/

void  display_sweep(int x_pos, int y_pos, int style)
{
   111b4:	defffb04 	addi	sp,sp,-20
   111b8:	dfc00415 	stw	ra,16(sp)
   111bc:	df000315 	stw	fp,12(sp)
   111c0:	df000304 	addi	fp,sp,12
   111c4:	e13ffd15 	stw	r4,-12(fp)
   111c8:	e17ffe15 	stw	r5,-8(fp)
   111cc:	e1bfff15 	stw	r6,-4(fp)
      /* none */



    /* display the sweep rate */
    plot_string(x_pos, y_pos, sweep_rates[sweep].s, style);
   111d0:	d0a5a017 	ldw	r2,-27008(gp)
   111d4:	00c00074 	movhi	r3,1
   111d8:	18d4e304 	addi	r3,r3,21388
   111dc:	100490fa 	slli	r2,r2,3
   111e0:	1885883a 	add	r2,r3,r2
   111e4:	10800104 	addi	r2,r2,4
   111e8:	10c00017 	ldw	r3,0(r2)
   111ec:	e0bfff17 	ldw	r2,-4(fp)
   111f0:	e13ffd17 	ldw	r4,-12(fp)
   111f4:	e17ffe17 	ldw	r5,-8(fp)
   111f8:	180d883a 	mov	r6,r3
   111fc:	100f883a 	mov	r7,r2
   11200:	00106a00 	call	106a0 <plot_string>


    /* all done displaying the sweep rate - return */
    return;
   11204:	0001883a 	nop

}
   11208:	e037883a 	mov	sp,fp
   1120c:	dfc00117 	ldw	ra,4(sp)
   11210:	df000017 	ldw	fp,0(sp)
   11214:	dec00204 	addi	sp,sp,8
   11218:	f800283a 	ret

0001121c <set_trg_level>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_level(int l)
{
   1121c:	defffd04 	addi	sp,sp,-12
   11220:	dfc00215 	stw	ra,8(sp)
   11224:	df000115 	stw	fp,4(sp)
   11228:	df000104 	addi	fp,sp,4
   1122c:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger level */
    level = l;
   11230:	e0bfff17 	ldw	r2,-4(fp)
   11234:	d0a5a115 	stw	r2,-27004(gp)

    /* set the trigger level in hardware too */
    set_trigger(level, slope);
   11238:	d0e5a117 	ldw	r3,-27004(gp)
   1123c:	d0a5a217 	ldw	r2,-27000(gp)
   11240:	1809883a 	mov	r4,r3
   11244:	100b883a 	mov	r5,r2
   11248:	0011a9c0 	call	11a9c <set_trigger>


    /* all done initializing the trigger level - return */
    return;
   1124c:	0001883a 	nop

}
   11250:	e037883a 	mov	sp,fp
   11254:	dfc00117 	ldw	ra,4(sp)
   11258:	df000017 	ldw	fp,0(sp)
   1125c:	dec00204 	addi	sp,sp,8
   11260:	f800283a 	ret

00011264 <trg_level_down>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_level_down()
{
   11264:	defffe04 	addi	sp,sp,-8
   11268:	dfc00115 	stw	ra,4(sp)
   1126c:	df000015 	stw	fp,0(sp)
   11270:	d839883a 	mov	fp,sp
      /* none */



    /* decrease the trigger level, if not already the minimum */
    if (level > MIN_TRG_LEVEL_SET)
   11274:	d0a5a117 	ldw	r2,-27004(gp)
   11278:	0080030e 	bge	zero,r2,11288 <trg_level_down+0x24>
        level--;
   1127c:	d0a5a117 	ldw	r2,-27004(gp)
   11280:	10bfffc4 	addi	r2,r2,-1
   11284:	d0a5a115 	stw	r2,-27004(gp)

    /* set the trigger level for the hardware */
    set_trigger(level, slope);
   11288:	d0e5a117 	ldw	r3,-27004(gp)
   1128c:	d0a5a217 	ldw	r2,-27000(gp)
   11290:	1809883a 	mov	r4,r3
   11294:	100b883a 	mov	r5,r2
   11298:	0011a9c0 	call	11a9c <set_trigger>


    /* all done with lowering the trigger level - return */
    return;
   1129c:	0001883a 	nop

}
   112a0:	e037883a 	mov	sp,fp
   112a4:	dfc00117 	ldw	ra,4(sp)
   112a8:	df000017 	ldw	fp,0(sp)
   112ac:	dec00204 	addi	sp,sp,8
   112b0:	f800283a 	ret

000112b4 <trg_level_up>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_level_up()
{
   112b4:	defffe04 	addi	sp,sp,-8
   112b8:	dfc00115 	stw	ra,4(sp)
   112bc:	df000015 	stw	fp,0(sp)
   112c0:	d839883a 	mov	fp,sp
      /* none */



    /* increase the trigger level, if not already the maximum */
    if (level < MAX_TRG_LEVEL_SET)
   112c4:	d0a5a117 	ldw	r2,-27004(gp)
   112c8:	10801fc8 	cmpgei	r2,r2,127
   112cc:	1000031e 	bne	r2,zero,112dc <trg_level_up+0x28>
        level++;
   112d0:	d0a5a117 	ldw	r2,-27004(gp)
   112d4:	10800044 	addi	r2,r2,1
   112d8:	d0a5a115 	stw	r2,-27004(gp)

    /* tell the hardware the new trigger level */
    set_trigger(level, slope);
   112dc:	d0e5a117 	ldw	r3,-27004(gp)
   112e0:	d0a5a217 	ldw	r2,-27000(gp)
   112e4:	1809883a 	mov	r4,r3
   112e8:	100b883a 	mov	r5,r2
   112ec:	0011a9c0 	call	11a9c <set_trigger>


    /* all done raising the trigger level - return */
    return;
   112f0:	0001883a 	nop

}
   112f4:	e037883a 	mov	sp,fp
   112f8:	dfc00117 	ldw	ra,4(sp)
   112fc:	df000017 	ldw	fp,0(sp)
   11300:	dec00204 	addi	sp,sp,8
   11304:	f800283a 	ret

00011308 <display_trg_level>:
   Last Modified:    Mar. 10, 1995

*/

void  display_trg_level(int x_pos, int y_pos, int style)
{
   11308:	defff704 	addi	sp,sp,-36
   1130c:	dfc00815 	stw	ra,32(sp)
   11310:	df000715 	stw	fp,28(sp)
   11314:	df000704 	addi	fp,sp,28
   11318:	e13ffd15 	stw	r4,-12(fp)
   1131c:	e17ffe15 	stw	r5,-8(fp)
   11320:	e1bfff15 	stw	r6,-4(fp)
    /* variables */
    char      level_str[] = "        "; /* string containing the trigger level */
   11324:	00880834 	movhi	r2,8224
   11328:	10880804 	addi	r2,r2,8224
   1132c:	e0bffa15 	stw	r2,-24(fp)
   11330:	00880834 	movhi	r2,8224
   11334:	10880804 	addi	r2,r2,8224
   11338:	e0bffb15 	stw	r2,-20(fp)
   1133c:	e03ffc05 	stb	zero,-16(fp)
    long int  l;			/* trigger level in mV */



    /* compute the trigger level in millivolts */
    l = ((long int) MAX_LEVEL - MIN_LEVEL) * level / (MAX_TRG_LEVEL_SET - MIN_TRG_LEVEL_SET) + MIN_LEVEL;
   11340:	d0a5a117 	ldw	r2,-27004(gp)
   11344:	1084e224 	muli	r2,r2,5000
   11348:	1009883a 	mov	r4,r2
   1134c:	01401fc4 	movi	r5,127
   11350:	0012b2c0 	call	12b2c <__divsi3>
   11354:	e0bff915 	stw	r2,-28(fp)

    /* convert the level to the string (leave first character blank) */
    cvt_num_field(l, &level_str[1]);
   11358:	e0bffa04 	addi	r2,fp,-24
   1135c:	10800044 	addi	r2,r2,1
   11360:	e13ff917 	ldw	r4,-28(fp)
   11364:	100b883a 	mov	r5,r2
   11368:	00118540 	call	11854 <cvt_num_field>

    /* add in the units */
    level_str[7] = 'V';
   1136c:	00801584 	movi	r2,86
   11370:	e0bffbc5 	stb	r2,-17(fp)


    /* now finally display the trigger level */
    plot_string(x_pos, y_pos, level_str, style);
   11374:	e0bfff17 	ldw	r2,-4(fp)
   11378:	e0fffa04 	addi	r3,fp,-24
   1137c:	e13ffd17 	ldw	r4,-12(fp)
   11380:	e17ffe17 	ldw	r5,-8(fp)
   11384:	180d883a 	mov	r6,r3
   11388:	100f883a 	mov	r7,r2
   1138c:	00106a00 	call	106a0 <plot_string>


    /* all done displaying the trigger level - return */
    return;

}
   11390:	e037883a 	mov	sp,fp
   11394:	dfc00117 	ldw	ra,4(sp)
   11398:	df000017 	ldw	fp,0(sp)
   1139c:	dec00204 	addi	sp,sp,8
   113a0:	f800283a 	ret

000113a4 <set_trg_slope>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_slope(enum slope_type s)
{
   113a4:	defffd04 	addi	sp,sp,-12
   113a8:	dfc00215 	stw	ra,8(sp)
   113ac:	df000115 	stw	fp,4(sp)
   113b0:	df000104 	addi	fp,sp,4
   113b4:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the slope type */
    slope = s;
   113b8:	e0bfff17 	ldw	r2,-4(fp)
   113bc:	d0a5a215 	stw	r2,-27000(gp)

    /* also tell the hardware what the slope is */
    set_trigger(level, slope);
   113c0:	d0e5a117 	ldw	r3,-27004(gp)
   113c4:	d0a5a217 	ldw	r2,-27000(gp)
   113c8:	1809883a 	mov	r4,r3
   113cc:	100b883a 	mov	r5,r2
   113d0:	0011a9c0 	call	11a9c <set_trigger>


    /* all done setting the trigger slope - return */
    return;
   113d4:	0001883a 	nop

}
   113d8:	e037883a 	mov	sp,fp
   113dc:	dfc00117 	ldw	ra,4(sp)
   113e0:	df000017 	ldw	fp,0(sp)
   113e4:	dec00204 	addi	sp,sp,8
   113e8:	f800283a 	ret

000113ec <trg_slope_toggle>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_slope_toggle()
{
   113ec:	defffe04 	addi	sp,sp,-8
   113f0:	dfc00115 	stw	ra,4(sp)
   113f4:	df000015 	stw	fp,0(sp)
   113f8:	d839883a 	mov	fp,sp
      /* none */



    /* toggle the trigger slope */
    if (slope == SLOPE_POSITIVE)
   113fc:	d0a5a217 	ldw	r2,-27000(gp)
   11400:	1000031e 	bne	r2,zero,11410 <trg_slope_toggle+0x24>
        slope = SLOPE_NEGATIVE;
   11404:	00800044 	movi	r2,1
   11408:	d0a5a215 	stw	r2,-27000(gp)
   1140c:	00000106 	br	11414 <trg_slope_toggle+0x28>
    else
        slope = SLOPE_POSITIVE;
   11410:	d025a215 	stw	zero,-27000(gp)

    /* set the new trigger slope */
    set_trigger(level, slope);
   11414:	d0e5a117 	ldw	r3,-27004(gp)
   11418:	d0a5a217 	ldw	r2,-27000(gp)
   1141c:	1809883a 	mov	r4,r3
   11420:	100b883a 	mov	r5,r2
   11424:	0011a9c0 	call	11a9c <set_trigger>


    /* all done with the trigger slope - return */
    return;
   11428:	0001883a 	nop

}
   1142c:	e037883a 	mov	sp,fp
   11430:	dfc00117 	ldw	ra,4(sp)
   11434:	df000017 	ldw	fp,0(sp)
   11438:	dec00204 	addi	sp,sp,8
   1143c:	f800283a 	ret

00011440 <display_trg_slope>:
   Last Modified:    Mar. 13, 1994

*/

void  display_trg_slope(int x_pos, int y_pos, int style)
{
   11440:	defffb04 	addi	sp,sp,-20
   11444:	dfc00415 	stw	ra,16(sp)
   11448:	df000315 	stw	fp,12(sp)
   1144c:	df000304 	addi	fp,sp,12
   11450:	e13ffd15 	stw	r4,-12(fp)
   11454:	e17ffe15 	stw	r5,-8(fp)
   11458:	e1bfff15 	stw	r6,-4(fp)
    const static char * const  slopes[] =  {  " +", " -"  };



    /* display the trigger slope */
    plot_string(x_pos, y_pos, slopes[slope], style);
   1145c:	d0a5a217 	ldw	r2,-27000(gp)
   11460:	1085883a 	add	r2,r2,r2
   11464:	1087883a 	add	r3,r2,r2
   11468:	d0a00004 	addi	r2,gp,-32768
   1146c:	1885883a 	add	r2,r3,r2
   11470:	10c00017 	ldw	r3,0(r2)
   11474:	e0bfff17 	ldw	r2,-4(fp)
   11478:	e13ffd17 	ldw	r4,-12(fp)
   1147c:	e17ffe17 	ldw	r5,-8(fp)
   11480:	180d883a 	mov	r6,r3
   11484:	100f883a 	mov	r7,r2
   11488:	00106a00 	call	106a0 <plot_string>


    /* all done displaying the trigger slope - return */
    return;
   1148c:	0001883a 	nop

}
   11490:	e037883a 	mov	sp,fp
   11494:	dfc00117 	ldw	ra,4(sp)
   11498:	df000017 	ldw	fp,0(sp)
   1149c:	dec00204 	addi	sp,sp,8
   114a0:	f800283a 	ret

000114a4 <set_trg_delay>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_delay(long int d)
{
   114a4:	defffd04 	addi	sp,sp,-12
   114a8:	dfc00215 	stw	ra,8(sp)
   114ac:	df000115 	stw	fp,4(sp)
   114b0:	df000104 	addi	fp,sp,4
   114b4:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger delay */
    delay = d;
   114b8:	e0bfff17 	ldw	r2,-4(fp)
   114bc:	d0a5a315 	stw	r2,-26996(gp)

    /* set the trigger delay in hardware too */
    set_delay(delay);
   114c0:	d0a5a317 	ldw	r2,-26996(gp)
   114c4:	1009883a 	mov	r4,r2
   114c8:	0011ac40 	call	11ac4 <set_delay>


    /* all done initializing the trigger delay - return */
    return;
   114cc:	0001883a 	nop

}
   114d0:	e037883a 	mov	sp,fp
   114d4:	dfc00117 	ldw	ra,4(sp)
   114d8:	df000017 	ldw	fp,0(sp)
   114dc:	dec00204 	addi	sp,sp,8
   114e0:	f800283a 	ret

000114e4 <trg_delay_down>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_delay_down()
{
   114e4:	defffe04 	addi	sp,sp,-8
   114e8:	dfc00115 	stw	ra,4(sp)
   114ec:	df000015 	stw	fp,0(sp)
   114f0:	d839883a 	mov	fp,sp
      /* none */



    /* decrease the trigger delay, if not already the minimum */
    if (delay > MIN_DELAY)
   114f4:	d0a5a317 	ldw	r2,-26996(gp)
   114f8:	0080030e 	bge	zero,r2,11508 <trg_delay_down+0x24>
        delay--;
   114fc:	d0a5a317 	ldw	r2,-26996(gp)
   11500:	10bfffc4 	addi	r2,r2,-1
   11504:	d0a5a315 	stw	r2,-26996(gp)

    /* set the trigger delay for the hardware */
    set_delay(delay);
   11508:	d0a5a317 	ldw	r2,-26996(gp)
   1150c:	1009883a 	mov	r4,r2
   11510:	0011ac40 	call	11ac4 <set_delay>


    /* all done with lowering the trigger delay - return */
    return;
   11514:	0001883a 	nop

}
   11518:	e037883a 	mov	sp,fp
   1151c:	dfc00117 	ldw	ra,4(sp)
   11520:	df000017 	ldw	fp,0(sp)
   11524:	dec00204 	addi	sp,sp,8
   11528:	f800283a 	ret

0001152c <trg_delay_up>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_delay_up()
{
   1152c:	defffe04 	addi	sp,sp,-8
   11530:	dfc00115 	stw	ra,4(sp)
   11534:	df000015 	stw	fp,0(sp)
   11538:	d839883a 	mov	fp,sp
      /* none */



    /* increase the trigger delay, if not already the maximum */
    if (delay < MAX_DELAY)
   1153c:	d0a5a317 	ldw	r2,-26996(gp)
   11540:	00f0d3d4 	movui	r3,49999
   11544:	18800316 	blt	r3,r2,11554 <trg_delay_up+0x28>
        delay++;
   11548:	d0a5a317 	ldw	r2,-26996(gp)
   1154c:	10800044 	addi	r2,r2,1
   11550:	d0a5a315 	stw	r2,-26996(gp)

    /* tell the hardware the new trigger delay */
    set_delay(delay);
   11554:	d0a5a317 	ldw	r2,-26996(gp)
   11558:	1009883a 	mov	r4,r2
   1155c:	0011ac40 	call	11ac4 <set_delay>


    /* all done raising the trigger delay - return */
    return;
   11560:	0001883a 	nop

}
   11564:	e037883a 	mov	sp,fp
   11568:	dfc00117 	ldw	ra,4(sp)
   1156c:	df000017 	ldw	fp,0(sp)
   11570:	dec00204 	addi	sp,sp,8
   11574:	f800283a 	ret

00011578 <adjust_trg_delay>:
   Last Modified:    Mar. 8, 1994

*/

static void  adjust_trg_delay(int old_sweep, int new_sweep)
{
   11578:	defffc04 	addi	sp,sp,-16
   1157c:	dfc00315 	stw	ra,12(sp)
   11580:	df000215 	stw	fp,8(sp)
   11584:	df000204 	addi	fp,sp,8
   11588:	e13ffe15 	stw	r4,-8(fp)
   1158c:	e17fff15 	stw	r5,-4(fp)
      /* none */



    /* multiply by 10 times the ratio of sweep rates */
    delay *= (10 * sweep_rates[new_sweep].sample_rate) / sweep_rates[old_sweep].sample_rate;
   11590:	00c00074 	movhi	r3,1
   11594:	18d4e304 	addi	r3,r3,21388
   11598:	e0bfff17 	ldw	r2,-4(fp)
   1159c:	100490fa 	slli	r2,r2,3
   115a0:	1885883a 	add	r2,r3,r2
   115a4:	10800017 	ldw	r2,0(r2)
   115a8:	10c002a4 	muli	r3,r2,10
   115ac:	01000074 	movhi	r4,1
   115b0:	2114e304 	addi	r4,r4,21388
   115b4:	e0bffe17 	ldw	r2,-8(fp)
   115b8:	100490fa 	slli	r2,r2,3
   115bc:	2085883a 	add	r2,r4,r2
   115c0:	10800017 	ldw	r2,0(r2)
   115c4:	1809883a 	mov	r4,r3
   115c8:	100b883a 	mov	r5,r2
   115cc:	0012b2c0 	call	12b2c <__divsi3>
   115d0:	1007883a 	mov	r3,r2
   115d4:	d0a5a317 	ldw	r2,-26996(gp)
   115d8:	1885383a 	mul	r2,r3,r2
   115dc:	d0a5a315 	stw	r2,-26996(gp)
    /* now divide the factor of 10 back out */
    delay /= 10;
   115e0:	d0a5a317 	ldw	r2,-26996(gp)
   115e4:	1009883a 	mov	r4,r2
   115e8:	01400284 	movi	r5,10
   115ec:	0012b2c0 	call	12b2c <__divsi3>
   115f0:	d0a5a315 	stw	r2,-26996(gp)

    /* make sure delay is not out of range */
    if (delay > MAX_DELAY)
   115f4:	d0a5a317 	ldw	r2,-26996(gp)
   115f8:	00f0d414 	movui	r3,50000
   115fc:	1880020e 	bge	r3,r2,11608 <adjust_trg_delay+0x90>
        /* delay is too large - set to maximum */
        delay = MAX_DELAY;
   11600:	00b0d414 	movui	r2,50000
   11604:	d0a5a315 	stw	r2,-26996(gp)
    if (delay < MIN_DELAY)
   11608:	d0a5a317 	ldw	r2,-26996(gp)
   1160c:	1000010e 	bge	r2,zero,11614 <adjust_trg_delay+0x9c>
        /* delay is too small - set to minimum */
	delay = MIN_DELAY;
   11610:	d025a315 	stw	zero,-26996(gp)


    /* tell the hardware the new trigger delay */
    set_delay(delay);
   11614:	d0a5a317 	ldw	r2,-26996(gp)
   11618:	1009883a 	mov	r4,r2
   1161c:	0011ac40 	call	11ac4 <set_delay>


    /* all done adjusting the trigger delay - return */
    return;
   11620:	0001883a 	nop

}
   11624:	e037883a 	mov	sp,fp
   11628:	dfc00117 	ldw	ra,4(sp)
   1162c:	df000017 	ldw	fp,0(sp)
   11630:	dec00204 	addi	sp,sp,8
   11634:	f800283a 	ret

00011638 <display_trg_delay>:
   Last Modified:    May 3, 2006

*/

void  display_trg_delay(int x_pos, int y_pos, int style)
{
   11638:	defff604 	addi	sp,sp,-40
   1163c:	dfc00915 	stw	ra,36(sp)
   11640:	df000815 	stw	fp,32(sp)
   11644:	df000804 	addi	fp,sp,32
   11648:	e13ffd15 	stw	r4,-12(fp)
   1164c:	e17ffe15 	stw	r5,-8(fp)
   11650:	e1bfff15 	stw	r6,-4(fp)
    /* variables */
    char      delay_str[] = "         "; /* string containing the trigger delay */
   11654:	00880834 	movhi	r2,8224
   11658:	10880804 	addi	r2,r2,8224
   1165c:	e0bffa15 	stw	r2,-24(fp)
   11660:	00880834 	movhi	r2,8224
   11664:	10880804 	addi	r2,r2,8224
   11668:	e0bffb15 	stw	r2,-20(fp)
   1166c:	00800804 	movi	r2,32
   11670:	e0bffc0d 	sth	r2,-16(fp)
    long int  d;                         /* delay in appropriate units */


    /* compute the delay in the appropriate units */
    /* have to watch out for overflow, so be careful */
    if (sweep_rates[sweep].sample_rate > 1000000L)  {
   11674:	d0a5a017 	ldw	r2,-27008(gp)
   11678:	00c00074 	movhi	r3,1
   1167c:	18d4e304 	addi	r3,r3,21388
   11680:	100490fa 	slli	r2,r2,3
   11684:	1885883a 	add	r2,r3,r2
   11688:	10800017 	ldw	r2,0(r2)
   1168c:	00c003f4 	movhi	r3,15
   11690:	18d09004 	addi	r3,r3,16960
   11694:	1880140e 	bge	r3,r2,116e8 <display_trg_delay+0xb0>
        /* have a fast sweep rate, could overflow */
        /* first compute in units of 100 ns */
        d = delay * (10000000L / sweep_rates[sweep].sample_rate);
   11698:	d0a5a017 	ldw	r2,-27008(gp)
   1169c:	00c00074 	movhi	r3,1
   116a0:	18d4e304 	addi	r3,r3,21388
   116a4:	100490fa 	slli	r2,r2,3
   116a8:	1885883a 	add	r2,r3,r2
   116ac:	10800017 	ldw	r2,0(r2)
   116b0:	01002674 	movhi	r4,153
   116b4:	2125a004 	addi	r4,r4,-27008
   116b8:	100b883a 	mov	r5,r2
   116bc:	0012b2c0 	call	12b2c <__divsi3>
   116c0:	1007883a 	mov	r3,r2
   116c4:	d0a5a317 	ldw	r2,-26996(gp)
   116c8:	1885383a 	mul	r2,r3,r2
   116cc:	e0bff915 	stw	r2,-28(fp)
	/* now convert to nanoseconds */
	d *= 100L;
   116d0:	e0bff917 	ldw	r2,-28(fp)
   116d4:	10801924 	muli	r2,r2,100
   116d8:	e0bff915 	stw	r2,-28(fp)
	/* need to divide by 1000 to get to microseconds */
	units_adj = 1000;
   116dc:	0080fa04 	movi	r2,1000
   116e0:	e0bff815 	stw	r2,-32(fp)
   116e4:	00001006 	br	11728 <display_trg_delay+0xf0>
    }
    else  {
        /* slow sweep rate, don't have to worry about overflow */
        d = delay * (1000000L / sweep_rates[sweep].sample_rate);
   116e8:	d0a5a017 	ldw	r2,-27008(gp)
   116ec:	00c00074 	movhi	r3,1
   116f0:	18d4e304 	addi	r3,r3,21388
   116f4:	100490fa 	slli	r2,r2,3
   116f8:	1885883a 	add	r2,r3,r2
   116fc:	10800017 	ldw	r2,0(r2)
   11700:	010003f4 	movhi	r4,15
   11704:	21109004 	addi	r4,r4,16960
   11708:	100b883a 	mov	r5,r2
   1170c:	0012b2c0 	call	12b2c <__divsi3>
   11710:	1007883a 	mov	r3,r2
   11714:	d0a5a317 	ldw	r2,-26996(gp)
   11718:	1885383a 	mul	r2,r3,r2
   1171c:	e0bff915 	stw	r2,-28(fp)
	/* already in microseconds, so adjustment is 1 */
	units_adj = 1;
   11720:	00800044 	movi	r2,1
   11724:	e0bff815 	stw	r2,-32(fp)
    }

    /* convert it to the string (leave first character blank) */
    cvt_num_field(d, &delay_str[1]);
   11728:	e0bffa04 	addi	r2,fp,-24
   1172c:	10800044 	addi	r2,r2,1
   11730:	e13ff917 	ldw	r4,-28(fp)
   11734:	100b883a 	mov	r5,r2
   11738:	00118540 	call	11854 <cvt_num_field>

    /* add in the units */
    if (((d / units_adj) < 1000) && ((d / units_adj) > -1000) && (units_adj == 1000)) {
   1173c:	e13ff917 	ldw	r4,-28(fp)
   11740:	e17ff817 	ldw	r5,-32(fp)
   11744:	0012b2c0 	call	12b2c <__divsi3>
   11748:	1080fa08 	cmpgei	r2,r2,1000
   1174c:	10000d1e 	bne	r2,zero,11784 <display_trg_delay+0x14c>
   11750:	e13ff917 	ldw	r4,-28(fp)
   11754:	e17ff817 	ldw	r5,-32(fp)
   11758:	0012b2c0 	call	12b2c <__divsi3>
   1175c:	10bf0650 	cmplti	r2,r2,-999
   11760:	1000081e 	bne	r2,zero,11784 <display_trg_delay+0x14c>
   11764:	e0bff817 	ldw	r2,-32(fp)
   11768:	1080fa18 	cmpnei	r2,r2,1000
   1176c:	1000051e 	bne	r2,zero,11784 <display_trg_delay+0x14c>
        /* delay is in microseconds */
	delay_str[7] = '\004';
   11770:	00800104 	movi	r2,4
   11774:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
   11778:	00801cc4 	movi	r2,115
   1177c:	e0bffc05 	stb	r2,-16(fp)
   11780:	00002806 	br	11824 <display_trg_delay+0x1ec>
    }
    else if (((d / units_adj) < 1000000) && ((d / units_adj) > -1000000)) {
   11784:	e13ff917 	ldw	r4,-28(fp)
   11788:	e17ff817 	ldw	r5,-32(fp)
   1178c:	0012b2c0 	call	12b2c <__divsi3>
   11790:	00c003f4 	movhi	r3,15
   11794:	18d08fc4 	addi	r3,r3,16959
   11798:	18800c16 	blt	r3,r2,117cc <display_trg_delay+0x194>
   1179c:	e13ff917 	ldw	r4,-28(fp)
   117a0:	e17ff817 	ldw	r5,-32(fp)
   117a4:	0012b2c0 	call	12b2c <__divsi3>
   117a8:	1007883a 	mov	r3,r2
   117ac:	00bffc74 	movhi	r2,65521
   117b0:	10af7044 	addi	r2,r2,-16959
   117b4:	18800516 	blt	r3,r2,117cc <display_trg_delay+0x194>
        /* delay is in milliseconds */
	delay_str[7] = 'm';
   117b8:	00801b44 	movi	r2,109
   117bc:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
   117c0:	00801cc4 	movi	r2,115
   117c4:	e0bffc05 	stb	r2,-16(fp)
   117c8:	00001606 	br	11824 <display_trg_delay+0x1ec>
    }
    else if (((d / units_adj) < 1000000000) && ((d / units_adj) > -1000000000))  {
   117cc:	e13ff917 	ldw	r4,-28(fp)
   117d0:	e17ff817 	ldw	r5,-32(fp)
   117d4:	0012b2c0 	call	12b2c <__divsi3>
   117d8:	00cee6f4 	movhi	r3,15259
   117dc:	18f27fc4 	addi	r3,r3,-13825
   117e0:	18800c16 	blt	r3,r2,11814 <display_trg_delay+0x1dc>
   117e4:	e13ff917 	ldw	r4,-28(fp)
   117e8:	e17ff817 	ldw	r5,-32(fp)
   117ec:	0012b2c0 	call	12b2c <__divsi3>
   117f0:	1007883a 	mov	r3,r2
   117f4:	00b11974 	movhi	r2,50277
   117f8:	108d8044 	addi	r2,r2,13825
   117fc:	18800516 	blt	r3,r2,11814 <display_trg_delay+0x1dc>
        /* delay is in seconds */
	delay_str[7] = 's';
   11800:	00801cc4 	movi	r2,115
   11804:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = ' ';
   11808:	00800804 	movi	r2,32
   1180c:	e0bffc05 	stb	r2,-16(fp)
   11810:	00000406 	br	11824 <display_trg_delay+0x1ec>
    }
    else  {
        /* delay is in kiloseconds */
	delay_str[7] = 'k';
   11814:	00801ac4 	movi	r2,107
   11818:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
   1181c:	00801cc4 	movi	r2,115
   11820:	e0bffc05 	stb	r2,-16(fp)
    }


    /* now actually display the trigger delay */
    plot_string(x_pos, y_pos, delay_str, style);
   11824:	e0bfff17 	ldw	r2,-4(fp)
   11828:	e0fffa04 	addi	r3,fp,-24
   1182c:	e13ffd17 	ldw	r4,-12(fp)
   11830:	e17ffe17 	ldw	r5,-8(fp)
   11834:	180d883a 	mov	r6,r3
   11838:	100f883a 	mov	r7,r2
   1183c:	00106a00 	call	106a0 <plot_string>


    /* all done displaying the trigger delay - return */
    return;

}
   11840:	e037883a 	mov	sp,fp
   11844:	dfc00117 	ldw	ra,4(sp)
   11848:	df000017 	ldw	fp,0(sp)
   1184c:	dec00204 	addi	sp,sp,8
   11850:	f800283a 	ret

00011854 <cvt_num_field>:
   Last Modified:    Mar. 8, 1994

*/

static void  cvt_num_field(long int n, char *s)
{
   11854:	defff804 	addi	sp,sp,-32
   11858:	dfc00715 	stw	ra,28(sp)
   1185c:	df000615 	stw	fp,24(sp)
   11860:	dc000515 	stw	r16,20(sp)
   11864:	df000504 	addi	fp,sp,20
   11868:	e13ffe15 	stw	r4,-8(fp)
   1186c:	e17fff15 	stw	r5,-4(fp)
    /* variables */
    int  dp = 3;		/* digits to right of decimal point */
   11870:	008000c4 	movi	r2,3
   11874:	e0bffb15 	stw	r2,-20(fp)
    int  d;			/* digit weight (power of 10) */

    int  i = 0;			/* string index */
   11878:	e03ffd15 	stw	zero,-12(fp)



    /* first get the sign (and make n positive for conversion) */
    if (n < 0)  {
   1187c:	e0bffe17 	ldw	r2,-8(fp)
   11880:	10000c0e 	bge	r2,zero,118b4 <cvt_num_field+0x60>
        /* n is negative, set sign and convert to positive */
	s[i++] = '-';
   11884:	e0bffd17 	ldw	r2,-12(fp)
   11888:	e0ffff17 	ldw	r3,-4(fp)
   1188c:	1885883a 	add	r2,r3,r2
   11890:	00c00b44 	movi	r3,45
   11894:	10c00005 	stb	r3,0(r2)
   11898:	e0bffd17 	ldw	r2,-12(fp)
   1189c:	10800044 	addi	r2,r2,1
   118a0:	e0bffd15 	stw	r2,-12(fp)
	n = -n;
   118a4:	e0bffe17 	ldw	r2,-8(fp)
   118a8:	0085c83a 	sub	r2,zero,r2
   118ac:	e0bffe15 	stw	r2,-8(fp)
	s[i++] = '+';
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
   118b0:	00001106 	br	118f8 <cvt_num_field+0xa4>
	s[i++] = '-';
	n = -n;
    }
    else  {
        /* n is positive, set sign only */
	s[i++] = '+';
   118b4:	e0bffd17 	ldw	r2,-12(fp)
   118b8:	e0ffff17 	ldw	r3,-4(fp)
   118bc:	1885883a 	add	r2,r3,r2
   118c0:	00c00ac4 	movi	r3,43
   118c4:	10c00005 	stb	r3,0(r2)
   118c8:	e0bffd17 	ldw	r2,-12(fp)
   118cc:	10800044 	addi	r2,r2,1
   118d0:	e0bffd15 	stw	r2,-12(fp)
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
   118d4:	00000806 	br	118f8 <cvt_num_field+0xa4>
        /* have more than 4 digits - get rid of one */
	n /= 10;
   118d8:	e0bffe17 	ldw	r2,-8(fp)
   118dc:	1009883a 	mov	r4,r2
   118e0:	01400284 	movi	r5,10
   118e4:	0012b2c0 	call	12b2c <__divsi3>
   118e8:	e0bffe15 	stw	r2,-8(fp)
	/* adjust the decimal point */
	dp--;
   118ec:	e0bffb17 	ldw	r2,-20(fp)
   118f0:	10bfffc4 	addi	r2,r2,-1
   118f4:	e0bffb15 	stw	r2,-20(fp)
	s[i++] = '+';
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
   118f8:	e0bffe17 	ldw	r2,-8(fp)
   118fc:	1089c408 	cmpgei	r2,r2,10000
   11900:	103ff51e 	bne	r2,zero,118d8 <cvt_num_field+0x84>
	dp--;
    }

    /* if decimal point is non-positive, make positive */
    /* (assume will take care of adjustment with output units in this case) */
    while (dp <= 0)
   11904:	00000306 	br	11914 <cvt_num_field+0xc0>
       dp += 3;
   11908:	e0bffb17 	ldw	r2,-20(fp)
   1190c:	108000c4 	addi	r2,r2,3
   11910:	e0bffb15 	stw	r2,-20(fp)
	dp--;
    }

    /* if decimal point is non-positive, make positive */
    /* (assume will take care of adjustment with output units in this case) */
    while (dp <= 0)
   11914:	e0bffb17 	ldw	r2,-20(fp)
   11918:	00bffb0e 	bge	zero,r2,11908 <cvt_num_field+0xb4>
       dp += 3;


    /* adjust dp to be digits to the right of the decimal point */
    /* (assuming 4 digits) */
    dp = 4 - dp;
   1191c:	00c00104 	movi	r3,4
   11920:	e0bffb17 	ldw	r2,-20(fp)
   11924:	1885c83a 	sub	r2,r3,r2
   11928:	e0bffb15 	stw	r2,-20(fp)


    /* finally, loop getting and converting digits */
    for (d = 1000; d > 0; d /= 10)  {
   1192c:	0080fa04 	movi	r2,1000
   11930:	e0bffc15 	stw	r2,-16(fp)
   11934:	00002406 	br	119c8 <cvt_num_field+0x174>

        /* check if need decimal the decimal point now */
	if (dp-- == 0)
   11938:	e0bffb17 	ldw	r2,-20(fp)
   1193c:	1005003a 	cmpeq	r2,r2,zero
   11940:	e0fffb17 	ldw	r3,-20(fp)
   11944:	18ffffc4 	addi	r3,r3,-1
   11948:	e0fffb15 	stw	r3,-20(fp)
   1194c:	10803fcc 	andi	r2,r2,255
   11950:	10000826 	beq	r2,zero,11974 <cvt_num_field+0x120>
	    /* time for decimal point */
	    s[i++] = '.';
   11954:	e0bffd17 	ldw	r2,-12(fp)
   11958:	e0ffff17 	ldw	r3,-4(fp)
   1195c:	1885883a 	add	r2,r3,r2
   11960:	00c00b84 	movi	r3,46
   11964:	10c00005 	stb	r3,0(r2)
   11968:	e0bffd17 	ldw	r2,-12(fp)
   1196c:	10800044 	addi	r2,r2,1
   11970:	e0bffd15 	stw	r2,-12(fp)

	/* get and convert this digit */
	s[i++] = (n / d) + '0';
   11974:	e0bffd17 	ldw	r2,-12(fp)
   11978:	e0ffff17 	ldw	r3,-4(fp)
   1197c:	18a1883a 	add	r16,r3,r2
   11980:	e13ffe17 	ldw	r4,-8(fp)
   11984:	e17ffc17 	ldw	r5,-16(fp)
   11988:	0012b2c0 	call	12b2c <__divsi3>
   1198c:	10800c04 	addi	r2,r2,48
   11990:	80800005 	stb	r2,0(r16)
   11994:	e0bffd17 	ldw	r2,-12(fp)
   11998:	10800044 	addi	r2,r2,1
   1199c:	e0bffd15 	stw	r2,-12(fp)
	/* remove this digit from n */
	n %= d;
   119a0:	e0bffe17 	ldw	r2,-8(fp)
   119a4:	1009883a 	mov	r4,r2
   119a8:	e17ffc17 	ldw	r5,-16(fp)
   119ac:	0012b7c0 	call	12b7c <__modsi3>
   119b0:	e0bffe15 	stw	r2,-8(fp)
    /* (assuming 4 digits) */
    dp = 4 - dp;


    /* finally, loop getting and converting digits */
    for (d = 1000; d > 0; d /= 10)  {
   119b4:	e0bffc17 	ldw	r2,-16(fp)
   119b8:	1009883a 	mov	r4,r2
   119bc:	01400284 	movi	r5,10
   119c0:	0012b2c0 	call	12b2c <__divsi3>
   119c4:	e0bffc15 	stw	r2,-16(fp)
   119c8:	e0bffc17 	ldw	r2,-16(fp)
   119cc:	00bfda16 	blt	zero,r2,11938 <cvt_num_field+0xe4>
	n %= d;
    }


    /* all done converting the number, return */
    return;
   119d0:	0001883a 	nop

}
   119d4:	e037883a 	mov	sp,fp
   119d8:	dfc00217 	ldw	ra,8(sp)
   119dc:	df000117 	ldw	fp,4(sp)
   119e0:	dc000017 	ldw	r16,0(sp)
   119e4:	dec00304 	addi	sp,sp,12
   119e8:	f800283a 	ret

000119ec <key_available>:


/* keypad functions */

unsigned char  key_available()
{
   119ec:	deffff04 	addi	sp,sp,-4
   119f0:	df000015 	stw	fp,0(sp)
   119f4:	d839883a 	mov	fp,sp
    return  FALSE;
   119f8:	0005883a 	mov	r2,zero
}
   119fc:	e037883a 	mov	sp,fp
   11a00:	df000017 	ldw	fp,0(sp)
   11a04:	dec00104 	addi	sp,sp,4
   11a08:	f800283a 	ret

00011a0c <getkey>:

int  getkey()
{
   11a0c:	deffff04 	addi	sp,sp,-4
   11a10:	df000015 	stw	fp,0(sp)
   11a14:	d839883a 	mov	fp,sp
    return  KEY_ILLEGAL;
   11a18:	00800184 	movi	r2,6
}
   11a1c:	e037883a 	mov	sp,fp
   11a20:	df000017 	ldw	fp,0(sp)
   11a24:	dec00104 	addi	sp,sp,4
   11a28:	f800283a 	ret

00011a2c <clear_display>:


/* display functions  */

void  clear_display()
{
   11a2c:	deffff04 	addi	sp,sp,-4
   11a30:	df000015 	stw	fp,0(sp)
   11a34:	d839883a 	mov	fp,sp
    return;
   11a38:	0001883a 	nop
}
   11a3c:	e037883a 	mov	sp,fp
   11a40:	df000017 	ldw	fp,0(sp)
   11a44:	dec00104 	addi	sp,sp,4
   11a48:	f800283a 	ret

00011a4c <plot_pixel>:

void  plot_pixel(unsigned int x, unsigned int y, int p)
{
   11a4c:	defffc04 	addi	sp,sp,-16
   11a50:	df000315 	stw	fp,12(sp)
   11a54:	df000304 	addi	fp,sp,12
   11a58:	e13ffd15 	stw	r4,-12(fp)
   11a5c:	e17ffe15 	stw	r5,-8(fp)
   11a60:	e1bfff15 	stw	r6,-4(fp)
    return;
   11a64:	0001883a 	nop
}
   11a68:	e037883a 	mov	sp,fp
   11a6c:	df000017 	ldw	fp,0(sp)
   11a70:	dec00104 	addi	sp,sp,4
   11a74:	f800283a 	ret

00011a78 <set_sample_rate>:


/* sampling parameter functions */

int  set_sample_rate(long int rate)
{
   11a78:	defffe04 	addi	sp,sp,-8
   11a7c:	df000115 	stw	fp,4(sp)
   11a80:	df000104 	addi	fp,sp,4
   11a84:	e13fff15 	stw	r4,-4(fp)
    return  SIZE_X;
   11a88:	00807804 	movi	r2,480
}
   11a8c:	e037883a 	mov	sp,fp
   11a90:	df000017 	ldw	fp,0(sp)
   11a94:	dec00104 	addi	sp,sp,4
   11a98:	f800283a 	ret

00011a9c <set_trigger>:

void  set_trigger(int level, int slope)
{
   11a9c:	defffd04 	addi	sp,sp,-12
   11aa0:	df000215 	stw	fp,8(sp)
   11aa4:	df000204 	addi	fp,sp,8
   11aa8:	e13ffe15 	stw	r4,-8(fp)
   11aac:	e17fff15 	stw	r5,-4(fp)
    return;
   11ab0:	0001883a 	nop
}
   11ab4:	e037883a 	mov	sp,fp
   11ab8:	df000017 	ldw	fp,0(sp)
   11abc:	dec00104 	addi	sp,sp,4
   11ac0:	f800283a 	ret

00011ac4 <set_delay>:

void  set_delay(long int delay)
{
   11ac4:	defffe04 	addi	sp,sp,-8
   11ac8:	df000115 	stw	fp,4(sp)
   11acc:	df000104 	addi	fp,sp,4
   11ad0:	e13fff15 	stw	r4,-4(fp)
    return;
   11ad4:	0001883a 	nop
}
   11ad8:	e037883a 	mov	sp,fp
   11adc:	df000017 	ldw	fp,0(sp)
   11ae0:	dec00104 	addi	sp,sp,4
   11ae4:	f800283a 	ret

00011ae8 <start_sample>:


/* sampling functions */

void  start_sample(int auto_trigger)
{
   11ae8:	defffe04 	addi	sp,sp,-8
   11aec:	df000115 	stw	fp,4(sp)
   11af0:	df000104 	addi	fp,sp,4
   11af4:	e13fff15 	stw	r4,-4(fp)
    return;
   11af8:	0001883a 	nop
}
   11afc:	e037883a 	mov	sp,fp
   11b00:	df000017 	ldw	fp,0(sp)
   11b04:	dec00104 	addi	sp,sp,4
   11b08:	f800283a 	ret

00011b0c <sample_done>:

unsigned char  *sample_done()
{
   11b0c:	deffff04 	addi	sp,sp,-4
   11b10:	df000015 	stw	fp,0(sp)
   11b14:	d839883a 	mov	fp,sp
    return  NULL;
   11b18:	0005883a 	mov	r2,zero
}
   11b1c:	e037883a 	mov	sp,fp
   11b20:	df000017 	ldw	fp,0(sp)
   11b24:	dec00104 	addi	sp,sp,4
   11b28:	f800283a 	ret

00011b2c <get_test_sample>:
   Last Modified:    May 3, 2006

*/

void  get_test_sample(long int sample_rate, int sample_size, unsigned char *sample)
{
   11b2c:	defff904 	addi	sp,sp,-28
   11b30:	dfc00615 	stw	ra,24(sp)
   11b34:	df000515 	stw	fp,20(sp)
   11b38:	df000504 	addi	fp,sp,20
   11b3c:	e13ffd15 	stw	r4,-12(fp)
   11b40:	e17ffe15 	stw	r5,-8(fp)
   11b44:	e1bfff15 	stw	r6,-4(fp)
	    63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
	    63,  63,  63,  63,  63,  63,  64,  64,  64,  64,  64,  64,  64,
	    64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64
	  };

    long int  sample_pt = 0;	/* current sample within the waveform */
   11b48:	e03ffb15 	stw	zero,-20(fp)

    int       sample_sign = 1;	/* sample waveform sign */
   11b4c:	00800044 	movi	r2,1
   11b50:	e0bffc15 	stw	r2,-16(fp)



    /* loop, getting sample points */
    while (sample_size-- > 0)  {
   11b54:	00003306 	br	11c24 <get_test_sample+0xf8>

        /* get this sample point (value based on sign) */
	if (sample_sign > 0)
   11b58:	e0bffc17 	ldw	r2,-16(fp)
   11b5c:	0080100e 	bge	zero,r2,11ba0 <get_test_sample+0x74>
	    *sample++ = waveform[sample_pt/20] + 127;
   11b60:	e0bffb17 	ldw	r2,-20(fp)
   11b64:	1009883a 	mov	r4,r2
   11b68:	01400504 	movi	r5,20
   11b6c:	0012b2c0 	call	12b2c <__divsi3>
   11b70:	00c00074 	movhi	r3,1
   11b74:	18d51c04 	addi	r3,r3,21616
   11b78:	1885883a 	add	r2,r3,r2
   11b7c:	10800003 	ldbu	r2,0(r2)
   11b80:	10801fc4 	addi	r2,r2,127
   11b84:	1007883a 	mov	r3,r2
   11b88:	e0bfff17 	ldw	r2,-4(fp)
   11b8c:	10c00005 	stb	r3,0(r2)
   11b90:	e0bfff17 	ldw	r2,-4(fp)
   11b94:	10800044 	addi	r2,r2,1
   11b98:	e0bfff15 	stw	r2,-4(fp)
   11b9c:	00001006 	br	11be0 <get_test_sample+0xb4>
	else
	    *sample++ = 128 - waveform[sample_pt/20];
   11ba0:	e0bffb17 	ldw	r2,-20(fp)
   11ba4:	1009883a 	mov	r4,r2
   11ba8:	01400504 	movi	r5,20
   11bac:	0012b2c0 	call	12b2c <__divsi3>
   11bb0:	00c00074 	movhi	r3,1
   11bb4:	18d51c04 	addi	r3,r3,21616
   11bb8:	1885883a 	add	r2,r3,r2
   11bbc:	10800003 	ldbu	r2,0(r2)
   11bc0:	00ffe004 	movi	r3,-128
   11bc4:	1885c83a 	sub	r2,r3,r2
   11bc8:	1007883a 	mov	r3,r2
   11bcc:	e0bfff17 	ldw	r2,-4(fp)
   11bd0:	10c00005 	stb	r3,0(r2)
   11bd4:	e0bfff17 	ldw	r2,-4(fp)
   11bd8:	10800044 	addi	r2,r2,1
   11bdc:	e0bfff15 	stw	r2,-4(fp)

	/* compute the time for the next sample point */
	sample_pt += (10000000L / sample_rate);
   11be0:	01002674 	movhi	r4,153
   11be4:	2125a004 	addi	r4,r4,-27008
   11be8:	e17ffd17 	ldw	r5,-12(fp)
   11bec:	0012b2c0 	call	12b2c <__divsi3>
   11bf0:	e0fffb17 	ldw	r3,-20(fp)
   11bf4:	1885883a 	add	r2,r3,r2
   11bf8:	e0bffb15 	stw	r2,-20(fp)
	/* keep sample_pt within the waveform (need to scale it) */
	while (sample_pt >= (20 * NO_TEST_PTS))  {
   11bfc:	00000606 	br	11c18 <get_test_sample+0xec>
	    /* keep sample_pt within the test waveform */
	    sample_pt -= (20 * NO_TEST_PTS);
   11c00:	e0bffb17 	ldw	r2,-20(fp)
   11c04:	10b6a004 	addi	r2,r2,-9600
   11c08:	e0bffb15 	stw	r2,-20(fp)
	    /* each time through the waveform, invert it */
	    sample_sign = -sample_sign;
   11c0c:	e0bffc17 	ldw	r2,-16(fp)
   11c10:	0085c83a 	sub	r2,zero,r2
   11c14:	e0bffc15 	stw	r2,-16(fp)
	    *sample++ = 128 - waveform[sample_pt/20];

	/* compute the time for the next sample point */
	sample_pt += (10000000L / sample_rate);
	/* keep sample_pt within the waveform (need to scale it) */
	while (sample_pt >= (20 * NO_TEST_PTS))  {
   11c18:	e0bffb17 	ldw	r2,-20(fp)
   11c1c:	10896028 	cmpgeui	r2,r2,9600
   11c20:	103ff71e 	bne	r2,zero,11c00 <get_test_sample+0xd4>
    int       sample_sign = 1;	/* sample waveform sign */



    /* loop, getting sample points */
    while (sample_size-- > 0)  {
   11c24:	e0bffe17 	ldw	r2,-8(fp)
   11c28:	0084803a 	cmplt	r2,zero,r2
   11c2c:	e0fffe17 	ldw	r3,-8(fp)
   11c30:	18ffffc4 	addi	r3,r3,-1
   11c34:	e0fffe15 	stw	r3,-8(fp)
   11c38:	10803fcc 	andi	r2,r2,255
   11c3c:	103fc61e 	bne	r2,zero,11b58 <get_test_sample+0x2c>
        }
    }


    /* done getting the sample - return */
    return;
   11c40:	0001883a 	nop

}
   11c44:	e037883a 	mov	sp,fp
   11c48:	dfc00117 	ldw	ra,4(sp)
   11c4c:	df000017 	ldw	fp,0(sp)
   11c50:	dec00204 	addi	sp,sp,8
   11c54:	f800283a 	ret

00011c58 <init_trace>:
   Last Modified:    May 9, 2006

*/

void  init_trace()
{
   11c58:	defffe04 	addi	sp,sp,-8
   11c5c:	dfc00115 	stw	ra,4(sp)
   11c60:	df000015 	stw	fp,0(sp)
   11c64:	d839883a 	mov	fp,sp


    /* initialize system status variables */

    /* ready for a trace */
    trace_status = TRUE;
   11c68:	00800044 	movi	r2,1
   11c6c:	d0a5a415 	stw	r2,-26992(gp)

    /* not currently sampling data */
    sampling = FALSE;
   11c70:	d025a515 	stw	zero,-26988(gp)

    /* turn off the displayed scale */
    cur_scale = SCALE_NONE;
   11c74:	d025a715 	stw	zero,-26980(gp)

    /* sample size is the screen size */
    sample_size = SIZE_X;
   11c78:	00807804 	movi	r2,480
   11c7c:	d0a5a615 	stw	r2,-26984(gp)


    /* clear save areas */
    clear_saved_areas();
   11c80:	00121ac0 	call	121ac <clear_saved_areas>

    /* also clear the general saved area location variables (off-screen) */
    saved_pos_x = SIZE_X + 1;
   11c84:	00807844 	movi	r2,481
   11c88:	d0a5a815 	stw	r2,-26976(gp)
    saved_pos_y = SIZE_Y + 1;
   11c8c:	00802044 	movi	r2,129
   11c90:	d0a5a915 	stw	r2,-26972(gp)
    saved_end_x = SIZE_X + 1;
   11c94:	00807844 	movi	r2,481
   11c98:	d0a5aa15 	stw	r2,-26968(gp)
    saved_end_y = SIZE_Y + 1;
   11c9c:	00802044 	movi	r2,129
   11ca0:	d0a5ab15 	stw	r2,-26964(gp)


    /* done initializing, return */
    return;
   11ca4:	0001883a 	nop

}
   11ca8:	e037883a 	mov	sp,fp
   11cac:	dfc00117 	ldw	ra,4(sp)
   11cb0:	df000017 	ldw	fp,0(sp)
   11cb4:	dec00204 	addi	sp,sp,8
   11cb8:	f800283a 	ret

00011cbc <set_mode>:
   Last Modified:    May 27, 2008

*/

void  set_mode(enum trigger_type trigger_mode)
{
   11cbc:	defffe04 	addi	sp,sp,-8
   11cc0:	df000115 	stw	fp,4(sp)
   11cc4:	df000104 	addi	fp,sp,4
   11cc8:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* if not one-shot triggering - ready for trace too */
    trace_status = (trigger_mode != ONESHOT_TRIGGER);
   11ccc:	e0bfff17 	ldw	r2,-4(fp)
   11cd0:	10800098 	cmpnei	r2,r2,2
   11cd4:	10803fcc 	andi	r2,r2,255
   11cd8:	d0a5a415 	stw	r2,-26992(gp)


    /* turn off the sampling flag so will start a new sample */
    sampling = FALSE;
   11cdc:	d025a515 	stw	zero,-26988(gp)


    /* all done, return */
    return;
   11ce0:	0001883a 	nop

}
   11ce4:	e037883a 	mov	sp,fp
   11ce8:	df000017 	ldw	fp,0(sp)
   11cec:	dec00104 	addi	sp,sp,4
   11cf0:	f800283a 	ret

00011cf4 <is_sampling>:
   Last Modified:    May 27, 2008

*/

int  is_sampling()
{
   11cf4:	deffff04 	addi	sp,sp,-4
   11cf8:	df000015 	stw	fp,0(sp)
   11cfc:	d839883a 	mov	fp,sp
      /* none */



    /* currently sampling if sampling flag is set */
    return  sampling;
   11d00:	d0a5a517 	ldw	r2,-26988(gp)

}
   11d04:	e037883a 	mov	sp,fp
   11d08:	df000017 	ldw	fp,0(sp)
   11d0c:	dec00104 	addi	sp,sp,4
   11d10:	f800283a 	ret

00011d14 <trace_rdy>:
   Last Modified:    Mar. 13, 1994

*/

int  trace_rdy()
{
   11d14:	deffff04 	addi	sp,sp,-4
   11d18:	df000015 	stw	fp,0(sp)
   11d1c:	d839883a 	mov	fp,sp
      /* none */



    /* ready for another trace if not sampling and trace is ready */
    return  (!sampling && trace_status);
   11d20:	d0a5a517 	ldw	r2,-26988(gp)
   11d24:	1000041e 	bne	r2,zero,11d38 <trace_rdy+0x24>
   11d28:	d0a5a417 	ldw	r2,-26992(gp)
   11d2c:	10000226 	beq	r2,zero,11d38 <trace_rdy+0x24>
   11d30:	00800044 	movi	r2,1
   11d34:	00000106 	br	11d3c <trace_rdy+0x28>
   11d38:	0005883a 	mov	r2,zero

}
   11d3c:	e037883a 	mov	sp,fp
   11d40:	df000017 	ldw	fp,0(sp)
   11d44:	dec00104 	addi	sp,sp,4
   11d48:	f800283a 	ret

00011d4c <trace_done>:
   Last Modified:    May 9, 2006

*/

void  trace_done()
{
   11d4c:	defffe04 	addi	sp,sp,-8
   11d50:	dfc00115 	stw	ra,4(sp)
   11d54:	df000015 	stw	fp,0(sp)
   11d58:	d839883a 	mov	fp,sp
      /* none */



    /* done with a trace - if retriggering, ready for another one */
    if (get_trigger_mode() != ONESHOT_TRIGGER)
   11d5c:	0010d900 	call	10d90 <get_trigger_mode>
   11d60:	108000a0 	cmpeqi	r2,r2,2
   11d64:	1000021e 	bne	r2,zero,11d70 <trace_done+0x24>
        /* in a retriggering mode - set trace_status to TRUE (ready) */
	trace_status = TRUE;
   11d68:	00800044 	movi	r2,1
   11d6c:	d0a5a415 	stw	r2,-26992(gp)

    /* no longer sampling data */
    sampling = FALSE;
   11d70:	d025a515 	stw	zero,-26988(gp)


    /* done so return */
    return;
   11d74:	0001883a 	nop

}
   11d78:	e037883a 	mov	sp,fp
   11d7c:	dfc00117 	ldw	ra,4(sp)
   11d80:	df000017 	ldw	fp,0(sp)
   11d84:	dec00204 	addi	sp,sp,8
   11d88:	f800283a 	ret

00011d8c <trace_rearm>:
   Last Modified:    Mar. 8, 1994

*/

void  trace_rearm()
{
   11d8c:	deffff04 	addi	sp,sp,-4
   11d90:	df000015 	stw	fp,0(sp)
   11d94:	d839883a 	mov	fp,sp
      /* none */



    /* rearm the trace - set status to ready (TRUE) */
    trace_status = TRUE;
   11d98:	00800044 	movi	r2,1
   11d9c:	d0a5a415 	stw	r2,-26992(gp)


    /* all done - return */
    return;
   11da0:	0001883a 	nop

}
   11da4:	e037883a 	mov	sp,fp
   11da8:	df000017 	ldw	fp,0(sp)
   11dac:	dec00104 	addi	sp,sp,4
   11db0:	f800283a 	ret

00011db4 <set_trace_size>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trace_size(int size)
{
   11db4:	defffe04 	addi	sp,sp,-8
   11db8:	df000115 	stw	fp,4(sp)
   11dbc:	df000104 	addi	fp,sp,4
   11dc0:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the locally global sample size */
    sample_size = size;
   11dc4:	e0bfff17 	ldw	r2,-4(fp)
   11dc8:	d0a5a615 	stw	r2,-26984(gp)


    /* all done, return */
    return;
   11dcc:	0001883a 	nop

}
   11dd0:	e037883a 	mov	sp,fp
   11dd4:	df000017 	ldw	fp,0(sp)
   11dd8:	dec00104 	addi	sp,sp,4
   11ddc:	f800283a 	ret

00011de0 <set_display_scale>:
   Last Modified:    May 9, 2006

*/

void  set_display_scale(enum scale_type scale)
{
   11de0:	defffa04 	addi	sp,sp,-24
   11de4:	dfc00515 	stw	ra,20(sp)
   11de8:	df000415 	stw	fp,16(sp)
   11dec:	df000404 	addi	fp,sp,16
   11df0:	e13fff15 	stw	r4,-4(fp)



    /* whenever change scale type, need to clear out previous scale */
    /* unnecessary if going to SCALE_GRID or from SCALE_NONE or not changing the scale */
    if ((scale != SCALE_GRID) && (cur_scale != SCALE_NONE) && (scale != cur_scale))  {
   11df4:	e0bfff17 	ldw	r2,-4(fp)
   11df8:	108000a0 	cmpeqi	r2,r2,2
   11dfc:	10008d1e 	bne	r2,zero,12034 <set_display_scale+0x254>
   11e00:	d0a5a717 	ldw	r2,-26980(gp)
   11e04:	10008b26 	beq	r2,zero,12034 <set_display_scale+0x254>
   11e08:	d0a5a717 	ldw	r2,-26980(gp)
   11e0c:	e0ffff17 	ldw	r3,-4(fp)
   11e10:	18808826 	beq	r3,r2,12034 <set_display_scale+0x254>

        /* need to restore the trace under the lines (tick, grid, or axis) */

	/* go through all points on horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
   11e14:	00bfffc4 	movi	r2,-1
   11e18:	e0bffe15 	stw	r2,-8(fp)
   11e1c:	00003e06 	br	11f18 <set_display_scale+0x138>

	    /* get y position of the line */
	    p = X_AXIS_POS + j * Y_TICK_SIZE;
   11e20:	e0bffe17 	ldw	r2,-8(fp)
   11e24:	10800c24 	muli	r2,r2,48
   11e28:	10801004 	addi	r2,r2,64
   11e2c:	e0bffc15 	stw	r2,-16(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_Y)
   11e30:	e0bffc17 	ldw	r2,-16(fp)
   11e34:	10802010 	cmplti	r2,r2,128
   11e38:	1000021e 	bne	r2,zero,11e44 <set_display_scale+0x64>
	        p = PLOT_SIZE_Y - 1;
   11e3c:	00801fc4 	movi	r2,127
   11e40:	e0bffc15 	stw	r2,-16(fp)
	    if (p < 0)
   11e44:	e0bffc17 	ldw	r2,-16(fp)
   11e48:	1000010e 	bge	r2,zero,11e50 <set_display_scale+0x70>
	        p = 0;
   11e4c:	e03ffc15 	stw	zero,-16(fp)

	    /* look at entire horizontal line */
	    for (i = 0; i < PLOT_SIZE_X; i++)  {
   11e50:	e03ffd15 	stw	zero,-12(fp)
   11e54:	00002a06 	br	11f00 <set_display_scale+0x120>
	        /* check if this point is on or off (need to look at bits) */
		if ((saved_axis_x[j + Y_TICK_CNT][i / 8] & (0x80 >> (i % 8))) == 0)
   11e58:	e0bffe17 	ldw	r2,-8(fp)
   11e5c:	11000044 	addi	r4,r2,1
   11e60:	e0bffd17 	ldw	r2,-12(fp)
   11e64:	1000010e 	bge	r2,zero,11e6c <set_display_scale+0x8c>
   11e68:	108001c4 	addi	r2,r2,7
   11e6c:	1005d0fa 	srai	r2,r2,3
   11e70:	00c000b4 	movhi	r3,2
   11e74:	18e0d304 	addi	r3,r3,-31924
   11e78:	21000f24 	muli	r4,r4,60
   11e7c:	2085883a 	add	r2,r4,r2
   11e80:	1885883a 	add	r2,r3,r2
   11e84:	10800003 	ldbu	r2,0(r2)
   11e88:	10c03fcc 	andi	r3,r2,255
   11e8c:	e13ffd17 	ldw	r4,-12(fp)
   11e90:	00a00034 	movhi	r2,32768
   11e94:	108001c4 	addi	r2,r2,7
   11e98:	2084703a 	and	r2,r4,r2
   11e9c:	1000040e 	bge	r2,zero,11eb0 <set_display_scale+0xd0>
   11ea0:	10bfffc4 	addi	r2,r2,-1
   11ea4:	013ffe04 	movi	r4,-8
   11ea8:	1104b03a 	or	r2,r2,r4
   11eac:	10800044 	addi	r2,r2,1
   11eb0:	01002004 	movi	r4,128
   11eb4:	2085d83a 	sra	r2,r4,r2
   11eb8:	1884703a 	and	r2,r3,r2
   11ebc:	1000071e 	bne	r2,zero,11edc <set_display_scale+0xfc>
		    /* saved pixel is off */
		    plot_pixel(i, p, PIXEL_WHITE);
   11ec0:	e0fffd17 	ldw	r3,-12(fp)
   11ec4:	e0bffc17 	ldw	r2,-16(fp)
   11ec8:	1809883a 	mov	r4,r3
   11ecc:	100b883a 	mov	r5,r2
   11ed0:	000d883a 	mov	r6,zero
   11ed4:	0011a4c0 	call	11a4c <plot_pixel>
   11ed8:	00000606 	br	11ef4 <set_display_scale+0x114>
		else
		    /* saved pixel is on */
		    plot_pixel(i, p, PIXEL_BLACK);
   11edc:	e0fffd17 	ldw	r3,-12(fp)
   11ee0:	e0bffc17 	ldw	r2,-16(fp)
   11ee4:	1809883a 	mov	r4,r3
   11ee8:	100b883a 	mov	r5,r2
   11eec:	01800044 	movi	r6,1
   11ef0:	0011a4c0 	call	11a4c <plot_pixel>
	        p = PLOT_SIZE_Y - 1;
	    if (p < 0)
	        p = 0;

	    /* look at entire horizontal line */
	    for (i = 0; i < PLOT_SIZE_X; i++)  {
   11ef4:	e0bffd17 	ldw	r2,-12(fp)
   11ef8:	10800044 	addi	r2,r2,1
   11efc:	e0bffd15 	stw	r2,-12(fp)
   11f00:	e0bffd17 	ldw	r2,-12(fp)
   11f04:	10807810 	cmplti	r2,r2,480
   11f08:	103fd31e 	bne	r2,zero,11e58 <set_display_scale+0x78>
    if ((scale != SCALE_GRID) && (cur_scale != SCALE_NONE) && (scale != cur_scale))  {

        /* need to restore the trace under the lines (tick, grid, or axis) */

	/* go through all points on horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
   11f0c:	e0bffe17 	ldw	r2,-8(fp)
   11f10:	10800044 	addi	r2,r2,1
   11f14:	e0bffe15 	stw	r2,-8(fp)
   11f18:	e0bffe17 	ldw	r2,-8(fp)
   11f1c:	10800090 	cmplti	r2,r2,2
   11f20:	103fbf1e 	bne	r2,zero,11e20 <set_display_scale+0x40>
		    plot_pixel(i, p, PIXEL_BLACK);
	    }
	}

	/* go through all points on vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
   11f24:	00bffec4 	movi	r2,-5
   11f28:	e0bffe15 	stw	r2,-8(fp)
   11f2c:	00003e06 	br	12028 <set_display_scale+0x248>

	    /* get x position of the line */
	    p = Y_AXIS_POS + j * X_TICK_SIZE;
   11f30:	e0bffe17 	ldw	r2,-8(fp)
   11f34:	10800c24 	muli	r2,r2,48
   11f38:	10803c04 	addi	r2,r2,240
   11f3c:	e0bffc15 	stw	r2,-16(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_X)
   11f40:	e0bffc17 	ldw	r2,-16(fp)
   11f44:	10807810 	cmplti	r2,r2,480
   11f48:	1000021e 	bne	r2,zero,11f54 <set_display_scale+0x174>
	        p = PLOT_SIZE_X - 1;
   11f4c:	008077c4 	movi	r2,479
   11f50:	e0bffc15 	stw	r2,-16(fp)
	    if (p < 0)
   11f54:	e0bffc17 	ldw	r2,-16(fp)
   11f58:	1000010e 	bge	r2,zero,11f60 <set_display_scale+0x180>
	        p = 0;
   11f5c:	e03ffc15 	stw	zero,-16(fp)

	    /* look at entire vertical line */
	    for (i = 0; i < PLOT_SIZE_Y; i++)  {
   11f60:	e03ffd15 	stw	zero,-12(fp)
   11f64:	00002a06 	br	12010 <set_display_scale+0x230>
	        /* check if this point is on or off (need to look at bits) */
		if ((saved_axis_y[j + X_TICK_CNT][i / 8] & (0x80 >> (i % 8))) == 0)
   11f68:	e0bffe17 	ldw	r2,-8(fp)
   11f6c:	11000144 	addi	r4,r2,5
   11f70:	e0bffd17 	ldw	r2,-12(fp)
   11f74:	1000010e 	bge	r2,zero,11f7c <set_display_scale+0x19c>
   11f78:	108001c4 	addi	r2,r2,7
   11f7c:	1005d0fa 	srai	r2,r2,3
   11f80:	00c000b4 	movhi	r3,2
   11f84:	18e10004 	addi	r3,r3,-31744
   11f88:	2008913a 	slli	r4,r4,4
   11f8c:	2085883a 	add	r2,r4,r2
   11f90:	1885883a 	add	r2,r3,r2
   11f94:	10800003 	ldbu	r2,0(r2)
   11f98:	10c03fcc 	andi	r3,r2,255
   11f9c:	e13ffd17 	ldw	r4,-12(fp)
   11fa0:	00a00034 	movhi	r2,32768
   11fa4:	108001c4 	addi	r2,r2,7
   11fa8:	2084703a 	and	r2,r4,r2
   11fac:	1000040e 	bge	r2,zero,11fc0 <set_display_scale+0x1e0>
   11fb0:	10bfffc4 	addi	r2,r2,-1
   11fb4:	013ffe04 	movi	r4,-8
   11fb8:	1104b03a 	or	r2,r2,r4
   11fbc:	10800044 	addi	r2,r2,1
   11fc0:	01002004 	movi	r4,128
   11fc4:	2085d83a 	sra	r2,r4,r2
   11fc8:	1884703a 	and	r2,r3,r2
   11fcc:	1000071e 	bne	r2,zero,11fec <set_display_scale+0x20c>
		    /* saved pixel is off */
		    plot_pixel(p, i, PIXEL_WHITE);
   11fd0:	e0fffc17 	ldw	r3,-16(fp)
   11fd4:	e0bffd17 	ldw	r2,-12(fp)
   11fd8:	1809883a 	mov	r4,r3
   11fdc:	100b883a 	mov	r5,r2
   11fe0:	000d883a 	mov	r6,zero
   11fe4:	0011a4c0 	call	11a4c <plot_pixel>
   11fe8:	00000606 	br	12004 <set_display_scale+0x224>
		else
		    /* saved pixel is on */
		    plot_pixel(p, i, PIXEL_BLACK);
   11fec:	e0fffc17 	ldw	r3,-16(fp)
   11ff0:	e0bffd17 	ldw	r2,-12(fp)
   11ff4:	1809883a 	mov	r4,r3
   11ff8:	100b883a 	mov	r5,r2
   11ffc:	01800044 	movi	r6,1
   12000:	0011a4c0 	call	11a4c <plot_pixel>
	        p = PLOT_SIZE_X - 1;
	    if (p < 0)
	        p = 0;

	    /* look at entire vertical line */
	    for (i = 0; i < PLOT_SIZE_Y; i++)  {
   12004:	e0bffd17 	ldw	r2,-12(fp)
   12008:	10800044 	addi	r2,r2,1
   1200c:	e0bffd15 	stw	r2,-12(fp)
   12010:	e0bffd17 	ldw	r2,-12(fp)
   12014:	10802010 	cmplti	r2,r2,128
   12018:	103fd31e 	bne	r2,zero,11f68 <set_display_scale+0x188>
		    plot_pixel(i, p, PIXEL_BLACK);
	    }
	}

	/* go through all points on vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
   1201c:	e0bffe17 	ldw	r2,-8(fp)
   12020:	10800044 	addi	r2,r2,1
   12024:	e0bffe15 	stw	r2,-8(fp)
   12028:	e0bffe17 	ldw	r2,-8(fp)
   1202c:	10800190 	cmplti	r2,r2,6
   12030:	103fbf1e 	bne	r2,zero,11f30 <set_display_scale+0x150>
	}
    }


    /* now handle the scale type appropriately */
    switch (scale)  {
   12034:	e0bfff17 	ldw	r2,-4(fp)
   12038:	10005326 	beq	r2,zero,12188 <set_display_scale+0x3a8>
   1203c:	108000e8 	cmpgeui	r2,r2,3
   12040:	1000521e 	bne	r2,zero,1218c <set_display_scale+0x3ac>

    	case SCALE_AXES:    /* axes for the scale */
    	case SCALE_GRID:    /* grid for the scale */

		            /* draw x lines (grid or tick marks) */
			    for (i = -Y_TICK_CNT; i <= Y_TICK_CNT; i++)  {
   12044:	00bfffc4 	movi	r2,-1
   12048:	e0bffd15 	stw	r2,-12(fp)
   1204c:	00002206 	br	120d8 <set_display_scale+0x2f8>

				/* get y position of the line */
				p = X_AXIS_POS + i * Y_TICK_SIZE;
   12050:	e0bffd17 	ldw	r2,-12(fp)
   12054:	10800c24 	muli	r2,r2,48
   12058:	10801004 	addi	r2,r2,64
   1205c:	e0bffc15 	stw	r2,-16(fp)
				/* make sure it is in range */
				if (p >= PLOT_SIZE_Y)
   12060:	e0bffc17 	ldw	r2,-16(fp)
   12064:	10802010 	cmplti	r2,r2,128
   12068:	1000021e 	bne	r2,zero,12074 <set_display_scale+0x294>
				    p = PLOT_SIZE_Y - 1;
   1206c:	00801fc4 	movi	r2,127
   12070:	e0bffc15 	stw	r2,-16(fp)
				if (p < 0)
   12074:	e0bffc17 	ldw	r2,-16(fp)
   12078:	1000010e 	bge	r2,zero,12080 <set_display_scale+0x2a0>
				    p = 0;
   1207c:	e03ffc15 	stw	zero,-16(fp)

				/* should we draw a grid, an axis, or a tick mark */
				if (scale == SCALE_GRID)
   12080:	e0bfff17 	ldw	r2,-4(fp)
   12084:	10800098 	cmpnei	r2,r2,2
   12088:	1000051e 	bne	r2,zero,120a0 <set_display_scale+0x2c0>
				    /* drawing a grid line */
			            plot_hline(X_GRID_START, p, (X_GRID_END - X_GRID_START));
   1208c:	0009883a 	mov	r4,zero
   12090:	e17ffc17 	ldw	r5,-16(fp)
   12094:	018077c4 	movi	r6,479
   12098:	00103e00 	call	103e0 <plot_hline>
   1209c:	00000b06 	br	120cc <set_display_scale+0x2ec>
				else if (i == 0)
   120a0:	e0bffd17 	ldw	r2,-12(fp)
   120a4:	1000051e 	bne	r2,zero,120bc <set_display_scale+0x2dc>
				    /* drawing the x axis */
			            plot_hline(X_AXIS_START, p, (X_AXIS_END - X_AXIS_START));
   120a8:	0009883a 	mov	r4,zero
   120ac:	e17ffc17 	ldw	r5,-16(fp)
   120b0:	018077c4 	movi	r6,479
   120b4:	00103e00 	call	103e0 <plot_hline>
   120b8:	00000406 	br	120cc <set_display_scale+0x2ec>
				else
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
   120bc:	01003b84 	movi	r4,238
   120c0:	e17ffc17 	ldw	r5,-16(fp)
   120c4:	01800144 	movi	r6,5
   120c8:	00103e00 	call	103e0 <plot_hline>

    	case SCALE_AXES:    /* axes for the scale */
    	case SCALE_GRID:    /* grid for the scale */

		            /* draw x lines (grid or tick marks) */
			    for (i = -Y_TICK_CNT; i <= Y_TICK_CNT; i++)  {
   120cc:	e0bffd17 	ldw	r2,-12(fp)
   120d0:	10800044 	addi	r2,r2,1
   120d4:	e0bffd15 	stw	r2,-12(fp)
   120d8:	e0bffd17 	ldw	r2,-12(fp)
   120dc:	10800090 	cmplti	r2,r2,2
   120e0:	103fdb1e 	bne	r2,zero,12050 <set_display_scale+0x270>
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
			    }

		            /* draw y lines (grid or tick marks) */
			    for (i = -X_TICK_CNT; i <= X_TICK_CNT; i++)  {
   120e4:	00bffec4 	movi	r2,-5
   120e8:	e0bffd15 	stw	r2,-12(fp)
   120ec:	00002206 	br	12178 <set_display_scale+0x398>

				/* get x position of the line */
				p = Y_AXIS_POS + i * X_TICK_SIZE;
   120f0:	e0bffd17 	ldw	r2,-12(fp)
   120f4:	10800c24 	muli	r2,r2,48
   120f8:	10803c04 	addi	r2,r2,240
   120fc:	e0bffc15 	stw	r2,-16(fp)
				/* make sure it is in range */
				if (p >= PLOT_SIZE_X)
   12100:	e0bffc17 	ldw	r2,-16(fp)
   12104:	10807810 	cmplti	r2,r2,480
   12108:	1000021e 	bne	r2,zero,12114 <set_display_scale+0x334>
				    p = PLOT_SIZE_X - 1;
   1210c:	008077c4 	movi	r2,479
   12110:	e0bffc15 	stw	r2,-16(fp)
			        if (p < 0)
   12114:	e0bffc17 	ldw	r2,-16(fp)
   12118:	1000010e 	bge	r2,zero,12120 <set_display_scale+0x340>
				    p = 0;
   1211c:	e03ffc15 	stw	zero,-16(fp)

				/* should we draw a grid, an axis, or a tick mark */
				if (scale == SCALE_GRID)
   12120:	e0bfff17 	ldw	r2,-4(fp)
   12124:	10800098 	cmpnei	r2,r2,2
   12128:	1000051e 	bne	r2,zero,12140 <set_display_scale+0x360>
				    /* drawing a grid line */
			            plot_vline(p, Y_GRID_START, (Y_GRID_END - Y_GRID_START));
   1212c:	e13ffc17 	ldw	r4,-16(fp)
   12130:	000b883a 	mov	r5,zero
   12134:	01801fc4 	movi	r6,127
   12138:	001048c0 	call	1048c <plot_vline>
   1213c:	00000b06 	br	1216c <set_display_scale+0x38c>
				else if (i == 0)
   12140:	e0bffd17 	ldw	r2,-12(fp)
   12144:	1000051e 	bne	r2,zero,1215c <set_display_scale+0x37c>
				    /* drawing the y axis */
			            plot_vline(p, Y_AXIS_START, (Y_AXIS_END - Y_AXIS_START));
   12148:	e13ffc17 	ldw	r4,-16(fp)
   1214c:	000b883a 	mov	r5,zero
   12150:	01801fc4 	movi	r6,127
   12154:	001048c0 	call	1048c <plot_vline>
   12158:	00000406 	br	1216c <set_display_scale+0x38c>
				else
				    /* must be drawing a tick mark */
			            plot_vline(p, (X_AXIS_POS - (TICK_LEN / 2)), TICK_LEN);
   1215c:	e13ffc17 	ldw	r4,-16(fp)
   12160:	01400f84 	movi	r5,62
   12164:	01800144 	movi	r6,5
   12168:	001048c0 	call	1048c <plot_vline>
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
			    }

		            /* draw y lines (grid or tick marks) */
			    for (i = -X_TICK_CNT; i <= X_TICK_CNT; i++)  {
   1216c:	e0bffd17 	ldw	r2,-12(fp)
   12170:	10800044 	addi	r2,r2,1
   12174:	e0bffd15 	stw	r2,-12(fp)
   12178:	e0bffd17 	ldw	r2,-12(fp)
   1217c:	10800190 	cmplti	r2,r2,6
   12180:	103fdb1e 	bne	r2,zero,120f0 <set_display_scale+0x310>
				    /* must be drawing a tick mark */
			            plot_vline(p, (X_AXIS_POS - (TICK_LEN / 2)), TICK_LEN);
			    }

			    /* done with the axes */
			    break;
   12184:	00000106 	br	1218c <set_display_scale+0x3ac>

        case SCALE_NONE:    /* there is no scale */
			    /* already restored plot so nothing to do */
			    break;
   12188:	0001883a 	nop

    }


    /* now remember the new (now current) scale type */
    cur_scale = scale;
   1218c:	e0bfff17 	ldw	r2,-4(fp)
   12190:	d0a5a715 	stw	r2,-26980(gp)


    /* scale is taken care of, return */
    return;
   12194:	0001883a 	nop

}
   12198:	e037883a 	mov	sp,fp
   1219c:	dfc00117 	ldw	ra,4(sp)
   121a0:	df000017 	ldw	fp,0(sp)
   121a4:	dec00204 	addi	sp,sp,8
   121a8:	f800283a 	ret

000121ac <clear_saved_areas>:
   Last Modified:    May 9, 2006

*/

void  clear_saved_areas()
{
   121ac:	defffd04 	addi	sp,sp,-12
   121b0:	df000215 	stw	fp,8(sp)
   121b4:	df000204 	addi	fp,sp,8
    int  j;



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
   121b8:	e03fff15 	stw	zero,-4(fp)
   121bc:	00001306 	br	1220c <clear_saved_areas+0x60>
        for (i = 0; i < (SIZE_X / 8); i++)
   121c0:	e03ffe15 	stw	zero,-8(fp)
   121c4:	00000b06 	br	121f4 <clear_saved_areas+0x48>
            saved_axis_x[j][i] = 0;
   121c8:	00c000b4 	movhi	r3,2
   121cc:	18e0d304 	addi	r3,r3,-31924
   121d0:	e0bfff17 	ldw	r2,-4(fp)
   121d4:	11000f24 	muli	r4,r2,60
   121d8:	e0bffe17 	ldw	r2,-8(fp)
   121dc:	2085883a 	add	r2,r4,r2
   121e0:	1885883a 	add	r2,r3,r2
   121e4:	10000005 	stb	zero,0(r2)



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
   121e8:	e0bffe17 	ldw	r2,-8(fp)
   121ec:	10800044 	addi	r2,r2,1
   121f0:	e0bffe15 	stw	r2,-8(fp)
   121f4:	e0bffe17 	ldw	r2,-8(fp)
   121f8:	10800f10 	cmplti	r2,r2,60
   121fc:	103ff21e 	bne	r2,zero,121c8 <clear_saved_areas+0x1c>
    int  j;



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
   12200:	e0bfff17 	ldw	r2,-4(fp)
   12204:	10800044 	addi	r2,r2,1
   12208:	e0bfff15 	stw	r2,-4(fp)
   1220c:	e0bfff17 	ldw	r2,-4(fp)
   12210:	108000d0 	cmplti	r2,r2,3
   12214:	103fea1e 	bne	r2,zero,121c0 <clear_saved_areas+0x14>
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
   12218:	e03fff15 	stw	zero,-4(fp)
   1221c:	00001306 	br	1226c <clear_saved_areas+0xc0>
        for (i = 0; i < (SIZE_Y / 8); i++)
   12220:	e03ffe15 	stw	zero,-8(fp)
   12224:	00000b06 	br	12254 <clear_saved_areas+0xa8>
            saved_axis_y[j][i] = 0;
   12228:	00c000b4 	movhi	r3,2
   1222c:	18e10004 	addi	r3,r3,-31744
   12230:	e0bfff17 	ldw	r2,-4(fp)
   12234:	1008913a 	slli	r4,r2,4
   12238:	e0bffe17 	ldw	r2,-8(fp)
   1223c:	2085883a 	add	r2,r4,r2
   12240:	1885883a 	add	r2,r3,r2
   12244:	10000005 	stb	zero,0(r2)
    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
        for (i = 0; i < (SIZE_Y / 8); i++)
   12248:	e0bffe17 	ldw	r2,-8(fp)
   1224c:	10800044 	addi	r2,r2,1
   12250:	e0bffe15 	stw	r2,-8(fp)
   12254:	e0bffe17 	ldw	r2,-8(fp)
   12258:	10800410 	cmplti	r2,r2,16
   1225c:	103ff21e 	bne	r2,zero,12228 <clear_saved_areas+0x7c>

    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
   12260:	e0bfff17 	ldw	r2,-4(fp)
   12264:	10800044 	addi	r2,r2,1
   12268:	e0bfff15 	stw	r2,-4(fp)
   1226c:	e0bfff17 	ldw	r2,-4(fp)
   12270:	108002d0 	cmplti	r2,r2,11
   12274:	103fea1e 	bne	r2,zero,12220 <clear_saved_areas+0x74>
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
   12278:	e03ffe15 	stw	zero,-8(fp)
   1227c:	00001306 	br	122cc <clear_saved_areas+0x120>
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
   12280:	e03fff15 	stw	zero,-4(fp)
   12284:	00000b06 	br	122b4 <clear_saved_areas+0x108>
	    saved_menu[i][j] = 0;
   12288:	00c000b4 	movhi	r3,2
   1228c:	18e12c04 	addi	r3,r3,-31568
   12290:	e0bffe17 	ldw	r2,-8(fp)
   12294:	11000324 	muli	r4,r2,12
   12298:	e0bfff17 	ldw	r2,-4(fp)
   1229c:	2085883a 	add	r2,r4,r2
   122a0:	1885883a 	add	r2,r3,r2
   122a4:	10000005 	stb	zero,0(r2)
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
   122a8:	e0bfff17 	ldw	r2,-4(fp)
   122ac:	10800044 	addi	r2,r2,1
   122b0:	e0bfff15 	stw	r2,-4(fp)
   122b4:	e0bfff17 	ldw	r2,-4(fp)
   122b8:	10800310 	cmplti	r2,r2,12
   122bc:	103ff21e 	bne	r2,zero,12288 <clear_saved_areas+0xdc>
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
   122c0:	e0bffe17 	ldw	r2,-8(fp)
   122c4:	10800044 	addi	r2,r2,1
   122c8:	e0bffe15 	stw	r2,-8(fp)
   122cc:	e0bffe17 	ldw	r2,-8(fp)
   122d0:	10800e10 	cmplti	r2,r2,56
   122d4:	103fea1e 	bne	r2,zero,12280 <clear_saved_areas+0xd4>
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
   122d8:	e03ffe15 	stw	zero,-8(fp)
   122dc:	00001306 	br	1232c <clear_saved_areas+0x180>
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
   122e0:	e03fff15 	stw	zero,-4(fp)
   122e4:	00000b06 	br	12314 <clear_saved_areas+0x168>
	    saved_area[i][j] = 0;
   122e8:	00c000b4 	movhi	r3,2
   122ec:	18e1d404 	addi	r3,r3,-30896
   122f0:	e0bffe17 	ldw	r2,-8(fp)
   122f4:	110003e4 	muli	r4,r2,15
   122f8:	e0bfff17 	ldw	r2,-4(fp)
   122fc:	2085883a 	add	r2,r4,r2
   12300:	1885883a 	add	r2,r3,r2
   12304:	10000005 	stb	zero,0(r2)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
   12308:	e0bfff17 	ldw	r2,-4(fp)
   1230c:	10800044 	addi	r2,r2,1
   12310:	e0bfff15 	stw	r2,-4(fp)
   12314:	e0bfff17 	ldw	r2,-4(fp)
   12318:	108003d0 	cmplti	r2,r2,15
   1231c:	103ff21e 	bne	r2,zero,122e8 <clear_saved_areas+0x13c>
    for (i = 0; i < MENU_SIZE_Y; i++)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
   12320:	e0bffe17 	ldw	r2,-8(fp)
   12324:	10800044 	addi	r2,r2,1
   12328:	e0bffe15 	stw	r2,-8(fp)
   1232c:	e0bffe17 	ldw	r2,-8(fp)
   12330:	10800410 	cmplti	r2,r2,16
   12334:	103fea1e 	bne	r2,zero,122e0 <clear_saved_areas+0x134>
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
	    saved_area[i][j] = 0;


    /* done clearing the saved areas - return */
    return;
   12338:	0001883a 	nop

}
   1233c:	e037883a 	mov	sp,fp
   12340:	df000017 	ldw	fp,0(sp)
   12344:	dec00104 	addi	sp,sp,4
   12348:	f800283a 	ret

0001234c <restore_menu_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  restore_menu_trace()
{
   1234c:	defffa04 	addi	sp,sp,-24
   12350:	dfc00515 	stw	ra,20(sp)
   12354:	df000415 	stw	fp,16(sp)
   12358:	df000404 	addi	fp,sp,16
    int  y;



    /* loop, restoring the trace under the menu */
    for (y = MENU_UL_Y; y < (MENU_UL_Y + MENU_SIZE_Y); y++)  {
   1235c:	e03fff15 	stw	zero,-4(fp)
   12360:	00003206 	br	1242c <restore_menu_trace+0xe0>

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
   12364:	00802004 	movi	r2,128
   12368:	e0bffc15 	stw	r2,-16(fp)
	bit_offset = 0;		/* first byte of the row */
   1236c:	e03ffd15 	stw	zero,-12(fp)

        for (x = MENU_UL_X; x < (MENU_UL_X + MENU_SIZE_X); x++)  {
   12370:	00805e84 	movi	r2,378
   12374:	e0bffe15 	stw	r2,-8(fp)
   12378:	00002606 	br	12414 <restore_menu_trace+0xc8>

	    /* check if this point is on or off (need to look at bits) */
	    if ((saved_menu[y - MENU_UL_Y][bit_offset] & bit_position) == 0)
   1237c:	00c000b4 	movhi	r3,2
   12380:	18e12c04 	addi	r3,r3,-31568
   12384:	e0bfff17 	ldw	r2,-4(fp)
   12388:	11000324 	muli	r4,r2,12
   1238c:	e0bffd17 	ldw	r2,-12(fp)
   12390:	2085883a 	add	r2,r4,r2
   12394:	1885883a 	add	r2,r3,r2
   12398:	10800003 	ldbu	r2,0(r2)
   1239c:	10c03fcc 	andi	r3,r2,255
   123a0:	e0bffc17 	ldw	r2,-16(fp)
   123a4:	1884703a 	and	r2,r3,r2
   123a8:	1000071e 	bne	r2,zero,123c8 <restore_menu_trace+0x7c>
	        /* saved pixel is off */
		plot_pixel(x, y, PIXEL_WHITE);
   123ac:	e0fffe17 	ldw	r3,-8(fp)
   123b0:	e0bfff17 	ldw	r2,-4(fp)
   123b4:	1809883a 	mov	r4,r3
   123b8:	100b883a 	mov	r5,r2
   123bc:	000d883a 	mov	r6,zero
   123c0:	0011a4c0 	call	11a4c <plot_pixel>
   123c4:	00000606 	br	123e0 <restore_menu_trace+0x94>
	    else
	        /* saved pixel is on */
		plot_pixel(x, y, PIXEL_BLACK);
   123c8:	e0fffe17 	ldw	r3,-8(fp)
   123cc:	e0bfff17 	ldw	r2,-4(fp)
   123d0:	1809883a 	mov	r4,r3
   123d4:	100b883a 	mov	r5,r2
   123d8:	01800044 	movi	r6,1
   123dc:	0011a4c0 	call	11a4c <plot_pixel>

	    /* move to the next bit position */
	    bit_position >>= 1;
   123e0:	e0bffc17 	ldw	r2,-16(fp)
   123e4:	1005d07a 	srai	r2,r2,1
   123e8:	e0bffc15 	stw	r2,-16(fp)
	    /* check if moving to next byte */
	    if (bit_position == 0)  {
   123ec:	e0bffc17 	ldw	r2,-16(fp)
   123f0:	1000051e 	bne	r2,zero,12408 <restore_menu_trace+0xbc>
	        /* now on high bit of next byte */
		bit_position = 0x80;
   123f4:	00802004 	movi	r2,128
   123f8:	e0bffc15 	stw	r2,-16(fp)
		bit_offset++;
   123fc:	e0bffd17 	ldw	r2,-12(fp)
   12400:	10800044 	addi	r2,r2,1
   12404:	e0bffd15 	stw	r2,-12(fp)

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
	bit_offset = 0;		/* first byte of the row */

        for (x = MENU_UL_X; x < (MENU_UL_X + MENU_SIZE_X); x++)  {
   12408:	e0bffe17 	ldw	r2,-8(fp)
   1240c:	10800044 	addi	r2,r2,1
   12410:	e0bffe15 	stw	r2,-8(fp)
   12414:	e0bffe17 	ldw	r2,-8(fp)
   12418:	10807690 	cmplti	r2,r2,474
   1241c:	103fd71e 	bne	r2,zero,1237c <restore_menu_trace+0x30>
    int  y;



    /* loop, restoring the trace under the menu */
    for (y = MENU_UL_Y; y < (MENU_UL_Y + MENU_SIZE_Y); y++)  {
   12420:	e0bfff17 	ldw	r2,-4(fp)
   12424:	10800044 	addi	r2,r2,1
   12428:	e0bfff15 	stw	r2,-4(fp)
   1242c:	e0bfff17 	ldw	r2,-4(fp)
   12430:	10800e10 	cmplti	r2,r2,56
   12434:	103fcb1e 	bne	r2,zero,12364 <restore_menu_trace+0x18>
        }
    }


    /* restored menu area - return */
    return;
   12438:	0001883a 	nop

}
   1243c:	e037883a 	mov	sp,fp
   12440:	dfc00117 	ldw	ra,4(sp)
   12444:	df000017 	ldw	fp,0(sp)
   12448:	dec00204 	addi	sp,sp,8
   1244c:	f800283a 	ret

00012450 <set_save_area>:
   Last Modified:    Mar. 8, 1994

*/

void  set_save_area(int pos_x, int pos_y, int size_x, int size_y)
{
   12450:	defff904 	addi	sp,sp,-28
   12454:	df000615 	stw	fp,24(sp)
   12458:	df000604 	addi	fp,sp,24
   1245c:	e13ffc15 	stw	r4,-16(fp)
   12460:	e17ffd15 	stw	r5,-12(fp)
   12464:	e1bffe15 	stw	r6,-8(fp)
   12468:	e1ffff15 	stw	r7,-4(fp)
    int  y;



    /* just setup all the locally global variables from the passed values */
    saved_pos_x = pos_x;
   1246c:	e0bffc17 	ldw	r2,-16(fp)
   12470:	d0a5a815 	stw	r2,-26976(gp)
    saved_pos_y = pos_y;
   12474:	e0bffd17 	ldw	r2,-12(fp)
   12478:	d0a5a915 	stw	r2,-26972(gp)
    saved_end_x = pos_x + size_x;
   1247c:	e0fffc17 	ldw	r3,-16(fp)
   12480:	e0bffe17 	ldw	r2,-8(fp)
   12484:	1885883a 	add	r2,r3,r2
   12488:	d0a5aa15 	stw	r2,-26968(gp)
    saved_end_y = pos_y + size_y;
   1248c:	e0fffd17 	ldw	r3,-12(fp)
   12490:	e0bfff17 	ldw	r2,-4(fp)
   12494:	1885883a 	add	r2,r3,r2
   12498:	d0a5ab15 	stw	r2,-26964(gp)


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
   1249c:	e03ffb15 	stw	zero,-20(fp)
   124a0:	00001306 	br	124f0 <set_save_area+0xa0>
        for (x = 0; x < (SAVE_SIZE_X / 8); x++)  {
   124a4:	e03ffa15 	stw	zero,-24(fp)
   124a8:	00000b06 	br	124d8 <set_save_area+0x88>
	    saved_area[y][x] = 0;
   124ac:	00c000b4 	movhi	r3,2
   124b0:	18e1d404 	addi	r3,r3,-30896
   124b4:	e0bffb17 	ldw	r2,-20(fp)
   124b8:	110003e4 	muli	r4,r2,15
   124bc:	e0bffa17 	ldw	r2,-24(fp)
   124c0:	2085883a 	add	r2,r4,r2
   124c4:	1885883a 	add	r2,r3,r2
   124c8:	10000005 	stb	zero,0(r2)
    saved_end_y = pos_y + size_y;


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
        for (x = 0; x < (SAVE_SIZE_X / 8); x++)  {
   124cc:	e0bffa17 	ldw	r2,-24(fp)
   124d0:	10800044 	addi	r2,r2,1
   124d4:	e0bffa15 	stw	r2,-24(fp)
   124d8:	e0bffa17 	ldw	r2,-24(fp)
   124dc:	108003d0 	cmplti	r2,r2,15
   124e0:	103ff21e 	bne	r2,zero,124ac <set_save_area+0x5c>
    saved_end_x = pos_x + size_x;
    saved_end_y = pos_y + size_y;


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
   124e4:	e0bffb17 	ldw	r2,-20(fp)
   124e8:	10800044 	addi	r2,r2,1
   124ec:	e0bffb15 	stw	r2,-20(fp)
   124f0:	e0bffb17 	ldw	r2,-20(fp)
   124f4:	10800410 	cmplti	r2,r2,16
   124f8:	103fea1e 	bne	r2,zero,124a4 <set_save_area+0x54>
        }
    }


    /* setup the saved area - return */
    return;
   124fc:	0001883a 	nop

}
   12500:	e037883a 	mov	sp,fp
   12504:	df000017 	ldw	fp,0(sp)
   12508:	dec00104 	addi	sp,sp,4
   1250c:	f800283a 	ret

00012510 <restore_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  restore_trace()
{
   12510:	defffa04 	addi	sp,sp,-24
   12514:	dfc00515 	stw	ra,20(sp)
   12518:	df000415 	stw	fp,16(sp)
   1251c:	df000404 	addi	fp,sp,16
    int  y;



    /* loop, restoring the saved trace */
    for (y = saved_pos_y; y < saved_end_y; y++)  {
   12520:	d0a5a917 	ldw	r2,-26972(gp)
   12524:	e0bfff15 	stw	r2,-4(fp)
   12528:	00003406 	br	125fc <restore_trace+0xec>

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
   1252c:	00802004 	movi	r2,128
   12530:	e0bffc15 	stw	r2,-16(fp)
	bit_offset = 0;		/* first byte of the row */
   12534:	e03ffd15 	stw	zero,-12(fp)

        for (x = saved_pos_x; x < saved_end_x; x++)  {
   12538:	d0a5a817 	ldw	r2,-26976(gp)
   1253c:	e0bffe15 	stw	r2,-8(fp)
   12540:	00002806 	br	125e4 <restore_trace+0xd4>

	    /* check if this point is on or off (need to look at bits) */
	    if ((saved_area[y - saved_pos_y][bit_offset] & bit_position) == 0)
   12544:	d0a5a917 	ldw	r2,-26972(gp)
   12548:	e0ffff17 	ldw	r3,-4(fp)
   1254c:	1885c83a 	sub	r2,r3,r2
   12550:	00c000b4 	movhi	r3,2
   12554:	18e1d404 	addi	r3,r3,-30896
   12558:	110003e4 	muli	r4,r2,15
   1255c:	e0bffd17 	ldw	r2,-12(fp)
   12560:	2085883a 	add	r2,r4,r2
   12564:	1885883a 	add	r2,r3,r2
   12568:	10800003 	ldbu	r2,0(r2)
   1256c:	10c03fcc 	andi	r3,r2,255
   12570:	e0bffc17 	ldw	r2,-16(fp)
   12574:	1884703a 	and	r2,r3,r2
   12578:	1000071e 	bne	r2,zero,12598 <restore_trace+0x88>
	        /* saved pixel is off */
		plot_pixel(x, y, PIXEL_WHITE);
   1257c:	e0fffe17 	ldw	r3,-8(fp)
   12580:	e0bfff17 	ldw	r2,-4(fp)
   12584:	1809883a 	mov	r4,r3
   12588:	100b883a 	mov	r5,r2
   1258c:	000d883a 	mov	r6,zero
   12590:	0011a4c0 	call	11a4c <plot_pixel>
   12594:	00000606 	br	125b0 <restore_trace+0xa0>
	    else
	        /* saved pixel is on */
		plot_pixel(x, y, PIXEL_BLACK);
   12598:	e0fffe17 	ldw	r3,-8(fp)
   1259c:	e0bfff17 	ldw	r2,-4(fp)
   125a0:	1809883a 	mov	r4,r3
   125a4:	100b883a 	mov	r5,r2
   125a8:	01800044 	movi	r6,1
   125ac:	0011a4c0 	call	11a4c <plot_pixel>

	    /* move to the next bit position */
	    bit_position >>= 1;
   125b0:	e0bffc17 	ldw	r2,-16(fp)
   125b4:	1005d07a 	srai	r2,r2,1
   125b8:	e0bffc15 	stw	r2,-16(fp)
	    /* check if moving to next byte */
	    if (bit_position == 0)  {
   125bc:	e0bffc17 	ldw	r2,-16(fp)
   125c0:	1000051e 	bne	r2,zero,125d8 <restore_trace+0xc8>
	        /* now on high bit of next byte */
		bit_position = 0x80;
   125c4:	00802004 	movi	r2,128
   125c8:	e0bffc15 	stw	r2,-16(fp)
		bit_offset++;
   125cc:	e0bffd17 	ldw	r2,-12(fp)
   125d0:	10800044 	addi	r2,r2,1
   125d4:	e0bffd15 	stw	r2,-12(fp)

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
	bit_offset = 0;		/* first byte of the row */

        for (x = saved_pos_x; x < saved_end_x; x++)  {
   125d8:	e0bffe17 	ldw	r2,-8(fp)
   125dc:	10800044 	addi	r2,r2,1
   125e0:	e0bffe15 	stw	r2,-8(fp)
   125e4:	d0a5aa17 	ldw	r2,-26968(gp)
   125e8:	e0fffe17 	ldw	r3,-8(fp)
   125ec:	18bfd516 	blt	r3,r2,12544 <restore_trace+0x34>
    int  y;



    /* loop, restoring the saved trace */
    for (y = saved_pos_y; y < saved_end_y; y++)  {
   125f0:	e0bfff17 	ldw	r2,-4(fp)
   125f4:	10800044 	addi	r2,r2,1
   125f8:	e0bfff15 	stw	r2,-4(fp)
   125fc:	d0a5ab17 	ldw	r2,-26964(gp)
   12600:	e0ffff17 	ldw	r3,-4(fp)
   12604:	18bfc916 	blt	r3,r2,1252c <restore_trace+0x1c>
        }
    }


    /* restored the saved area - return */
    return;
   12608:	0001883a 	nop

}
   1260c:	e037883a 	mov	sp,fp
   12610:	dfc00117 	ldw	ra,4(sp)
   12614:	df000017 	ldw	fp,0(sp)
   12618:	dec00204 	addi	sp,sp,8
   1261c:	f800283a 	ret

00012620 <do_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  do_trace()
{
   12620:	defffe04 	addi	sp,sp,-8
   12624:	dfc00115 	stw	ra,4(sp)
   12628:	df000015 	stw	fp,0(sp)
   1262c:	d839883a 	mov	fp,sp



    /* start up the trace */
    /* indicate whether using automatic triggering or not */
    start_sample(get_trigger_mode() == AUTO_TRIGGER);
   12630:	0010d900 	call	10d90 <get_trigger_mode>
   12634:	10800060 	cmpeqi	r2,r2,1
   12638:	10803fcc 	andi	r2,r2,255
   1263c:	1009883a 	mov	r4,r2
   12640:	0011ae80 	call	11ae8 <start_sample>

    /* now not ready for another trace (currently doing one) */
    trace_status = FALSE;
   12644:	d025a415 	stw	zero,-26992(gp)

    /* and are currently sampling data */
    sampling = TRUE;
   12648:	00800044 	movi	r2,1
   1264c:	d0a5a515 	stw	r2,-26988(gp)


    /* trace is going, return */
    return;
   12650:	0001883a 	nop

}
   12654:	e037883a 	mov	sp,fp
   12658:	dfc00117 	ldw	ra,4(sp)
   1265c:	df000017 	ldw	fp,0(sp)
   12660:	dec00204 	addi	sp,sp,8
   12664:	f800283a 	ret

00012668 <plot_trace>:
   Last Modified:    May 9, 2006

*/

void  plot_trace(unsigned char *sample)
{
   12668:	defff704 	addi	sp,sp,-36
   1266c:	dfc00815 	stw	ra,32(sp)
   12670:	df000715 	stw	fp,28(sp)
   12674:	df000704 	addi	fp,sp,28
   12678:	e13fff15 	stw	r4,-4(fp)
    /* variables */
    int  x = 0;				/* current x position to plot */
   1267c:	e03ff915 	stw	zero,-28(fp)
    int  x_pos = (PLOT_SIZE_X / 2);	/* "fine" x position for multiple point plotting */
   12680:	00803c04 	movi	r2,240
   12684:	e0bffa15 	stw	r2,-24(fp)
    int  j;



    /* first, clear the display to get rid of old plots */
    clear_display();
   12688:	0011a2c0 	call	11a2c <clear_display>

    /* clear the saved areas too */
    clear_saved_areas();
   1268c:	00121ac0 	call	121ac <clear_saved_areas>

    /* re-display the menu (if it was on) */
    refresh_menu();
   12690:	00109840 	call	10984 <refresh_menu>


    /* plot the sample */
    for (i = 0; i < sample_size; i++)  {
   12694:	e03ffc15 	stw	zero,-16(fp)
   12698:	0000fb06 	br	12a88 <plot_trace+0x420>

        /* determine y position of point (note: screen coordinates invert) */
	y = (PLOT_SIZE_Y - 1) - ((sample[i] * (PLOT_SIZE_Y - 1)) / 255);
   1269c:	e0bffc17 	ldw	r2,-16(fp)
   126a0:	e0ffff17 	ldw	r3,-4(fp)
   126a4:	1885883a 	add	r2,r3,r2
   126a8:	10800003 	ldbu	r2,0(r2)
   126ac:	10803fcc 	andi	r2,r2,255
   126b0:	10801fe4 	muli	r2,r2,127
   126b4:	1009883a 	mov	r4,r2
   126b8:	01403fc4 	movi	r5,255
   126bc:	0012b2c0 	call	12b2c <__divsi3>
   126c0:	00c01fc4 	movi	r3,127
   126c4:	1885c83a 	sub	r2,r3,r2
   126c8:	e0bffe15 	stw	r2,-8(fp)

        /* plot this point */
	plot_pixel(x, y, PIXEL_BLACK);
   126cc:	e0fff917 	ldw	r3,-28(fp)
   126d0:	e0bffe17 	ldw	r2,-8(fp)
   126d4:	1809883a 	mov	r4,r3
   126d8:	100b883a 	mov	r5,r2
   126dc:	01800044 	movi	r6,1
   126e0:	0011a4c0 	call	11a4c <plot_pixel>


	/* check if the point is in a save area */

	/* check if in the menu area */
	if ((x >= MENU_UL_X) && (x < (MENU_UL_X + MENU_SIZE_X)) &&
   126e4:	e0bff917 	ldw	r2,-28(fp)
   126e8:	10805e90 	cmplti	r2,r2,378
   126ec:	10002b1e 	bne	r2,zero,1279c <plot_trace+0x134>
   126f0:	e0bff917 	ldw	r2,-28(fp)
   126f4:	10807688 	cmpgei	r2,r2,474
   126f8:	1000281e 	bne	r2,zero,1279c <plot_trace+0x134>
   126fc:	e0bffe17 	ldw	r2,-8(fp)
   12700:	10002616 	blt	r2,zero,1279c <plot_trace+0x134>
	    (y >= MENU_UL_Y) && (y < (MENU_UL_Y + MENU_SIZE_Y)))
   12704:	e0bffe17 	ldw	r2,-8(fp)
   12708:	10800e08 	cmpgei	r2,r2,56
   1270c:	1000231e 	bne	r2,zero,1279c <plot_trace+0x134>
	    /* point is in the menu area - save it */
	    saved_menu[y - MENU_UL_Y][(x - MENU_UL_X)/8] |= (0x80 >> ((x - MENU_UL_X) % 8));
   12710:	e0bff917 	ldw	r2,-28(fp)
   12714:	10bfa184 	addi	r2,r2,-378
   12718:	1000010e 	bge	r2,zero,12720 <plot_trace+0xb8>
   1271c:	108001c4 	addi	r2,r2,7
   12720:	1005d0fa 	srai	r2,r2,3
   12724:	1007883a 	mov	r3,r2
   12728:	010000b4 	movhi	r4,2
   1272c:	21212c04 	addi	r4,r4,-31568
   12730:	e0bffe17 	ldw	r2,-8(fp)
   12734:	10800324 	muli	r2,r2,12
   12738:	10c5883a 	add	r2,r2,r3
   1273c:	2085883a 	add	r2,r4,r2
   12740:	10800003 	ldbu	r2,0(r2)
   12744:	1009883a 	mov	r4,r2
   12748:	e0bff917 	ldw	r2,-28(fp)
   1274c:	117fa184 	addi	r5,r2,-378
   12750:	00a00034 	movhi	r2,32768
   12754:	108001c4 	addi	r2,r2,7
   12758:	2884703a 	and	r2,r5,r2
   1275c:	1000040e 	bge	r2,zero,12770 <plot_trace+0x108>
   12760:	10bfffc4 	addi	r2,r2,-1
   12764:	017ffe04 	movi	r5,-8
   12768:	1144b03a 	or	r2,r2,r5
   1276c:	10800044 	addi	r2,r2,1
   12770:	01402004 	movi	r5,128
   12774:	2885d83a 	sra	r2,r5,r2
   12778:	2084b03a 	or	r2,r4,r2
   1277c:	1009883a 	mov	r4,r2
   12780:	014000b4 	movhi	r5,2
   12784:	29612c04 	addi	r5,r5,-31568
   12788:	e0bffe17 	ldw	r2,-8(fp)
   1278c:	10800324 	muli	r2,r2,12
   12790:	10c5883a 	add	r2,r2,r3
   12794:	2885883a 	add	r2,r5,r2
   12798:	11000005 	stb	r4,0(r2)

	/* check if in the saved area */
	if ((x >= saved_pos_x) && (x <= saved_end_x) && (y >= saved_pos_y) && (y <= saved_end_y))
   1279c:	d0a5a817 	ldw	r2,-26976(gp)
   127a0:	e0fff917 	ldw	r3,-28(fp)
   127a4:	18803216 	blt	r3,r2,12870 <plot_trace+0x208>
   127a8:	d0e5aa17 	ldw	r3,-26968(gp)
   127ac:	e0bff917 	ldw	r2,-28(fp)
   127b0:	18802f16 	blt	r3,r2,12870 <plot_trace+0x208>
   127b4:	d0a5a917 	ldw	r2,-26972(gp)
   127b8:	e0fffe17 	ldw	r3,-8(fp)
   127bc:	18802c16 	blt	r3,r2,12870 <plot_trace+0x208>
   127c0:	d0e5ab17 	ldw	r3,-26964(gp)
   127c4:	e0bffe17 	ldw	r2,-8(fp)
   127c8:	18802916 	blt	r3,r2,12870 <plot_trace+0x208>
	    /* point is in the save area - save it */
	    saved_area[y - saved_pos_y][(x - saved_pos_x)/8] |= (0x80 >> ((x - saved_pos_x) % 8));
   127cc:	d0a5a917 	ldw	r2,-26972(gp)
   127d0:	e0fffe17 	ldw	r3,-8(fp)
   127d4:	188dc83a 	sub	r6,r3,r2
   127d8:	d0a5a817 	ldw	r2,-26976(gp)
   127dc:	e0fff917 	ldw	r3,-28(fp)
   127e0:	1885c83a 	sub	r2,r3,r2
   127e4:	1000010e 	bge	r2,zero,127ec <plot_trace+0x184>
   127e8:	108001c4 	addi	r2,r2,7
   127ec:	1005d0fa 	srai	r2,r2,3
   127f0:	1007883a 	mov	r3,r2
   127f4:	d0a5a917 	ldw	r2,-26972(gp)
   127f8:	e13ffe17 	ldw	r4,-8(fp)
   127fc:	2085c83a 	sub	r2,r4,r2
   12800:	010000b4 	movhi	r4,2
   12804:	2121d404 	addi	r4,r4,-30896
   12808:	108003e4 	muli	r2,r2,15
   1280c:	10c5883a 	add	r2,r2,r3
   12810:	2085883a 	add	r2,r4,r2
   12814:	10800003 	ldbu	r2,0(r2)
   12818:	1009883a 	mov	r4,r2
   1281c:	d0a5a817 	ldw	r2,-26976(gp)
   12820:	e17ff917 	ldw	r5,-28(fp)
   12824:	288bc83a 	sub	r5,r5,r2
   12828:	00a00034 	movhi	r2,32768
   1282c:	108001c4 	addi	r2,r2,7
   12830:	2884703a 	and	r2,r5,r2
   12834:	1000040e 	bge	r2,zero,12848 <plot_trace+0x1e0>
   12838:	10bfffc4 	addi	r2,r2,-1
   1283c:	017ffe04 	movi	r5,-8
   12840:	1144b03a 	or	r2,r2,r5
   12844:	10800044 	addi	r2,r2,1
   12848:	01402004 	movi	r5,128
   1284c:	2885d83a 	sra	r2,r5,r2
   12850:	2084b03a 	or	r2,r4,r2
   12854:	1009883a 	mov	r4,r2
   12858:	014000b4 	movhi	r5,2
   1285c:	2961d404 	addi	r5,r5,-30896
   12860:	308003e4 	muli	r2,r6,15
   12864:	10c5883a 	add	r2,r2,r3
   12868:	2885883a 	add	r2,r5,r2
   1286c:	11000005 	stb	r4,0(r2)

	/* check if on a grid line */
	/* go through all the horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
   12870:	00bfffc4 	movi	r2,-1
   12874:	e0bffd15 	stw	r2,-12(fp)
   12878:	00003506 	br	12950 <plot_trace+0x2e8>

	    /* get y position of the line */
	    p = X_AXIS_POS + j * Y_TICK_SIZE;
   1287c:	e0bffd17 	ldw	r2,-12(fp)
   12880:	10800c24 	muli	r2,r2,48
   12884:	10801004 	addi	r2,r2,64
   12888:	e0bffb15 	stw	r2,-20(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_Y)
   1288c:	e0bffb17 	ldw	r2,-20(fp)
   12890:	10802010 	cmplti	r2,r2,128
   12894:	1000021e 	bne	r2,zero,128a0 <plot_trace+0x238>
	        p = PLOT_SIZE_Y - 1;
   12898:	00801fc4 	movi	r2,127
   1289c:	e0bffb15 	stw	r2,-20(fp)
	    if (p < 0)
   128a0:	e0bffb17 	ldw	r2,-20(fp)
   128a4:	1000010e 	bge	r2,zero,128ac <plot_trace+0x244>
	        p = 0;
   128a8:	e03ffb15 	stw	zero,-20(fp)

	    /* if the point is on this line, save it */
	    if (y == p)
   128ac:	e0fffe17 	ldw	r3,-8(fp)
   128b0:	e0bffb17 	ldw	r2,-20(fp)
   128b4:	1880231e 	bne	r3,r2,12944 <plot_trace+0x2dc>
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
   128b8:	e0bffd17 	ldw	r2,-12(fp)
   128bc:	11800044 	addi	r6,r2,1
   128c0:	e0bff917 	ldw	r2,-28(fp)
   128c4:	1000010e 	bge	r2,zero,128cc <plot_trace+0x264>
   128c8:	108001c4 	addi	r2,r2,7
   128cc:	1005d0fa 	srai	r2,r2,3
   128d0:	1007883a 	mov	r3,r2
   128d4:	e0bffd17 	ldw	r2,-12(fp)
   128d8:	10800044 	addi	r2,r2,1
   128dc:	010000b4 	movhi	r4,2
   128e0:	2120d304 	addi	r4,r4,-31924
   128e4:	10800f24 	muli	r2,r2,60
   128e8:	10c5883a 	add	r2,r2,r3
   128ec:	2085883a 	add	r2,r4,r2
   128f0:	10800003 	ldbu	r2,0(r2)
   128f4:	1009883a 	mov	r4,r2
   128f8:	e17ff917 	ldw	r5,-28(fp)
   128fc:	00a00034 	movhi	r2,32768
   12900:	108001c4 	addi	r2,r2,7
   12904:	2884703a 	and	r2,r5,r2
   12908:	1000040e 	bge	r2,zero,1291c <plot_trace+0x2b4>
   1290c:	10bfffc4 	addi	r2,r2,-1
   12910:	017ffe04 	movi	r5,-8
   12914:	1144b03a 	or	r2,r2,r5
   12918:	10800044 	addi	r2,r2,1
   1291c:	01402004 	movi	r5,128
   12920:	2885d83a 	sra	r2,r5,r2
   12924:	2084b03a 	or	r2,r4,r2
   12928:	1009883a 	mov	r4,r2
   1292c:	014000b4 	movhi	r5,2
   12930:	2960d304 	addi	r5,r5,-31924
   12934:	30800f24 	muli	r2,r6,60
   12938:	10c5883a 	add	r2,r2,r3
   1293c:	2885883a 	add	r2,r5,r2
   12940:	11000005 	stb	r4,0(r2)
	    /* point is in the save area - save it */
	    saved_area[y - saved_pos_y][(x - saved_pos_x)/8] |= (0x80 >> ((x - saved_pos_x) % 8));

	/* check if on a grid line */
	/* go through all the horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
   12944:	e0bffd17 	ldw	r2,-12(fp)
   12948:	10800044 	addi	r2,r2,1
   1294c:	e0bffd15 	stw	r2,-12(fp)
   12950:	e0bffd17 	ldw	r2,-12(fp)
   12954:	10800090 	cmplti	r2,r2,2
   12958:	103fc81e 	bne	r2,zero,1287c <plot_trace+0x214>
	    if (y == p)
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
	}

	/* go through all the vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
   1295c:	00bffec4 	movi	r2,-5
   12960:	e0bffd15 	stw	r2,-12(fp)
   12964:	00003506 	br	12a3c <plot_trace+0x3d4>

	    /* get x position of the line */
	    p = Y_AXIS_POS + j * X_TICK_SIZE;
   12968:	e0bffd17 	ldw	r2,-12(fp)
   1296c:	10800c24 	muli	r2,r2,48
   12970:	10803c04 	addi	r2,r2,240
   12974:	e0bffb15 	stw	r2,-20(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_X)
   12978:	e0bffb17 	ldw	r2,-20(fp)
   1297c:	10807810 	cmplti	r2,r2,480
   12980:	1000021e 	bne	r2,zero,1298c <plot_trace+0x324>
	        p = PLOT_SIZE_X - 1;
   12984:	008077c4 	movi	r2,479
   12988:	e0bffb15 	stw	r2,-20(fp)
	    if (p < 0)
   1298c:	e0bffb17 	ldw	r2,-20(fp)
   12990:	1000010e 	bge	r2,zero,12998 <plot_trace+0x330>
	        p = 0;
   12994:	e03ffb15 	stw	zero,-20(fp)

	    /* if the point is on this line, save it */
	    if (x == p)
   12998:	e0fff917 	ldw	r3,-28(fp)
   1299c:	e0bffb17 	ldw	r2,-20(fp)
   129a0:	1880231e 	bne	r3,r2,12a30 <plot_trace+0x3c8>
		saved_axis_y[j + X_TICK_CNT][y / 8] |= (0x80 >> (y % 8));
   129a4:	e0bffd17 	ldw	r2,-12(fp)
   129a8:	11800144 	addi	r6,r2,5
   129ac:	e0bffe17 	ldw	r2,-8(fp)
   129b0:	1000010e 	bge	r2,zero,129b8 <plot_trace+0x350>
   129b4:	108001c4 	addi	r2,r2,7
   129b8:	1005d0fa 	srai	r2,r2,3
   129bc:	1007883a 	mov	r3,r2
   129c0:	e0bffd17 	ldw	r2,-12(fp)
   129c4:	10800144 	addi	r2,r2,5
   129c8:	010000b4 	movhi	r4,2
   129cc:	21210004 	addi	r4,r4,-31744
   129d0:	1004913a 	slli	r2,r2,4
   129d4:	10c5883a 	add	r2,r2,r3
   129d8:	2085883a 	add	r2,r4,r2
   129dc:	10800003 	ldbu	r2,0(r2)
   129e0:	1009883a 	mov	r4,r2
   129e4:	e17ffe17 	ldw	r5,-8(fp)
   129e8:	00a00034 	movhi	r2,32768
   129ec:	108001c4 	addi	r2,r2,7
   129f0:	2884703a 	and	r2,r5,r2
   129f4:	1000040e 	bge	r2,zero,12a08 <plot_trace+0x3a0>
   129f8:	10bfffc4 	addi	r2,r2,-1
   129fc:	017ffe04 	movi	r5,-8
   12a00:	1144b03a 	or	r2,r2,r5
   12a04:	10800044 	addi	r2,r2,1
   12a08:	01402004 	movi	r5,128
   12a0c:	2885d83a 	sra	r2,r5,r2
   12a10:	2084b03a 	or	r2,r4,r2
   12a14:	1009883a 	mov	r4,r2
   12a18:	014000b4 	movhi	r5,2
   12a1c:	29610004 	addi	r5,r5,-31744
   12a20:	3004913a 	slli	r2,r6,4
   12a24:	10c5883a 	add	r2,r2,r3
   12a28:	2885883a 	add	r2,r5,r2
   12a2c:	11000005 	stb	r4,0(r2)
	    if (y == p)
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
	}

	/* go through all the vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
   12a30:	e0bffd17 	ldw	r2,-12(fp)
   12a34:	10800044 	addi	r2,r2,1
   12a38:	e0bffd15 	stw	r2,-12(fp)
   12a3c:	e0bffd17 	ldw	r2,-12(fp)
   12a40:	10800190 	cmplti	r2,r2,6
   12a44:	103fc81e 	bne	r2,zero,12968 <plot_trace+0x300>
		saved_axis_y[j + X_TICK_CNT][y / 8] |= (0x80 >> (y % 8));
	}


	/* update x position */
	x_pos += PLOT_SIZE_X;
   12a48:	e0bffa17 	ldw	r2,-24(fp)
   12a4c:	10807804 	addi	r2,r2,480
   12a50:	e0bffa15 	stw	r2,-24(fp)
	/* check if at next horizontal position */
	if (x_pos >= sample_size)  {
   12a54:	d0a5a617 	ldw	r2,-26984(gp)
   12a58:	e0fffa17 	ldw	r3,-24(fp)
   12a5c:	18800716 	blt	r3,r2,12a7c <plot_trace+0x414>
	    /* at next position - update positions */
	    x++;
   12a60:	e0bff917 	ldw	r2,-28(fp)
   12a64:	10800044 	addi	r2,r2,1
   12a68:	e0bff915 	stw	r2,-28(fp)
	    x_pos -= sample_size;
   12a6c:	d0a5a617 	ldw	r2,-26984(gp)
   12a70:	e0fffa17 	ldw	r3,-24(fp)
   12a74:	1885c83a 	sub	r2,r3,r2
   12a78:	e0bffa15 	stw	r2,-24(fp)
    /* re-display the menu (if it was on) */
    refresh_menu();


    /* plot the sample */
    for (i = 0; i < sample_size; i++)  {
   12a7c:	e0bffc17 	ldw	r2,-16(fp)
   12a80:	10800044 	addi	r2,r2,1
   12a84:	e0bffc15 	stw	r2,-16(fp)
   12a88:	d0a5a617 	ldw	r2,-26984(gp)
   12a8c:	e0fffc17 	ldw	r3,-16(fp)
   12a90:	18bf0216 	blt	r3,r2,1269c <plot_trace+0x34>
	}
    }


    /* finally, output the scale if need be */
    set_display_scale(cur_scale);
   12a94:	d0a5a717 	ldw	r2,-26980(gp)
   12a98:	1009883a 	mov	r4,r2
   12a9c:	0011de00 	call	11de0 <set_display_scale>


    /* done with plot, return */
    return;
   12aa0:	0001883a 	nop

}
   12aa4:	e037883a 	mov	sp,fp
   12aa8:	dfc00117 	ldw	ra,4(sp)
   12aac:	df000017 	ldw	fp,0(sp)
   12ab0:	dec00204 	addi	sp,sp,8
   12ab4:	f800283a 	ret

00012ab8 <udivmodsi4>:
   12ab8:	2005883a 	mov	r2,r4
   12abc:	2900182e 	bgeu	r5,r4,12b20 <udivmodsi4+0x68>
   12ac0:	28001716 	blt	r5,zero,12b20 <udivmodsi4+0x68>
   12ac4:	01000804 	movi	r4,32
   12ac8:	00c00044 	movi	r3,1
   12acc:	00000206 	br	12ad8 <udivmodsi4+0x20>
   12ad0:	20001126 	beq	r4,zero,12b18 <udivmodsi4+0x60>
   12ad4:	28000516 	blt	r5,zero,12aec <udivmodsi4+0x34>
   12ad8:	294b883a 	add	r5,r5,r5
   12adc:	213fffc4 	addi	r4,r4,-1
   12ae0:	18c7883a 	add	r3,r3,r3
   12ae4:	28bffa36 	bltu	r5,r2,12ad0 <udivmodsi4+0x18>
   12ae8:	18000b26 	beq	r3,zero,12b18 <udivmodsi4+0x60>
   12aec:	0009883a 	mov	r4,zero
   12af0:	11400236 	bltu	r2,r5,12afc <udivmodsi4+0x44>
   12af4:	1145c83a 	sub	r2,r2,r5
   12af8:	20c8b03a 	or	r4,r4,r3
   12afc:	1806d07a 	srli	r3,r3,1
   12b00:	280ad07a 	srli	r5,r5,1
   12b04:	183ffa1e 	bne	r3,zero,12af0 <udivmodsi4+0x38>
   12b08:	3000021e 	bne	r6,zero,12b14 <udivmodsi4+0x5c>
   12b0c:	2005883a 	mov	r2,r4
   12b10:	f800283a 	ret
   12b14:	f800283a 	ret
   12b18:	0009883a 	mov	r4,zero
   12b1c:	003ffa06 	br	12b08 <udivmodsi4+0x50>
   12b20:	00c00044 	movi	r3,1
   12b24:	0009883a 	mov	r4,zero
   12b28:	003ff106 	br	12af0 <udivmodsi4+0x38>

00012b2c <__divsi3>:
   12b2c:	defffe04 	addi	sp,sp,-8
   12b30:	dfc00115 	stw	ra,4(sp)
   12b34:	dc000015 	stw	r16,0(sp)
   12b38:	20000a16 	blt	r4,zero,12b64 <__divsi3+0x38>
   12b3c:	0021883a 	mov	r16,zero
   12b40:	28000b16 	blt	r5,zero,12b70 <__divsi3+0x44>
   12b44:	000d883a 	mov	r6,zero
   12b48:	0012ab80 	call	12ab8 <udivmodsi4>
   12b4c:	80000126 	beq	r16,zero,12b54 <__divsi3+0x28>
   12b50:	0085c83a 	sub	r2,zero,r2
   12b54:	dfc00117 	ldw	ra,4(sp)
   12b58:	dc000017 	ldw	r16,0(sp)
   12b5c:	dec00204 	addi	sp,sp,8
   12b60:	f800283a 	ret
   12b64:	0109c83a 	sub	r4,zero,r4
   12b68:	04000044 	movi	r16,1
   12b6c:	283ff50e 	bge	r5,zero,12b44 <__divsi3+0x18>
   12b70:	014bc83a 	sub	r5,zero,r5
   12b74:	8400005c 	xori	r16,r16,1
   12b78:	003ff206 	br	12b44 <__divsi3+0x18>

00012b7c <__modsi3>:
   12b7c:	deffff04 	addi	sp,sp,-4
   12b80:	dfc00015 	stw	ra,0(sp)
   12b84:	20000516 	blt	r4,zero,12b9c <__modsi3+0x20>
   12b88:	28000c16 	blt	r5,zero,12bbc <__modsi3+0x40>
   12b8c:	01800044 	movi	r6,1
   12b90:	dfc00017 	ldw	ra,0(sp)
   12b94:	dec00104 	addi	sp,sp,4
   12b98:	0012ab81 	jmpi	12ab8 <udivmodsi4>
   12b9c:	0109c83a 	sub	r4,zero,r4
   12ba0:	28000b16 	blt	r5,zero,12bd0 <__modsi3+0x54>
   12ba4:	01800044 	movi	r6,1
   12ba8:	0012ab80 	call	12ab8 <udivmodsi4>
   12bac:	0085c83a 	sub	r2,zero,r2
   12bb0:	dfc00017 	ldw	ra,0(sp)
   12bb4:	dec00104 	addi	sp,sp,4
   12bb8:	f800283a 	ret
   12bbc:	014bc83a 	sub	r5,zero,r5
   12bc0:	01800044 	movi	r6,1
   12bc4:	dfc00017 	ldw	ra,0(sp)
   12bc8:	dec00104 	addi	sp,sp,4
   12bcc:	0012ab81 	jmpi	12ab8 <udivmodsi4>
   12bd0:	014bc83a 	sub	r5,zero,r5
   12bd4:	003ff306 	br	12ba4 <__modsi3+0x28>

00012bd8 <__udivsi3>:
   12bd8:	000d883a 	mov	r6,zero
   12bdc:	0012ab81 	jmpi	12ab8 <udivmodsi4>

00012be0 <__umodsi3>:
   12be0:	01800044 	movi	r6,1
   12be4:	0012ab81 	jmpi	12ab8 <udivmodsi4>

00012be8 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
   12be8:	defffc04 	addi	sp,sp,-16
   12bec:	df000315 	stw	fp,12(sp)
   12bf0:	df000304 	addi	fp,sp,12
   12bf4:	e13ffd15 	stw	r4,-12(fp)
   12bf8:	e17ffe15 	stw	r5,-8(fp)
   12bfc:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
   12c00:	e0fffe17 	ldw	r3,-8(fp)
   12c04:	e0bffd17 	ldw	r2,-12(fp)
   12c08:	18800e26 	beq	r3,r2,12c44 <alt_load_section+0x5c>
  {
    while( to != end )
   12c0c:	00000a06 	br	12c38 <alt_load_section+0x50>
    {
      *to++ = *from++;
   12c10:	e0bffd17 	ldw	r2,-12(fp)
   12c14:	10c00017 	ldw	r3,0(r2)
   12c18:	e0bffe17 	ldw	r2,-8(fp)
   12c1c:	10c00015 	stw	r3,0(r2)
   12c20:	e0bffe17 	ldw	r2,-8(fp)
   12c24:	10800104 	addi	r2,r2,4
   12c28:	e0bffe15 	stw	r2,-8(fp)
   12c2c:	e0bffd17 	ldw	r2,-12(fp)
   12c30:	10800104 	addi	r2,r2,4
   12c34:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
   12c38:	e0fffe17 	ldw	r3,-8(fp)
   12c3c:	e0bfff17 	ldw	r2,-4(fp)
   12c40:	18bff31e 	bne	r3,r2,12c10 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
   12c44:	e037883a 	mov	sp,fp
   12c48:	df000017 	ldw	fp,0(sp)
   12c4c:	dec00104 	addi	sp,sp,4
   12c50:	f800283a 	ret

00012c54 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   12c54:	defffe04 	addi	sp,sp,-8
   12c58:	dfc00115 	stw	ra,4(sp)
   12c5c:	df000015 	stw	fp,0(sp)
   12c60:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
   12c64:	01000074 	movhi	r4,1
   12c68:	211b2d04 	addi	r4,r4,27828
   12c6c:	01400074 	movhi	r5,1
   12c70:	29559e04 	addi	r5,r5,22136
   12c74:	01800074 	movhi	r6,1
   12c78:	319b2d04 	addi	r6,r6,27828
   12c7c:	0012be80 	call	12be8 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
   12c80:	01000074 	movhi	r4,1
   12c84:	21000804 	addi	r4,r4,32
   12c88:	01400074 	movhi	r5,1
   12c8c:	29400804 	addi	r5,r5,32
   12c90:	01800074 	movhi	r6,1
   12c94:	31806e04 	addi	r6,r6,440
   12c98:	0012be80 	call	12be8 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
   12c9c:	01000074 	movhi	r4,1
   12ca0:	21137204 	addi	r4,r4,19912
   12ca4:	01400074 	movhi	r5,1
   12ca8:	29537204 	addi	r5,r5,19912
   12cac:	01800074 	movhi	r6,1
   12cb0:	31959e04 	addi	r6,r6,22136
   12cb4:	0012be80 	call	12be8 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   12cb8:	0013ab80 	call	13ab8 <alt_dcache_flush_all>
  alt_icache_flush_all();
   12cbc:	0013cd00 	call	13cd0 <alt_icache_flush_all>
}
   12cc0:	e037883a 	mov	sp,fp
   12cc4:	dfc00117 	ldw	ra,4(sp)
   12cc8:	df000017 	ldw	fp,0(sp)
   12ccc:	dec00204 	addi	sp,sp,8
   12cd0:	f800283a 	ret

00012cd4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   12cd4:	defffd04 	addi	sp,sp,-12
   12cd8:	dfc00215 	stw	ra,8(sp)
   12cdc:	df000115 	stw	fp,4(sp)
   12ce0:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   12ce4:	0009883a 	mov	r4,zero
   12ce8:	0012d840 	call	12d84 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   12cec:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   12cf0:	0012db80 	call	12db8 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   12cf4:	01000074 	movhi	r4,1
   12cf8:	21159404 	addi	r4,r4,22096
   12cfc:	01400074 	movhi	r5,1
   12d00:	29559404 	addi	r5,r5,22096
   12d04:	01800074 	movhi	r6,1
   12d08:	31959404 	addi	r6,r6,22096
   12d0c:	00140880 	call	14088 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
   12d10:	0013c180 	call	13c18 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
   12d14:	01000074 	movhi	r4,1
   12d18:	210f1d04 	addi	r4,r4,15476
   12d1c:	00148700 	call	14870 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   12d20:	d125ac17 	ldw	r4,-26960(gp)
   12d24:	d0e5ad17 	ldw	r3,-26956(gp)
   12d28:	d0a5ae17 	ldw	r2,-26952(gp)
   12d2c:	180b883a 	mov	r5,r3
   12d30:	100d883a 	mov	r6,r2
   12d34:	00107380 	call	10738 <main>
   12d38:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   12d3c:	01000044 	movi	r4,1
   12d40:	00139f00 	call	139f0 <close>
  exit (result);
   12d44:	e13fff17 	ldw	r4,-4(fp)
   12d48:	00148840 	call	14884 <exit>

00012d4c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   12d4c:	defffd04 	addi	sp,sp,-12
   12d50:	dfc00215 	stw	ra,8(sp)
   12d54:	df000115 	stw	fp,4(sp)
   12d58:	df000104 	addi	fp,sp,4
   12d5c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   12d60:	e13fff17 	ldw	r4,-4(fp)
   12d64:	01400074 	movhi	r5,1
   12d68:	295b2404 	addi	r5,r5,27792
   12d6c:	0013b780 	call	13b78 <alt_dev_llist_insert>
}
   12d70:	e037883a 	mov	sp,fp
   12d74:	dfc00117 	ldw	ra,4(sp)
   12d78:	df000017 	ldw	fp,0(sp)
   12d7c:	dec00204 	addi	sp,sp,8
   12d80:	f800283a 	ret

00012d84 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   12d84:	defffd04 	addi	sp,sp,-12
   12d88:	dfc00215 	stw	ra,8(sp)
   12d8c:	df000115 	stw	fp,4(sp)
   12d90:	df000104 	addi	fp,sp,4
   12d94:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS, nios);
   12d98:	001456c0 	call	1456c <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   12d9c:	00800044 	movi	r2,1
   12da0:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   12da4:	e037883a 	mov	sp,fp
   12da8:	dfc00117 	ldw	ra,4(sp)
   12dac:	df000017 	ldw	fp,0(sp)
   12db0:	dec00204 	addi	sp,sp,8
   12db4:	f800283a 	ret

00012db8 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   12db8:	defffe04 	addi	sp,sp,-8
   12dbc:	dfc00115 	stw	ra,4(sp)
   12dc0:	df000015 	stw	fp,0(sp)
   12dc4:	d839883a 	mov	fp,sp
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG, jtag);
   12dc8:	01000074 	movhi	r4,1
   12dcc:	2115a804 	addi	r4,r4,22176
   12dd0:	000b883a 	mov	r5,zero
   12dd4:	000d883a 	mov	r6,zero
   12dd8:	0012f600 	call	12f60 <altera_avalon_jtag_uart_init>
   12ddc:	01000074 	movhi	r4,1
   12de0:	21159e04 	addi	r4,r4,22136
   12de4:	0012d4c0 	call	12d4c <alt_dev_reg>
}
   12de8:	e037883a 	mov	sp,fp
   12dec:	dfc00117 	ldw	ra,4(sp)
   12df0:	df000017 	ldw	fp,0(sp)
   12df4:	dec00204 	addi	sp,sp,8
   12df8:	f800283a 	ret

00012dfc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   12dfc:	defffa04 	addi	sp,sp,-24
   12e00:	dfc00515 	stw	ra,20(sp)
   12e04:	df000415 	stw	fp,16(sp)
   12e08:	df000404 	addi	fp,sp,16
   12e0c:	e13ffd15 	stw	r4,-12(fp)
   12e10:	e17ffe15 	stw	r5,-8(fp)
   12e14:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   12e18:	e0bffd17 	ldw	r2,-12(fp)
   12e1c:	10800017 	ldw	r2,0(r2)
   12e20:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   12e24:	e0bffc17 	ldw	r2,-16(fp)
   12e28:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   12e2c:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   12e30:	10800217 	ldw	r2,8(r2)
   12e34:	1809883a 	mov	r4,r3
   12e38:	e17ffe17 	ldw	r5,-8(fp)
   12e3c:	e1bfff17 	ldw	r6,-4(fp)
   12e40:	100f883a 	mov	r7,r2
   12e44:	00134240 	call	13424 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   12e48:	e037883a 	mov	sp,fp
   12e4c:	dfc00117 	ldw	ra,4(sp)
   12e50:	df000017 	ldw	fp,0(sp)
   12e54:	dec00204 	addi	sp,sp,8
   12e58:	f800283a 	ret

00012e5c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   12e5c:	defffa04 	addi	sp,sp,-24
   12e60:	dfc00515 	stw	ra,20(sp)
   12e64:	df000415 	stw	fp,16(sp)
   12e68:	df000404 	addi	fp,sp,16
   12e6c:	e13ffd15 	stw	r4,-12(fp)
   12e70:	e17ffe15 	stw	r5,-8(fp)
   12e74:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   12e78:	e0bffd17 	ldw	r2,-12(fp)
   12e7c:	10800017 	ldw	r2,0(r2)
   12e80:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   12e84:	e0bffc17 	ldw	r2,-16(fp)
   12e88:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   12e8c:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   12e90:	10800217 	ldw	r2,8(r2)
   12e94:	1809883a 	mov	r4,r3
   12e98:	e17ffe17 	ldw	r5,-8(fp)
   12e9c:	e1bfff17 	ldw	r6,-4(fp)
   12ea0:	100f883a 	mov	r7,r2
   12ea4:	001363c0 	call	1363c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   12ea8:	e037883a 	mov	sp,fp
   12eac:	dfc00117 	ldw	ra,4(sp)
   12eb0:	df000017 	ldw	fp,0(sp)
   12eb4:	dec00204 	addi	sp,sp,8
   12eb8:	f800283a 	ret

00012ebc <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
   12ebc:	defffc04 	addi	sp,sp,-16
   12ec0:	dfc00315 	stw	ra,12(sp)
   12ec4:	df000215 	stw	fp,8(sp)
   12ec8:	df000204 	addi	fp,sp,8
   12ecc:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   12ed0:	e0bfff17 	ldw	r2,-4(fp)
   12ed4:	10800017 	ldw	r2,0(r2)
   12ed8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
   12edc:	e0bffe17 	ldw	r2,-8(fp)
   12ee0:	10c00a04 	addi	r3,r2,40
   12ee4:	e0bfff17 	ldw	r2,-4(fp)
   12ee8:	10800217 	ldw	r2,8(r2)
   12eec:	1809883a 	mov	r4,r3
   12ef0:	100b883a 	mov	r5,r2
   12ef4:	00132c80 	call	132c8 <altera_avalon_jtag_uart_close>
}
   12ef8:	e037883a 	mov	sp,fp
   12efc:	dfc00117 	ldw	ra,4(sp)
   12f00:	df000017 	ldw	fp,0(sp)
   12f04:	dec00204 	addi	sp,sp,8
   12f08:	f800283a 	ret

00012f0c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
   12f0c:	defffa04 	addi	sp,sp,-24
   12f10:	dfc00515 	stw	ra,20(sp)
   12f14:	df000415 	stw	fp,16(sp)
   12f18:	df000404 	addi	fp,sp,16
   12f1c:	e13ffd15 	stw	r4,-12(fp)
   12f20:	e17ffe15 	stw	r5,-8(fp)
   12f24:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
   12f28:	e0bffd17 	ldw	r2,-12(fp)
   12f2c:	10800017 	ldw	r2,0(r2)
   12f30:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
   12f34:	e0bffc17 	ldw	r2,-16(fp)
   12f38:	10800a04 	addi	r2,r2,40
   12f3c:	1009883a 	mov	r4,r2
   12f40:	e17ffe17 	ldw	r5,-8(fp)
   12f44:	e1bfff17 	ldw	r6,-4(fp)
   12f48:	00133300 	call	13330 <altera_avalon_jtag_uart_ioctl>
}
   12f4c:	e037883a 	mov	sp,fp
   12f50:	dfc00117 	ldw	ra,4(sp)
   12f54:	df000017 	ldw	fp,0(sp)
   12f58:	dec00204 	addi	sp,sp,8
   12f5c:	f800283a 	ret

00012f60 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
   12f60:	defffa04 	addi	sp,sp,-24
   12f64:	dfc00515 	stw	ra,20(sp)
   12f68:	df000415 	stw	fp,16(sp)
   12f6c:	df000404 	addi	fp,sp,16
   12f70:	e13ffd15 	stw	r4,-12(fp)
   12f74:	e17ffe15 	stw	r5,-8(fp)
   12f78:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   12f7c:	e0bffd17 	ldw	r2,-12(fp)
   12f80:	00c00044 	movi	r3,1
   12f84:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
   12f88:	e0bffd17 	ldw	r2,-12(fp)
   12f8c:	10800017 	ldw	r2,0(r2)
   12f90:	10800104 	addi	r2,r2,4
   12f94:	e0fffd17 	ldw	r3,-12(fp)
   12f98:	18c00817 	ldw	r3,32(r3)
   12f9c:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
   12fa0:	e0fffe17 	ldw	r3,-8(fp)
   12fa4:	e0bfff17 	ldw	r2,-4(fp)
   12fa8:	d8000015 	stw	zero,0(sp)
   12fac:	1809883a 	mov	r4,r3
   12fb0:	100b883a 	mov	r5,r2
   12fb4:	01800074 	movhi	r6,1
   12fb8:	318c0804 	addi	r6,r6,12320
   12fbc:	e1fffd17 	ldw	r7,-12(fp)
   12fc0:	0013d000 	call	13d00 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
   12fc4:	e0bffd17 	ldw	r2,-12(fp)
   12fc8:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
   12fcc:	e0bffd17 	ldw	r2,-12(fp)
   12fd0:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   12fd4:	008000b4 	movhi	r2,2
   12fd8:	10a0d004 	addi	r2,r2,-31936
   12fdc:	10800017 	ldw	r2,0(r2)
   12fe0:	1809883a 	mov	r4,r3
   12fe4:	100b883a 	mov	r5,r2
   12fe8:	01800074 	movhi	r6,1
   12fec:	318c8904 	addi	r6,r6,12836
   12ff0:	e1fffd17 	ldw	r7,-12(fp)
   12ff4:	00138600 	call	13860 <alt_alarm_start>
   12ff8:	1000040e 	bge	r2,zero,1300c <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
   12ffc:	e0bffd17 	ldw	r2,-12(fp)
   13000:	00e00034 	movhi	r3,32768
   13004:	18ffffc4 	addi	r3,r3,-1
   13008:	10c00115 	stw	r3,4(r2)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
   1300c:	e037883a 	mov	sp,fp
   13010:	dfc00117 	ldw	ra,4(sp)
   13014:	df000017 	ldw	fp,0(sp)
   13018:	dec00204 	addi	sp,sp,8
   1301c:	f800283a 	ret

00013020 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
   13020:	defff804 	addi	sp,sp,-32
   13024:	df000715 	stw	fp,28(sp)
   13028:	df000704 	addi	fp,sp,28
   1302c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
   13030:	e0bfff17 	ldw	r2,-4(fp)
   13034:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
   13038:	e0bffb17 	ldw	r2,-20(fp)
   1303c:	10800017 	ldw	r2,0(r2)
   13040:	e0bffc15 	stw	r2,-16(fp)
   13044:	00000106 	br	1304c <altera_avalon_jtag_uart_irq+0x2c>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
   13048:	0001883a 	nop
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   1304c:	e0bffc17 	ldw	r2,-16(fp)
   13050:	10800104 	addi	r2,r2,4
   13054:	10800037 	ldwio	r2,0(r2)
   13058:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
   1305c:	e0bffd17 	ldw	r2,-12(fp)
   13060:	1080c00c 	andi	r2,r2,768
   13064:	10006a26 	beq	r2,zero,13210 <altera_avalon_jtag_uart_irq+0x1f0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
   13068:	e0bffd17 	ldw	r2,-12(fp)
   1306c:	1080400c 	andi	r2,r2,256
   13070:	10003326 	beq	r2,zero,13140 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
   13074:	00800074 	movhi	r2,1
   13078:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   1307c:	e0bffb17 	ldw	r2,-20(fp)
   13080:	10800a17 	ldw	r2,40(r2)
   13084:	10800044 	addi	r2,r2,1
   13088:	1081ffcc 	andi	r2,r2,2047
   1308c:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
   13090:	e0bffb17 	ldw	r2,-20(fp)
   13094:	10c00b17 	ldw	r3,44(r2)
   13098:	e0bffe17 	ldw	r2,-8(fp)
   1309c:	18801426 	beq	r3,r2,130f0 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   130a0:	e0bffc17 	ldw	r2,-16(fp)
   130a4:	10800037 	ldwio	r2,0(r2)
   130a8:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
   130ac:	e0bff917 	ldw	r2,-28(fp)
   130b0:	10a0000c 	andi	r2,r2,32768
   130b4:	10001026 	beq	r2,zero,130f8 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   130b8:	e0bffb17 	ldw	r2,-20(fp)
   130bc:	10800a17 	ldw	r2,40(r2)
   130c0:	e0fff917 	ldw	r3,-28(fp)
   130c4:	e13ffb17 	ldw	r4,-20(fp)
   130c8:	2085883a 	add	r2,r4,r2
   130cc:	10800e04 	addi	r2,r2,56
   130d0:	10c00005 	stb	r3,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   130d4:	e0bffb17 	ldw	r2,-20(fp)
   130d8:	10800a17 	ldw	r2,40(r2)
   130dc:	10800044 	addi	r2,r2,1
   130e0:	10c1ffcc 	andi	r3,r2,2047
   130e4:	e0bffb17 	ldw	r2,-20(fp)
   130e8:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
   130ec:	003fe306 	br	1307c <altera_avalon_jtag_uart_irq+0x5c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
   130f0:	0001883a 	nop
   130f4:	00000106 	br	130fc <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
   130f8:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
   130fc:	e0bff917 	ldw	r2,-28(fp)
   13100:	10bfffec 	andhi	r2,r2,65535
   13104:	10000e26 	beq	r2,zero,13140 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   13108:	e0bffb17 	ldw	r2,-20(fp)
   1310c:	10c00817 	ldw	r3,32(r2)
   13110:	00bfff84 	movi	r2,-2
   13114:	1886703a 	and	r3,r3,r2
   13118:	e0bffb17 	ldw	r2,-20(fp)
   1311c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
   13120:	e0bffc17 	ldw	r2,-16(fp)
   13124:	10800104 	addi	r2,r2,4
   13128:	e0fffb17 	ldw	r3,-20(fp)
   1312c:	18c00817 	ldw	r3,32(r3)
   13130:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   13134:	e0bffc17 	ldw	r2,-16(fp)
   13138:	10800104 	addi	r2,r2,4
   1313c:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
   13140:	e0bffd17 	ldw	r2,-12(fp)
   13144:	1080800c 	andi	r2,r2,512
   13148:	103fbf26 	beq	r2,zero,13048 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
   1314c:	e0bffd17 	ldw	r2,-12(fp)
   13150:	1004d43a 	srli	r2,r2,16
   13154:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
   13158:	00001406 	br	131ac <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
   1315c:	e0bffc17 	ldw	r2,-16(fp)
   13160:	e0fffb17 	ldw	r3,-20(fp)
   13164:	18c00d17 	ldw	r3,52(r3)
   13168:	e13ffb17 	ldw	r4,-20(fp)
   1316c:	20c7883a 	add	r3,r4,r3
   13170:	18c20e04 	addi	r3,r3,2104
   13174:	18c00003 	ldbu	r3,0(r3)
   13178:	18c03fcc 	andi	r3,r3,255
   1317c:	18c0201c 	xori	r3,r3,128
   13180:	18ffe004 	addi	r3,r3,-128
   13184:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   13188:	e0bffb17 	ldw	r2,-20(fp)
   1318c:	10800d17 	ldw	r2,52(r2)
   13190:	10800044 	addi	r2,r2,1
   13194:	10c1ffcc 	andi	r3,r2,2047
   13198:	e0bffb17 	ldw	r2,-20(fp)
   1319c:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
   131a0:	e0bffa17 	ldw	r2,-24(fp)
   131a4:	10bfffc4 	addi	r2,r2,-1
   131a8:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
   131ac:	e0bffa17 	ldw	r2,-24(fp)
   131b0:	10000526 	beq	r2,zero,131c8 <altera_avalon_jtag_uart_irq+0x1a8>
   131b4:	e0bffb17 	ldw	r2,-20(fp)
   131b8:	10c00d17 	ldw	r3,52(r2)
   131bc:	e0bffb17 	ldw	r2,-20(fp)
   131c0:	10800c17 	ldw	r2,48(r2)
   131c4:	18bfe51e 	bne	r3,r2,1315c <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
   131c8:	e0bffa17 	ldw	r2,-24(fp)
   131cc:	103f9e26 	beq	r2,zero,13048 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   131d0:	e0bffb17 	ldw	r2,-20(fp)
   131d4:	10c00817 	ldw	r3,32(r2)
   131d8:	00bfff44 	movi	r2,-3
   131dc:	1886703a 	and	r3,r3,r2
   131e0:	e0bffb17 	ldw	r2,-20(fp)
   131e4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   131e8:	e0bffb17 	ldw	r2,-20(fp)
   131ec:	10800017 	ldw	r2,0(r2)
   131f0:	10800104 	addi	r2,r2,4
   131f4:	e0fffb17 	ldw	r3,-20(fp)
   131f8:	18c00817 	ldw	r3,32(r3)
   131fc:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   13200:	e0bffc17 	ldw	r2,-16(fp)
   13204:	10800104 	addi	r2,r2,4
   13208:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
   1320c:	003f8e06 	br	13048 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
   13210:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
   13214:	e037883a 	mov	sp,fp
   13218:	df000017 	ldw	fp,0(sp)
   1321c:	dec00104 	addi	sp,sp,4
   13220:	f800283a 	ret

00013224 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
   13224:	defffc04 	addi	sp,sp,-16
   13228:	df000315 	stw	fp,12(sp)
   1322c:	df000304 	addi	fp,sp,12
   13230:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
   13234:	e0bfff17 	ldw	r2,-4(fp)
   13238:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
   1323c:	e0bffd17 	ldw	r2,-12(fp)
   13240:	10800017 	ldw	r2,0(r2)
   13244:	10800104 	addi	r2,r2,4
   13248:	10800037 	ldwio	r2,0(r2)
   1324c:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
   13250:	e0bffe17 	ldw	r2,-8(fp)
   13254:	1081000c 	andi	r2,r2,1024
   13258:	10000a26 	beq	r2,zero,13284 <altera_avalon_jtag_uart_timeout+0x60>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
   1325c:	e0bffd17 	ldw	r2,-12(fp)
   13260:	10800017 	ldw	r2,0(r2)
   13264:	10800104 	addi	r2,r2,4
   13268:	e0fffd17 	ldw	r3,-12(fp)
   1326c:	18c00817 	ldw	r3,32(r3)
   13270:	18c10014 	ori	r3,r3,1024
   13274:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
   13278:	e0bffd17 	ldw	r2,-12(fp)
   1327c:	10000915 	stw	zero,36(r2)
   13280:	00000a06 	br	132ac <altera_avalon_jtag_uart_timeout+0x88>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
   13284:	e0bffd17 	ldw	r2,-12(fp)
   13288:	10800917 	ldw	r2,36(r2)
   1328c:	00e00034 	movhi	r3,32768
   13290:	18ffff04 	addi	r3,r3,-4
   13294:	18800536 	bltu	r3,r2,132ac <altera_avalon_jtag_uart_timeout+0x88>
    sp->host_inactive++;
   13298:	e0bffd17 	ldw	r2,-12(fp)
   1329c:	10800917 	ldw	r2,36(r2)
   132a0:	10c00044 	addi	r3,r2,1
   132a4:	e0bffd17 	ldw	r2,-12(fp)
   132a8:	10c00915 	stw	r3,36(r2)
   132ac:	008000b4 	movhi	r2,2
   132b0:	10a0d004 	addi	r2,r2,-31936
   132b4:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
   132b8:	e037883a 	mov	sp,fp
   132bc:	df000017 	ldw	fp,0(sp)
   132c0:	dec00104 	addi	sp,sp,4
   132c4:	f800283a 	ret

000132c8 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
   132c8:	defffd04 	addi	sp,sp,-12
   132cc:	df000215 	stw	fp,8(sp)
   132d0:	df000204 	addi	fp,sp,8
   132d4:	e13ffe15 	stw	r4,-8(fp)
   132d8:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   132dc:	00000506 	br	132f4 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   132e0:	e0bfff17 	ldw	r2,-4(fp)
   132e4:	1090000c 	andi	r2,r2,16384
   132e8:	10000226 	beq	r2,zero,132f4 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
   132ec:	00bffd44 	movi	r2,-11
   132f0:	00000b06 	br	13320 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   132f4:	e0bffe17 	ldw	r2,-8(fp)
   132f8:	10c00d17 	ldw	r3,52(r2)
   132fc:	e0bffe17 	ldw	r2,-8(fp)
   13300:	10800c17 	ldw	r2,48(r2)
   13304:	18800526 	beq	r3,r2,1331c <altera_avalon_jtag_uart_close+0x54>
   13308:	e0bffe17 	ldw	r2,-8(fp)
   1330c:	10c00917 	ldw	r3,36(r2)
   13310:	e0bffe17 	ldw	r2,-8(fp)
   13314:	10800117 	ldw	r2,4(r2)
   13318:	18bff136 	bltu	r3,r2,132e0 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   1331c:	0005883a 	mov	r2,zero
}
   13320:	e037883a 	mov	sp,fp
   13324:	df000017 	ldw	fp,0(sp)
   13328:	dec00104 	addi	sp,sp,4
   1332c:	f800283a 	ret

00013330 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
   13330:	defffa04 	addi	sp,sp,-24
   13334:	df000515 	stw	fp,20(sp)
   13338:	df000504 	addi	fp,sp,20
   1333c:	e13ffd15 	stw	r4,-12(fp)
   13340:	e17ffe15 	stw	r5,-8(fp)
   13344:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
   13348:	00bff9c4 	movi	r2,-25
   1334c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
   13350:	e0bffe17 	ldw	r2,-8(fp)
   13354:	10da8060 	cmpeqi	r3,r2,27137
   13358:	1800031e 	bne	r3,zero,13368 <altera_avalon_jtag_uart_ioctl+0x38>
   1335c:	109a80a0 	cmpeqi	r2,r2,27138
   13360:	1000181e 	bne	r2,zero,133c4 <altera_avalon_jtag_uart_ioctl+0x94>
   13364:	00002606 	br	13400 <altera_avalon_jtag_uart_ioctl+0xd0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
   13368:	e0bffd17 	ldw	r2,-12(fp)
   1336c:	10c00117 	ldw	r3,4(r2)
   13370:	00a00034 	movhi	r2,32768
   13374:	10bfffc4 	addi	r2,r2,-1
   13378:	18802226 	beq	r3,r2,13404 <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      int timeout = *((int *)arg);
   1337c:	e0bfff17 	ldw	r2,-4(fp)
   13380:	10800017 	ldw	r2,0(r2)
   13384:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
   13388:	e0bffc17 	ldw	r2,-16(fp)
   1338c:	10800090 	cmplti	r2,r2,2
   13390:	1000061e 	bne	r2,zero,133ac <altera_avalon_jtag_uart_ioctl+0x7c>
   13394:	e0fffc17 	ldw	r3,-16(fp)
   13398:	00a00034 	movhi	r2,32768
   1339c:	10bfffc4 	addi	r2,r2,-1
   133a0:	18800226 	beq	r3,r2,133ac <altera_avalon_jtag_uart_ioctl+0x7c>
   133a4:	e0bffc17 	ldw	r2,-16(fp)
   133a8:	00000206 	br	133b4 <altera_avalon_jtag_uart_ioctl+0x84>
   133ac:	00a00034 	movhi	r2,32768
   133b0:	10bfff84 	addi	r2,r2,-2
   133b4:	e0fffd17 	ldw	r3,-12(fp)
   133b8:	18800115 	stw	r2,4(r3)
      rc = 0;
   133bc:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   133c0:	00001006 	br	13404 <altera_avalon_jtag_uart_ioctl+0xd4>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
   133c4:	e0bffd17 	ldw	r2,-12(fp)
   133c8:	10c00117 	ldw	r3,4(r2)
   133cc:	00a00034 	movhi	r2,32768
   133d0:	10bfffc4 	addi	r2,r2,-1
   133d4:	18800d26 	beq	r3,r2,1340c <altera_avalon_jtag_uart_ioctl+0xdc>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
   133d8:	e0bffd17 	ldw	r2,-12(fp)
   133dc:	10c00917 	ldw	r3,36(r2)
   133e0:	e0bffd17 	ldw	r2,-12(fp)
   133e4:	10800117 	ldw	r2,4(r2)
   133e8:	1885803a 	cmpltu	r2,r3,r2
   133ec:	10c03fcc 	andi	r3,r2,255
   133f0:	e0bfff17 	ldw	r2,-4(fp)
   133f4:	10c00015 	stw	r3,0(r2)
      rc = 0;
   133f8:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   133fc:	00000306 	br	1340c <altera_avalon_jtag_uart_ioctl+0xdc>

  default:
    break;
   13400:	00000306 	br	13410 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
   13404:	0001883a 	nop
   13408:	00000106 	br	13410 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
   1340c:	0001883a 	nop

  default:
    break;
  }

  return rc;
   13410:	e0bffb17 	ldw	r2,-20(fp)
}
   13414:	e037883a 	mov	sp,fp
   13418:	df000017 	ldw	fp,0(sp)
   1341c:	dec00104 	addi	sp,sp,4
   13420:	f800283a 	ret

00013424 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
   13424:	defff304 	addi	sp,sp,-52
   13428:	dfc00c15 	stw	ra,48(sp)
   1342c:	df000b15 	stw	fp,44(sp)
   13430:	df000b04 	addi	fp,sp,44
   13434:	e13ffc15 	stw	r4,-16(fp)
   13438:	e17ffd15 	stw	r5,-12(fp)
   1343c:	e1bffe15 	stw	r6,-8(fp)
   13440:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
   13444:	e0bffd17 	ldw	r2,-12(fp)
   13448:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   1344c:	00004706 	br	1356c <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
   13450:	e0bffc17 	ldw	r2,-16(fp)
   13454:	10800a17 	ldw	r2,40(r2)
   13458:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
   1345c:	e0bffc17 	ldw	r2,-16(fp)
   13460:	10800b17 	ldw	r2,44(r2)
   13464:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
   13468:	e0fff717 	ldw	r3,-36(fp)
   1346c:	e0bff817 	ldw	r2,-32(fp)
   13470:	18800536 	bltu	r3,r2,13488 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
   13474:	e0fff717 	ldw	r3,-36(fp)
   13478:	e0bff817 	ldw	r2,-32(fp)
   1347c:	1885c83a 	sub	r2,r3,r2
   13480:	e0bff615 	stw	r2,-40(fp)
   13484:	00000406 	br	13498 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
   13488:	00c20004 	movi	r3,2048
   1348c:	e0bff817 	ldw	r2,-32(fp)
   13490:	1885c83a 	sub	r2,r3,r2
   13494:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
   13498:	e0bff617 	ldw	r2,-40(fp)
   1349c:	10001e26 	beq	r2,zero,13518 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
   134a0:	e0fffe17 	ldw	r3,-8(fp)
   134a4:	e0bff617 	ldw	r2,-40(fp)
   134a8:	1880022e 	bgeu	r3,r2,134b4 <altera_avalon_jtag_uart_read+0x90>
        n = space;
   134ac:	e0bffe17 	ldw	r2,-8(fp)
   134b0:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
   134b4:	e0bff817 	ldw	r2,-32(fp)
   134b8:	10800e04 	addi	r2,r2,56
   134bc:	e0fffc17 	ldw	r3,-16(fp)
   134c0:	1885883a 	add	r2,r3,r2
   134c4:	e13ff517 	ldw	r4,-44(fp)
   134c8:	100b883a 	mov	r5,r2
   134cc:	e1bff617 	ldw	r6,-40(fp)
   134d0:	00149380 	call	14938 <memcpy>
      ptr   += n;
   134d4:	e0fff517 	ldw	r3,-44(fp)
   134d8:	e0bff617 	ldw	r2,-40(fp)
   134dc:	1885883a 	add	r2,r3,r2
   134e0:	e0bff515 	stw	r2,-44(fp)
      space -= n;
   134e4:	e0fffe17 	ldw	r3,-8(fp)
   134e8:	e0bff617 	ldw	r2,-40(fp)
   134ec:	1885c83a 	sub	r2,r3,r2
   134f0:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   134f4:	e0fff817 	ldw	r3,-32(fp)
   134f8:	e0bff617 	ldw	r2,-40(fp)
   134fc:	1885883a 	add	r2,r3,r2
   13500:	10c1ffcc 	andi	r3,r2,2047
   13504:	e0bffc17 	ldw	r2,-16(fp)
   13508:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
   1350c:	e0bffe17 	ldw	r2,-8(fp)
   13510:	00bfcf16 	blt	zero,r2,13450 <altera_avalon_jtag_uart_read+0x2c>
   13514:	00000106 	br	1351c <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
   13518:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
   1351c:	e0fff517 	ldw	r3,-44(fp)
   13520:	e0bffd17 	ldw	r2,-12(fp)
   13524:	1880141e 	bne	r3,r2,13578 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
   13528:	e0bfff17 	ldw	r2,-4(fp)
   1352c:	1090000c 	andi	r2,r2,16384
   13530:	1000131e 	bne	r2,zero,13580 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
   13534:	0001883a 	nop
   13538:	e0bffc17 	ldw	r2,-16(fp)
   1353c:	10c00a17 	ldw	r3,40(r2)
   13540:	e0bff717 	ldw	r2,-36(fp)
   13544:	1880051e 	bne	r3,r2,1355c <altera_avalon_jtag_uart_read+0x138>
   13548:	e0bffc17 	ldw	r2,-16(fp)
   1354c:	10c00917 	ldw	r3,36(r2)
   13550:	e0bffc17 	ldw	r2,-16(fp)
   13554:	10800117 	ldw	r2,4(r2)
   13558:	18bff736 	bltu	r3,r2,13538 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
   1355c:	e0bffc17 	ldw	r2,-16(fp)
   13560:	10c00a17 	ldw	r3,40(r2)
   13564:	e0bff717 	ldw	r2,-36(fp)
   13568:	18800726 	beq	r3,r2,13588 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   1356c:	e0bffe17 	ldw	r2,-8(fp)
   13570:	00bfb716 	blt	zero,r2,13450 <altera_avalon_jtag_uart_read+0x2c>
   13574:	00000506 	br	1358c <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
   13578:	0001883a 	nop
   1357c:	00000306 	br	1358c <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
   13580:	0001883a 	nop
   13584:	00000106 	br	1358c <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
   13588:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
   1358c:	e0fff517 	ldw	r3,-44(fp)
   13590:	e0bffd17 	ldw	r2,-12(fp)
   13594:	18801726 	beq	r3,r2,135f4 <altera_avalon_jtag_uart_read+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   13598:	0005303a 	rdctl	r2,status
   1359c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   135a0:	e0fffa17 	ldw	r3,-24(fp)
   135a4:	00bfff84 	movi	r2,-2
   135a8:	1884703a 	and	r2,r3,r2
   135ac:	1001703a 	wrctl	status,r2
  
  return context;
   135b0:	e0bffa17 	ldw	r2,-24(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
   135b4:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   135b8:	e0bffc17 	ldw	r2,-16(fp)
   135bc:	10800817 	ldw	r2,32(r2)
   135c0:	10c00054 	ori	r3,r2,1
   135c4:	e0bffc17 	ldw	r2,-16(fp)
   135c8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   135cc:	e0bffc17 	ldw	r2,-16(fp)
   135d0:	10800017 	ldw	r2,0(r2)
   135d4:	10800104 	addi	r2,r2,4
   135d8:	e0fffc17 	ldw	r3,-16(fp)
   135dc:	18c00817 	ldw	r3,32(r3)
   135e0:	10c00035 	stwio	r3,0(r2)
   135e4:	e0bff917 	ldw	r2,-28(fp)
   135e8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   135ec:	e0bffb17 	ldw	r2,-20(fp)
   135f0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
   135f4:	e0fff517 	ldw	r3,-44(fp)
   135f8:	e0bffd17 	ldw	r2,-12(fp)
   135fc:	18800426 	beq	r3,r2,13610 <altera_avalon_jtag_uart_read+0x1ec>
    return ptr - buffer;
   13600:	e0fff517 	ldw	r3,-44(fp)
   13604:	e0bffd17 	ldw	r2,-12(fp)
   13608:	1885c83a 	sub	r2,r3,r2
   1360c:	00000606 	br	13628 <altera_avalon_jtag_uart_read+0x204>
  else if (flags & O_NONBLOCK)
   13610:	e0bfff17 	ldw	r2,-4(fp)
   13614:	1090000c 	andi	r2,r2,16384
   13618:	10000226 	beq	r2,zero,13624 <altera_avalon_jtag_uart_read+0x200>
    return -EWOULDBLOCK;
   1361c:	00bffd44 	movi	r2,-11
   13620:	00000106 	br	13628 <altera_avalon_jtag_uart_read+0x204>
  else
    return -EIO;
   13624:	00bffec4 	movi	r2,-5
}
   13628:	e037883a 	mov	sp,fp
   1362c:	dfc00117 	ldw	ra,4(sp)
   13630:	df000017 	ldw	fp,0(sp)
   13634:	dec00204 	addi	sp,sp,8
   13638:	f800283a 	ret

0001363c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   1363c:	defff304 	addi	sp,sp,-52
   13640:	dfc00c15 	stw	ra,48(sp)
   13644:	df000b15 	stw	fp,44(sp)
   13648:	df000b04 	addi	fp,sp,44
   1364c:	e13ffc15 	stw	r4,-16(fp)
   13650:	e17ffd15 	stw	r5,-12(fp)
   13654:	e1bffe15 	stw	r6,-8(fp)
   13658:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
   1365c:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
   13660:	e0bffd17 	ldw	r2,-12(fp)
   13664:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   13668:	00003706 	br	13748 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
   1366c:	e0bffc17 	ldw	r2,-16(fp)
   13670:	10800c17 	ldw	r2,48(r2)
   13674:	e0bff815 	stw	r2,-32(fp)
      out = sp->tx_out;
   13678:	e0bffc17 	ldw	r2,-16(fp)
   1367c:	10800d17 	ldw	r2,52(r2)
   13680:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
   13684:	e0fff817 	ldw	r3,-32(fp)
   13688:	e0bff517 	ldw	r2,-44(fp)
   1368c:	1880062e 	bgeu	r3,r2,136a8 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
   13690:	e0fff517 	ldw	r3,-44(fp)
   13694:	e0bff817 	ldw	r2,-32(fp)
   13698:	1885c83a 	sub	r2,r3,r2
   1369c:	10bfffc4 	addi	r2,r2,-1
   136a0:	e0bff615 	stw	r2,-40(fp)
   136a4:	00000b06 	br	136d4 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
   136a8:	e0bff517 	ldw	r2,-44(fp)
   136ac:	10000526 	beq	r2,zero,136c4 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
   136b0:	00c20004 	movi	r3,2048
   136b4:	e0bff817 	ldw	r2,-32(fp)
   136b8:	1885c83a 	sub	r2,r3,r2
   136bc:	e0bff615 	stw	r2,-40(fp)
   136c0:	00000406 	br	136d4 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
   136c4:	00c1ffc4 	movi	r3,2047
   136c8:	e0bff817 	ldw	r2,-32(fp)
   136cc:	1885c83a 	sub	r2,r3,r2
   136d0:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
   136d4:	e0bff617 	ldw	r2,-40(fp)
   136d8:	10001e26 	beq	r2,zero,13754 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
   136dc:	e0fffe17 	ldw	r3,-8(fp)
   136e0:	e0bff617 	ldw	r2,-40(fp)
   136e4:	1880022e 	bgeu	r3,r2,136f0 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
   136e8:	e0bffe17 	ldw	r2,-8(fp)
   136ec:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
   136f0:	e0bff817 	ldw	r2,-32(fp)
   136f4:	10820e04 	addi	r2,r2,2104
   136f8:	e0fffc17 	ldw	r3,-16(fp)
   136fc:	1885883a 	add	r2,r3,r2
   13700:	1009883a 	mov	r4,r2
   13704:	e17ffd17 	ldw	r5,-12(fp)
   13708:	e1bff617 	ldw	r6,-40(fp)
   1370c:	00149380 	call	14938 <memcpy>
      ptr   += n;
   13710:	e0fffd17 	ldw	r3,-12(fp)
   13714:	e0bff617 	ldw	r2,-40(fp)
   13718:	1885883a 	add	r2,r3,r2
   1371c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
   13720:	e0fffe17 	ldw	r3,-8(fp)
   13724:	e0bff617 	ldw	r2,-40(fp)
   13728:	1885c83a 	sub	r2,r3,r2
   1372c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   13730:	e0fff817 	ldw	r3,-32(fp)
   13734:	e0bff617 	ldw	r2,-40(fp)
   13738:	1885883a 	add	r2,r3,r2
   1373c:	10c1ffcc 	andi	r3,r2,2047
   13740:	e0bffc17 	ldw	r2,-16(fp)
   13744:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   13748:	e0bffe17 	ldw	r2,-8(fp)
   1374c:	00bfc716 	blt	zero,r2,1366c <altera_avalon_jtag_uart_write+0x30>
   13750:	00000106 	br	13758 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
   13754:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   13758:	0005303a 	rdctl	r2,status
   1375c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   13760:	e0fffa17 	ldw	r3,-24(fp)
   13764:	00bfff84 	movi	r2,-2
   13768:	1884703a 	and	r2,r3,r2
   1376c:	1001703a 	wrctl	status,r2
  
  return context;
   13770:	e0bffa17 	ldw	r2,-24(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
   13774:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   13778:	e0bffc17 	ldw	r2,-16(fp)
   1377c:	10800817 	ldw	r2,32(r2)
   13780:	10c00094 	ori	r3,r2,2
   13784:	e0bffc17 	ldw	r2,-16(fp)
   13788:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   1378c:	e0bffc17 	ldw	r2,-16(fp)
   13790:	10800017 	ldw	r2,0(r2)
   13794:	10800104 	addi	r2,r2,4
   13798:	e0fffc17 	ldw	r3,-16(fp)
   1379c:	18c00817 	ldw	r3,32(r3)
   137a0:	10c00035 	stwio	r3,0(r2)
   137a4:	e0bff917 	ldw	r2,-28(fp)
   137a8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   137ac:	e0bffb17 	ldw	r2,-20(fp)
   137b0:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
   137b4:	e0bffe17 	ldw	r2,-8(fp)
   137b8:	0080110e 	bge	zero,r2,13800 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
   137bc:	e0bfff17 	ldw	r2,-4(fp)
   137c0:	1090000c 	andi	r2,r2,16384
   137c4:	1000111e 	bne	r2,zero,1380c <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
   137c8:	0001883a 	nop
   137cc:	e0bffc17 	ldw	r2,-16(fp)
   137d0:	10c00d17 	ldw	r3,52(r2)
   137d4:	e0bff517 	ldw	r2,-44(fp)
   137d8:	1880051e 	bne	r3,r2,137f0 <altera_avalon_jtag_uart_write+0x1b4>
   137dc:	e0bffc17 	ldw	r2,-16(fp)
   137e0:	10c00917 	ldw	r3,36(r2)
   137e4:	e0bffc17 	ldw	r2,-16(fp)
   137e8:	10800117 	ldw	r2,4(r2)
   137ec:	18bff736 	bltu	r3,r2,137cc <altera_avalon_jtag_uart_write+0x190>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
   137f0:	e0bffc17 	ldw	r2,-16(fp)
   137f4:	10c00d17 	ldw	r3,52(r2)
   137f8:	e0bff517 	ldw	r2,-44(fp)
   137fc:	18800526 	beq	r3,r2,13814 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
   13800:	e0bffe17 	ldw	r2,-8(fp)
   13804:	00bfd016 	blt	zero,r2,13748 <altera_avalon_jtag_uart_write+0x10c>
   13808:	00000306 	br	13818 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
   1380c:	0001883a 	nop
   13810:	00000106 	br	13818 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
         break;
   13814:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
   13818:	e0fffd17 	ldw	r3,-12(fp)
   1381c:	e0bff717 	ldw	r2,-36(fp)
   13820:	18800426 	beq	r3,r2,13834 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
   13824:	e0fffd17 	ldw	r3,-12(fp)
   13828:	e0bff717 	ldw	r2,-36(fp)
   1382c:	1885c83a 	sub	r2,r3,r2
   13830:	00000606 	br	1384c <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
   13834:	e0bfff17 	ldw	r2,-4(fp)
   13838:	1090000c 	andi	r2,r2,16384
   1383c:	10000226 	beq	r2,zero,13848 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
   13840:	00bffd44 	movi	r2,-11
   13844:	00000106 	br	1384c <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
   13848:	00bffec4 	movi	r2,-5
}
   1384c:	e037883a 	mov	sp,fp
   13850:	dfc00117 	ldw	ra,4(sp)
   13854:	df000017 	ldw	fp,0(sp)
   13858:	dec00204 	addi	sp,sp,8
   1385c:	f800283a 	ret

00013860 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
   13860:	defff504 	addi	sp,sp,-44
   13864:	df000a15 	stw	fp,40(sp)
   13868:	df000a04 	addi	fp,sp,40
   1386c:	e13ffc15 	stw	r4,-16(fp)
   13870:	e17ffd15 	stw	r5,-12(fp)
   13874:	e1bffe15 	stw	r6,-8(fp)
   13878:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
   1387c:	e03ff615 	stw	zero,-40(fp)
   13880:	008000b4 	movhi	r2,2
   13884:	10a0d004 	addi	r2,r2,-31936
   13888:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
   1388c:	10003f26 	beq	r2,zero,1398c <alt_alarm_start+0x12c>
  {
    if (alarm)
   13890:	e0bffc17 	ldw	r2,-16(fp)
   13894:	10003b26 	beq	r2,zero,13984 <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
   13898:	e0bffc17 	ldw	r2,-16(fp)
   1389c:	e0fffe17 	ldw	r3,-8(fp)
   138a0:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
   138a4:	e0bffc17 	ldw	r2,-16(fp)
   138a8:	e0ffff17 	ldw	r3,-4(fp)
   138ac:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   138b0:	0005303a 	rdctl	r2,status
   138b4:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   138b8:	e0fff817 	ldw	r3,-32(fp)
   138bc:	00bfff84 	movi	r2,-2
   138c0:	1884703a 	and	r2,r3,r2
   138c4:	1001703a 	wrctl	status,r2
  
  return context;
   138c8:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
   138cc:	e0bff715 	stw	r2,-36(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
   138d0:	008000b4 	movhi	r2,2
   138d4:	10a0d104 	addi	r2,r2,-31932
   138d8:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
   138dc:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
   138e0:	e0fffd17 	ldw	r3,-12(fp)
   138e4:	e0bff617 	ldw	r2,-40(fp)
   138e8:	1885883a 	add	r2,r3,r2
   138ec:	10c00044 	addi	r3,r2,1
   138f0:	e0bffc17 	ldw	r2,-16(fp)
   138f4:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
   138f8:	e0bffc17 	ldw	r2,-16(fp)
   138fc:	10c00217 	ldw	r3,8(r2)
   13900:	e0bff617 	ldw	r2,-40(fp)
   13904:	1880042e 	bgeu	r3,r2,13918 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
   13908:	e0bffc17 	ldw	r2,-16(fp)
   1390c:	00c00044 	movi	r3,1
   13910:	10c00405 	stb	r3,16(r2)
   13914:	00000206 	br	13920 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
   13918:	e0bffc17 	ldw	r2,-16(fp)
   1391c:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
   13920:	e0bffc17 	ldw	r2,-16(fp)
   13924:	00c00074 	movhi	r3,1
   13928:	18db2904 	addi	r3,r3,27812
   1392c:	e0fff915 	stw	r3,-28(fp)
   13930:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   13934:	e0bffa17 	ldw	r2,-24(fp)
   13938:	e0fff917 	ldw	r3,-28(fp)
   1393c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   13940:	e0bff917 	ldw	r2,-28(fp)
   13944:	10c00017 	ldw	r3,0(r2)
   13948:	e0bffa17 	ldw	r2,-24(fp)
   1394c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   13950:	e0bff917 	ldw	r2,-28(fp)
   13954:	10800017 	ldw	r2,0(r2)
   13958:	e0fffa17 	ldw	r3,-24(fp)
   1395c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   13960:	e0bff917 	ldw	r2,-28(fp)
   13964:	e0fffa17 	ldw	r3,-24(fp)
   13968:	10c00015 	stw	r3,0(r2)
   1396c:	e0bff717 	ldw	r2,-36(fp)
   13970:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   13974:	e0bffb17 	ldw	r2,-20(fp)
   13978:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
   1397c:	0005883a 	mov	r2,zero
   13980:	00000306 	br	13990 <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
   13984:	00bffa84 	movi	r2,-22
   13988:	00000106 	br	13990 <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
   1398c:	00bfde84 	movi	r2,-134
  }
}
   13990:	e037883a 	mov	sp,fp
   13994:	df000017 	ldw	fp,0(sp)
   13998:	dec00104 	addi	sp,sp,4
   1399c:	f800283a 	ret

000139a0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   139a0:	defffe04 	addi	sp,sp,-8
   139a4:	dfc00115 	stw	ra,4(sp)
   139a8:	df000015 	stw	fp,0(sp)
   139ac:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   139b0:	00800074 	movhi	r2,1
   139b4:	109b2704 	addi	r2,r2,27804
   139b8:	10800017 	ldw	r2,0(r2)
   139bc:	10000526 	beq	r2,zero,139d4 <alt_get_errno+0x34>
   139c0:	00800074 	movhi	r2,1
   139c4:	109b2704 	addi	r2,r2,27804
   139c8:	10800017 	ldw	r2,0(r2)
   139cc:	103ee83a 	callr	r2
   139d0:	00000206 	br	139dc <alt_get_errno+0x3c>
   139d4:	008000b4 	movhi	r2,2
   139d8:	10a0d204 	addi	r2,r2,-31928
}
   139dc:	e037883a 	mov	sp,fp
   139e0:	dfc00117 	ldw	ra,4(sp)
   139e4:	df000017 	ldw	fp,0(sp)
   139e8:	dec00204 	addi	sp,sp,8
   139ec:	f800283a 	ret

000139f0 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   139f0:	defffb04 	addi	sp,sp,-20
   139f4:	dfc00415 	stw	ra,16(sp)
   139f8:	df000315 	stw	fp,12(sp)
   139fc:	df000304 	addi	fp,sp,12
   13a00:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   13a04:	e0bfff17 	ldw	r2,-4(fp)
   13a08:	10000616 	blt	r2,zero,13a24 <close+0x34>
   13a0c:	e0bfff17 	ldw	r2,-4(fp)
   13a10:	10c00324 	muli	r3,r2,12
   13a14:	00800074 	movhi	r2,1
   13a18:	1099c004 	addi	r2,r2,26368
   13a1c:	1885883a 	add	r2,r3,r2
   13a20:	00000106 	br	13a28 <close+0x38>
   13a24:	0005883a 	mov	r2,zero
   13a28:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   13a2c:	e0bffd17 	ldw	r2,-12(fp)
   13a30:	10001826 	beq	r2,zero,13a94 <close+0xa4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   13a34:	e0bffd17 	ldw	r2,-12(fp)
   13a38:	10800017 	ldw	r2,0(r2)
   13a3c:	10800417 	ldw	r2,16(r2)
   13a40:	10000626 	beq	r2,zero,13a5c <close+0x6c>
   13a44:	e0bffd17 	ldw	r2,-12(fp)
   13a48:	10800017 	ldw	r2,0(r2)
   13a4c:	10800417 	ldw	r2,16(r2)
   13a50:	e13ffd17 	ldw	r4,-12(fp)
   13a54:	103ee83a 	callr	r2
   13a58:	00000106 	br	13a60 <close+0x70>
   13a5c:	0005883a 	mov	r2,zero
   13a60:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   13a64:	e13fff17 	ldw	r4,-4(fp)
   13a68:	00143700 	call	14370 <alt_release_fd>
    if (rval < 0)
   13a6c:	e0bffe17 	ldw	r2,-8(fp)
   13a70:	1000060e 	bge	r2,zero,13a8c <close+0x9c>
    {
      ALT_ERRNO = -rval;
   13a74:	00139a00 	call	139a0 <alt_get_errno>
   13a78:	e0fffe17 	ldw	r3,-8(fp)
   13a7c:	00c7c83a 	sub	r3,zero,r3
   13a80:	10c00015 	stw	r3,0(r2)
      return -1;
   13a84:	00bfffc4 	movi	r2,-1
   13a88:	00000606 	br	13aa4 <close+0xb4>
    }
    return 0;
   13a8c:	0005883a 	mov	r2,zero
   13a90:	00000406 	br	13aa4 <close+0xb4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   13a94:	00139a00 	call	139a0 <alt_get_errno>
   13a98:	00c01444 	movi	r3,81
   13a9c:	10c00015 	stw	r3,0(r2)
    return -1;
   13aa0:	00bfffc4 	movi	r2,-1
  }
}
   13aa4:	e037883a 	mov	sp,fp
   13aa8:	dfc00117 	ldw	ra,4(sp)
   13aac:	df000017 	ldw	fp,0(sp)
   13ab0:	dec00204 	addi	sp,sp,8
   13ab4:	f800283a 	ret

00013ab8 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   13ab8:	defffe04 	addi	sp,sp,-8
   13abc:	df000115 	stw	fp,4(sp)
   13ac0:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
   13ac4:	e03fff15 	stw	zero,-4(fp)
   13ac8:	00000506 	br	13ae0 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
   13acc:	e0bfff17 	ldw	r2,-4(fp)
   13ad0:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
   13ad4:	e0bfff17 	ldw	r2,-4(fp)
   13ad8:	10800804 	addi	r2,r2,32
   13adc:	e0bfff15 	stw	r2,-4(fp)
   13ae0:	e0bfff17 	ldw	r2,-4(fp)
   13ae4:	10820030 	cmpltui	r2,r2,2048
   13ae8:	103ff81e 	bne	r2,zero,13acc <alt_dcache_flush_all+0x14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   13aec:	e037883a 	mov	sp,fp
   13af0:	df000017 	ldw	fp,0(sp)
   13af4:	dec00104 	addi	sp,sp,4
   13af8:	f800283a 	ret

00013afc <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   13afc:	defffc04 	addi	sp,sp,-16
   13b00:	df000315 	stw	fp,12(sp)
   13b04:	df000304 	addi	fp,sp,12
   13b08:	e13ffd15 	stw	r4,-12(fp)
   13b0c:	e17ffe15 	stw	r5,-8(fp)
   13b10:	e1bfff15 	stw	r6,-4(fp)
  return len;
   13b14:	e0bfff17 	ldw	r2,-4(fp)
}
   13b18:	e037883a 	mov	sp,fp
   13b1c:	df000017 	ldw	fp,0(sp)
   13b20:	dec00104 	addi	sp,sp,4
   13b24:	f800283a 	ret

00013b28 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   13b28:	defffe04 	addi	sp,sp,-8
   13b2c:	dfc00115 	stw	ra,4(sp)
   13b30:	df000015 	stw	fp,0(sp)
   13b34:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   13b38:	00800074 	movhi	r2,1
   13b3c:	109b2704 	addi	r2,r2,27804
   13b40:	10800017 	ldw	r2,0(r2)
   13b44:	10000526 	beq	r2,zero,13b5c <alt_get_errno+0x34>
   13b48:	00800074 	movhi	r2,1
   13b4c:	109b2704 	addi	r2,r2,27804
   13b50:	10800017 	ldw	r2,0(r2)
   13b54:	103ee83a 	callr	r2
   13b58:	00000206 	br	13b64 <alt_get_errno+0x3c>
   13b5c:	008000b4 	movhi	r2,2
   13b60:	10a0d204 	addi	r2,r2,-31928
}
   13b64:	e037883a 	mov	sp,fp
   13b68:	dfc00117 	ldw	ra,4(sp)
   13b6c:	df000017 	ldw	fp,0(sp)
   13b70:	dec00204 	addi	sp,sp,8
   13b74:	f800283a 	ret

00013b78 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   13b78:	defffa04 	addi	sp,sp,-24
   13b7c:	dfc00515 	stw	ra,20(sp)
   13b80:	df000415 	stw	fp,16(sp)
   13b84:	df000404 	addi	fp,sp,16
   13b88:	e13ffe15 	stw	r4,-8(fp)
   13b8c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   13b90:	e0bffe17 	ldw	r2,-8(fp)
   13b94:	10000326 	beq	r2,zero,13ba4 <alt_dev_llist_insert+0x2c>
   13b98:	e0bffe17 	ldw	r2,-8(fp)
   13b9c:	10800217 	ldw	r2,8(r2)
   13ba0:	1000051e 	bne	r2,zero,13bb8 <alt_dev_llist_insert+0x40>
  {
    ALT_ERRNO = EINVAL;
   13ba4:	0013b280 	call	13b28 <alt_get_errno>
   13ba8:	00c00584 	movi	r3,22
   13bac:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
   13bb0:	00bffa84 	movi	r2,-22
   13bb4:	00001306 	br	13c04 <alt_dev_llist_insert+0x8c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
   13bb8:	e0bffe17 	ldw	r2,-8(fp)
   13bbc:	e0ffff17 	ldw	r3,-4(fp)
   13bc0:	e0fffc15 	stw	r3,-16(fp)
   13bc4:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   13bc8:	e0bffd17 	ldw	r2,-12(fp)
   13bcc:	e0fffc17 	ldw	r3,-16(fp)
   13bd0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   13bd4:	e0bffc17 	ldw	r2,-16(fp)
   13bd8:	10c00017 	ldw	r3,0(r2)
   13bdc:	e0bffd17 	ldw	r2,-12(fp)
   13be0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   13be4:	e0bffc17 	ldw	r2,-16(fp)
   13be8:	10800017 	ldw	r2,0(r2)
   13bec:	e0fffd17 	ldw	r3,-12(fp)
   13bf0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   13bf4:	e0bffc17 	ldw	r2,-16(fp)
   13bf8:	e0fffd17 	ldw	r3,-12(fp)
   13bfc:	10c00015 	stw	r3,0(r2)

  return 0;  
   13c00:	0005883a 	mov	r2,zero
}
   13c04:	e037883a 	mov	sp,fp
   13c08:	dfc00117 	ldw	ra,4(sp)
   13c0c:	df000017 	ldw	fp,0(sp)
   13c10:	dec00204 	addi	sp,sp,8
   13c14:	f800283a 	ret

00013c18 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
   13c18:	defffd04 	addi	sp,sp,-12
   13c1c:	dfc00215 	stw	ra,8(sp)
   13c20:	df000115 	stw	fp,4(sp)
   13c24:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
   13c28:	00800074 	movhi	r2,1
   13c2c:	10937104 	addi	r2,r2,19908
   13c30:	e0bfff15 	stw	r2,-4(fp)
   13c34:	00000606 	br	13c50 <_do_ctors+0x38>
        (*ctor) (); 
   13c38:	e0bfff17 	ldw	r2,-4(fp)
   13c3c:	10800017 	ldw	r2,0(r2)
   13c40:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
   13c44:	e0bfff17 	ldw	r2,-4(fp)
   13c48:	10bfff04 	addi	r2,r2,-4
   13c4c:	e0bfff15 	stw	r2,-4(fp)
   13c50:	e0ffff17 	ldw	r3,-4(fp)
   13c54:	00800074 	movhi	r2,1
   13c58:	10937204 	addi	r2,r2,19912
   13c5c:	18bff62e 	bgeu	r3,r2,13c38 <_do_ctors+0x20>
        (*ctor) (); 
}
   13c60:	e037883a 	mov	sp,fp
   13c64:	dfc00117 	ldw	ra,4(sp)
   13c68:	df000017 	ldw	fp,0(sp)
   13c6c:	dec00204 	addi	sp,sp,8
   13c70:	f800283a 	ret

00013c74 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
   13c74:	defffd04 	addi	sp,sp,-12
   13c78:	dfc00215 	stw	ra,8(sp)
   13c7c:	df000115 	stw	fp,4(sp)
   13c80:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
   13c84:	00800074 	movhi	r2,1
   13c88:	10937104 	addi	r2,r2,19908
   13c8c:	e0bfff15 	stw	r2,-4(fp)
   13c90:	00000606 	br	13cac <_do_dtors+0x38>
        (*dtor) (); 
   13c94:	e0bfff17 	ldw	r2,-4(fp)
   13c98:	10800017 	ldw	r2,0(r2)
   13c9c:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
   13ca0:	e0bfff17 	ldw	r2,-4(fp)
   13ca4:	10bfff04 	addi	r2,r2,-4
   13ca8:	e0bfff15 	stw	r2,-4(fp)
   13cac:	e0ffff17 	ldw	r3,-4(fp)
   13cb0:	00800074 	movhi	r2,1
   13cb4:	10937204 	addi	r2,r2,19912
   13cb8:	18bff62e 	bgeu	r3,r2,13c94 <_do_dtors+0x20>
        (*dtor) (); 
}
   13cbc:	e037883a 	mov	sp,fp
   13cc0:	dfc00117 	ldw	ra,4(sp)
   13cc4:	df000017 	ldw	fp,0(sp)
   13cc8:	dec00204 	addi	sp,sp,8
   13ccc:	f800283a 	ret

00013cd0 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   13cd0:	defffe04 	addi	sp,sp,-8
   13cd4:	dfc00115 	stw	ra,4(sp)
   13cd8:	df000015 	stw	fp,0(sp)
   13cdc:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   13ce0:	0009883a 	mov	r4,zero
   13ce4:	01440004 	movi	r5,4096
   13ce8:	00147e40 	call	147e4 <alt_icache_flush>
#endif
}
   13cec:	e037883a 	mov	sp,fp
   13cf0:	dfc00117 	ldw	ra,4(sp)
   13cf4:	df000017 	ldw	fp,0(sp)
   13cf8:	dec00204 	addi	sp,sp,8
   13cfc:	f800283a 	ret

00013d00 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   13d00:	defff904 	addi	sp,sp,-28
   13d04:	dfc00615 	stw	ra,24(sp)
   13d08:	df000515 	stw	fp,20(sp)
   13d0c:	df000504 	addi	fp,sp,20
   13d10:	e13ffc15 	stw	r4,-16(fp)
   13d14:	e17ffd15 	stw	r5,-12(fp)
   13d18:	e1bffe15 	stw	r6,-8(fp)
   13d1c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   13d20:	e0800217 	ldw	r2,8(fp)
   13d24:	d8800015 	stw	r2,0(sp)
   13d28:	e13ffc17 	ldw	r4,-16(fp)
   13d2c:	e17ffd17 	ldw	r5,-12(fp)
   13d30:	e1bffe17 	ldw	r6,-8(fp)
   13d34:	e1ffff17 	ldw	r7,-4(fp)
   13d38:	0013ed80 	call	13ed8 <alt_iic_isr_register>
}  
   13d3c:	e037883a 	mov	sp,fp
   13d40:	dfc00117 	ldw	ra,4(sp)
   13d44:	df000017 	ldw	fp,0(sp)
   13d48:	dec00204 	addi	sp,sp,8
   13d4c:	f800283a 	ret

00013d50 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
   13d50:	defff904 	addi	sp,sp,-28
   13d54:	df000615 	stw	fp,24(sp)
   13d58:	df000604 	addi	fp,sp,24
   13d5c:	e13ffe15 	stw	r4,-8(fp)
   13d60:	e17fff15 	stw	r5,-4(fp)
   13d64:	e0bfff17 	ldw	r2,-4(fp)
   13d68:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   13d6c:	0005303a 	rdctl	r2,status
   13d70:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   13d74:	e0fffb17 	ldw	r3,-20(fp)
   13d78:	00bfff84 	movi	r2,-2
   13d7c:	1884703a 	and	r2,r3,r2
   13d80:	1001703a 	wrctl	status,r2
  
  return context;
   13d84:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   13d88:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
   13d8c:	e0bffa17 	ldw	r2,-24(fp)
   13d90:	00c00044 	movi	r3,1
   13d94:	1884983a 	sll	r2,r3,r2
   13d98:	1007883a 	mov	r3,r2
   13d9c:	008000b4 	movhi	r2,2
   13da0:	10a0cf04 	addi	r2,r2,-31940
   13da4:	10800017 	ldw	r2,0(r2)
   13da8:	1886b03a 	or	r3,r3,r2
   13dac:	008000b4 	movhi	r2,2
   13db0:	10a0cf04 	addi	r2,r2,-31940
   13db4:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   13db8:	008000b4 	movhi	r2,2
   13dbc:	10a0cf04 	addi	r2,r2,-31940
   13dc0:	10800017 	ldw	r2,0(r2)
   13dc4:	100170fa 	wrctl	ienable,r2
   13dc8:	e0bffc17 	ldw	r2,-16(fp)
   13dcc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   13dd0:	e0bffd17 	ldw	r2,-12(fp)
   13dd4:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   13dd8:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
   13ddc:	e037883a 	mov	sp,fp
   13de0:	df000017 	ldw	fp,0(sp)
   13de4:	dec00104 	addi	sp,sp,4
   13de8:	f800283a 	ret

00013dec <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
   13dec:	defff904 	addi	sp,sp,-28
   13df0:	df000615 	stw	fp,24(sp)
   13df4:	df000604 	addi	fp,sp,24
   13df8:	e13ffe15 	stw	r4,-8(fp)
   13dfc:	e17fff15 	stw	r5,-4(fp)
   13e00:	e0bfff17 	ldw	r2,-4(fp)
   13e04:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   13e08:	0005303a 	rdctl	r2,status
   13e0c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   13e10:	e0fffb17 	ldw	r3,-20(fp)
   13e14:	00bfff84 	movi	r2,-2
   13e18:	1884703a 	and	r2,r3,r2
   13e1c:	1001703a 	wrctl	status,r2
  
  return context;
   13e20:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
   13e24:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
   13e28:	e0bffa17 	ldw	r2,-24(fp)
   13e2c:	00c00044 	movi	r3,1
   13e30:	1884983a 	sll	r2,r3,r2
   13e34:	0084303a 	nor	r2,zero,r2
   13e38:	1007883a 	mov	r3,r2
   13e3c:	008000b4 	movhi	r2,2
   13e40:	10a0cf04 	addi	r2,r2,-31940
   13e44:	10800017 	ldw	r2,0(r2)
   13e48:	1886703a 	and	r3,r3,r2
   13e4c:	008000b4 	movhi	r2,2
   13e50:	10a0cf04 	addi	r2,r2,-31940
   13e54:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   13e58:	008000b4 	movhi	r2,2
   13e5c:	10a0cf04 	addi	r2,r2,-31940
   13e60:	10800017 	ldw	r2,0(r2)
   13e64:	100170fa 	wrctl	ienable,r2
   13e68:	e0bffc17 	ldw	r2,-16(fp)
   13e6c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   13e70:	e0bffd17 	ldw	r2,-12(fp)
   13e74:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
   13e78:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
   13e7c:	e037883a 	mov	sp,fp
   13e80:	df000017 	ldw	fp,0(sp)
   13e84:	dec00104 	addi	sp,sp,4
   13e88:	f800283a 	ret

00013e8c <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
   13e8c:	defffc04 	addi	sp,sp,-16
   13e90:	df000315 	stw	fp,12(sp)
   13e94:	df000304 	addi	fp,sp,12
   13e98:	e13ffe15 	stw	r4,-8(fp)
   13e9c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   13ea0:	000530fa 	rdctl	r2,ienable
   13ea4:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
   13ea8:	e0bfff17 	ldw	r2,-4(fp)
   13eac:	00c00044 	movi	r3,1
   13eb0:	1884983a 	sll	r2,r3,r2
   13eb4:	1007883a 	mov	r3,r2
   13eb8:	e0bffd17 	ldw	r2,-12(fp)
   13ebc:	1884703a 	and	r2,r3,r2
   13ec0:	1004c03a 	cmpne	r2,r2,zero
   13ec4:	10803fcc 	andi	r2,r2,255
}
   13ec8:	e037883a 	mov	sp,fp
   13ecc:	df000017 	ldw	fp,0(sp)
   13ed0:	dec00104 	addi	sp,sp,4
   13ed4:	f800283a 	ret

00013ed8 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   13ed8:	defff504 	addi	sp,sp,-44
   13edc:	dfc00a15 	stw	ra,40(sp)
   13ee0:	df000915 	stw	fp,36(sp)
   13ee4:	df000904 	addi	fp,sp,36
   13ee8:	e13ffc15 	stw	r4,-16(fp)
   13eec:	e17ffd15 	stw	r5,-12(fp)
   13ef0:	e1bffe15 	stw	r6,-8(fp)
   13ef4:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
   13ef8:	00bffa84 	movi	r2,-22
   13efc:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
   13f00:	e0bffd17 	ldw	r2,-12(fp)
   13f04:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
   13f08:	e0bff817 	ldw	r2,-32(fp)
   13f0c:	10800808 	cmpgei	r2,r2,32
   13f10:	1000271e 	bne	r2,zero,13fb0 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   13f14:	0005303a 	rdctl	r2,status
   13f18:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   13f1c:	e0fffa17 	ldw	r3,-24(fp)
   13f20:	00bfff84 	movi	r2,-2
   13f24:	1884703a 	and	r2,r3,r2
   13f28:	1001703a 	wrctl	status,r2
  
  return context;
   13f2c:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
   13f30:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
   13f34:	00c000b4 	movhi	r3,2
   13f38:	18e21004 	addi	r3,r3,-30656
   13f3c:	e0bff817 	ldw	r2,-32(fp)
   13f40:	100490fa 	slli	r2,r2,3
   13f44:	1885883a 	add	r2,r3,r2
   13f48:	e0fffe17 	ldw	r3,-8(fp)
   13f4c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
   13f50:	00c000b4 	movhi	r3,2
   13f54:	18e21004 	addi	r3,r3,-30656
   13f58:	e0bff817 	ldw	r2,-32(fp)
   13f5c:	100490fa 	slli	r2,r2,3
   13f60:	1885883a 	add	r2,r3,r2
   13f64:	10800104 	addi	r2,r2,4
   13f68:	e0ffff17 	ldw	r3,-4(fp)
   13f6c:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   13f70:	e0bffe17 	ldw	r2,-8(fp)
   13f74:	10000526 	beq	r2,zero,13f8c <alt_iic_isr_register+0xb4>
   13f78:	e0bff817 	ldw	r2,-32(fp)
   13f7c:	e13ffc17 	ldw	r4,-16(fp)
   13f80:	100b883a 	mov	r5,r2
   13f84:	0013d500 	call	13d50 <alt_ic_irq_enable>
   13f88:	00000406 	br	13f9c <alt_iic_isr_register+0xc4>
   13f8c:	e0bff817 	ldw	r2,-32(fp)
   13f90:	e13ffc17 	ldw	r4,-16(fp)
   13f94:	100b883a 	mov	r5,r2
   13f98:	0013dec0 	call	13dec <alt_ic_irq_disable>
   13f9c:	e0bff715 	stw	r2,-36(fp)
   13fa0:	e0bff917 	ldw	r2,-28(fp)
   13fa4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   13fa8:	e0bffb17 	ldw	r2,-20(fp)
   13fac:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
   13fb0:	e0bff717 	ldw	r2,-36(fp)
}
   13fb4:	e037883a 	mov	sp,fp
   13fb8:	dfc00117 	ldw	ra,4(sp)
   13fbc:	df000017 	ldw	fp,0(sp)
   13fc0:	dec00204 	addi	sp,sp,8
   13fc4:	f800283a 	ret

00013fc8 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   13fc8:	defff904 	addi	sp,sp,-28
   13fcc:	dfc00615 	stw	ra,24(sp)
   13fd0:	df000515 	stw	fp,20(sp)
   13fd4:	df000504 	addi	fp,sp,20
   13fd8:	e13ffc15 	stw	r4,-16(fp)
   13fdc:	e17ffd15 	stw	r5,-12(fp)
   13fe0:	e1bffe15 	stw	r6,-8(fp)
   13fe4:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
   13fe8:	e13ffd17 	ldw	r4,-12(fp)
   13fec:	e17ffe17 	ldw	r5,-8(fp)
   13ff0:	e1bfff17 	ldw	r6,-4(fp)
   13ff4:	001421c0 	call	1421c <open>
   13ff8:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
   13ffc:	e0bffb17 	ldw	r2,-20(fp)
   14000:	10001c16 	blt	r2,zero,14074 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
   14004:	00c00074 	movhi	r3,1
   14008:	18d9c004 	addi	r3,r3,26368
   1400c:	e0bffb17 	ldw	r2,-20(fp)
   14010:	10800324 	muli	r2,r2,12
   14014:	1885883a 	add	r2,r3,r2
   14018:	10c00017 	ldw	r3,0(r2)
   1401c:	e0bffc17 	ldw	r2,-16(fp)
   14020:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   14024:	00c00074 	movhi	r3,1
   14028:	18d9c004 	addi	r3,r3,26368
   1402c:	e0bffb17 	ldw	r2,-20(fp)
   14030:	10800324 	muli	r2,r2,12
   14034:	1885883a 	add	r2,r3,r2
   14038:	10800104 	addi	r2,r2,4
   1403c:	10c00017 	ldw	r3,0(r2)
   14040:	e0bffc17 	ldw	r2,-16(fp)
   14044:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   14048:	00c00074 	movhi	r3,1
   1404c:	18d9c004 	addi	r3,r3,26368
   14050:	e0bffb17 	ldw	r2,-20(fp)
   14054:	10800324 	muli	r2,r2,12
   14058:	1885883a 	add	r2,r3,r2
   1405c:	10800204 	addi	r2,r2,8
   14060:	10c00017 	ldw	r3,0(r2)
   14064:	e0bffc17 	ldw	r2,-16(fp)
   14068:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   1406c:	e13ffb17 	ldw	r4,-20(fp)
   14070:	00143700 	call	14370 <alt_release_fd>
  }
} 
   14074:	e037883a 	mov	sp,fp
   14078:	dfc00117 	ldw	ra,4(sp)
   1407c:	df000017 	ldw	fp,0(sp)
   14080:	dec00204 	addi	sp,sp,8
   14084:	f800283a 	ret

00014088 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   14088:	defffb04 	addi	sp,sp,-20
   1408c:	dfc00415 	stw	ra,16(sp)
   14090:	df000315 	stw	fp,12(sp)
   14094:	df000304 	addi	fp,sp,12
   14098:	e13ffd15 	stw	r4,-12(fp)
   1409c:	e17ffe15 	stw	r5,-8(fp)
   140a0:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   140a4:	01000074 	movhi	r4,1
   140a8:	2119c304 	addi	r4,r4,26380
   140ac:	e17ffd17 	ldw	r5,-12(fp)
   140b0:	01800044 	movi	r6,1
   140b4:	01c07fc4 	movi	r7,511
   140b8:	0013fc80 	call	13fc8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   140bc:	01000074 	movhi	r4,1
   140c0:	2119c004 	addi	r4,r4,26368
   140c4:	e17ffe17 	ldw	r5,-8(fp)
   140c8:	000d883a 	mov	r6,zero
   140cc:	01c07fc4 	movi	r7,511
   140d0:	0013fc80 	call	13fc8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   140d4:	01000074 	movhi	r4,1
   140d8:	2119c604 	addi	r4,r4,26392
   140dc:	e17fff17 	ldw	r5,-4(fp)
   140e0:	01800044 	movi	r6,1
   140e4:	01c07fc4 	movi	r7,511
   140e8:	0013fc80 	call	13fc8 <alt_open_fd>
}  
   140ec:	e037883a 	mov	sp,fp
   140f0:	dfc00117 	ldw	ra,4(sp)
   140f4:	df000017 	ldw	fp,0(sp)
   140f8:	dec00204 	addi	sp,sp,8
   140fc:	f800283a 	ret

00014100 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   14100:	defffe04 	addi	sp,sp,-8
   14104:	dfc00115 	stw	ra,4(sp)
   14108:	df000015 	stw	fp,0(sp)
   1410c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   14110:	00800074 	movhi	r2,1
   14114:	109b2704 	addi	r2,r2,27804
   14118:	10800017 	ldw	r2,0(r2)
   1411c:	10000526 	beq	r2,zero,14134 <alt_get_errno+0x34>
   14120:	00800074 	movhi	r2,1
   14124:	109b2704 	addi	r2,r2,27804
   14128:	10800017 	ldw	r2,0(r2)
   1412c:	103ee83a 	callr	r2
   14130:	00000206 	br	1413c <alt_get_errno+0x3c>
   14134:	008000b4 	movhi	r2,2
   14138:	10a0d204 	addi	r2,r2,-31928
}
   1413c:	e037883a 	mov	sp,fp
   14140:	dfc00117 	ldw	ra,4(sp)
   14144:	df000017 	ldw	fp,0(sp)
   14148:	dec00204 	addi	sp,sp,8
   1414c:	f800283a 	ret

00014150 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   14150:	defffd04 	addi	sp,sp,-12
   14154:	df000215 	stw	fp,8(sp)
   14158:	df000204 	addi	fp,sp,8
   1415c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   14160:	e0bfff17 	ldw	r2,-4(fp)
   14164:	10800217 	ldw	r2,8(r2)
   14168:	10d00034 	orhi	r3,r2,16384
   1416c:	e0bfff17 	ldw	r2,-4(fp)
   14170:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   14174:	e03ffe15 	stw	zero,-8(fp)
   14178:	00001d06 	br	141f0 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   1417c:	00c00074 	movhi	r3,1
   14180:	18d9c004 	addi	r3,r3,26368
   14184:	e0bffe17 	ldw	r2,-8(fp)
   14188:	10800324 	muli	r2,r2,12
   1418c:	1885883a 	add	r2,r3,r2
   14190:	10c00017 	ldw	r3,0(r2)
   14194:	e0bfff17 	ldw	r2,-4(fp)
   14198:	10800017 	ldw	r2,0(r2)
   1419c:	1880111e 	bne	r3,r2,141e4 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   141a0:	00c00074 	movhi	r3,1
   141a4:	18d9c004 	addi	r3,r3,26368
   141a8:	e0bffe17 	ldw	r2,-8(fp)
   141ac:	10800324 	muli	r2,r2,12
   141b0:	1885883a 	add	r2,r3,r2
   141b4:	10800204 	addi	r2,r2,8
   141b8:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   141bc:	1000090e 	bge	r2,zero,141e4 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   141c0:	e0bffe17 	ldw	r2,-8(fp)
   141c4:	10c00324 	muli	r3,r2,12
   141c8:	00800074 	movhi	r2,1
   141cc:	1099c004 	addi	r2,r2,26368
   141d0:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   141d4:	e0bfff17 	ldw	r2,-4(fp)
   141d8:	18800226 	beq	r3,r2,141e4 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   141dc:	00bffcc4 	movi	r2,-13
   141e0:	00000a06 	br	1420c <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   141e4:	e0bffe17 	ldw	r2,-8(fp)
   141e8:	10800044 	addi	r2,r2,1
   141ec:	e0bffe15 	stw	r2,-8(fp)
   141f0:	00800074 	movhi	r2,1
   141f4:	109b2604 	addi	r2,r2,27800
   141f8:	10800017 	ldw	r2,0(r2)
   141fc:	1007883a 	mov	r3,r2
   14200:	e0bffe17 	ldw	r2,-8(fp)
   14204:	18bfdd2e 	bgeu	r3,r2,1417c <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   14208:	0005883a 	mov	r2,zero
}
   1420c:	e037883a 	mov	sp,fp
   14210:	df000017 	ldw	fp,0(sp)
   14214:	dec00104 	addi	sp,sp,4
   14218:	f800283a 	ret

0001421c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   1421c:	defff604 	addi	sp,sp,-40
   14220:	dfc00915 	stw	ra,36(sp)
   14224:	df000815 	stw	fp,32(sp)
   14228:	df000804 	addi	fp,sp,32
   1422c:	e13ffd15 	stw	r4,-12(fp)
   14230:	e17ffe15 	stw	r5,-8(fp)
   14234:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   14238:	00bfffc4 	movi	r2,-1
   1423c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   14240:	00bffb44 	movi	r2,-19
   14244:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   14248:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   1424c:	e13ffd17 	ldw	r4,-12(fp)
   14250:	01400074 	movhi	r5,1
   14254:	295b2404 	addi	r5,r5,27792
   14258:	001458c0 	call	1458c <alt_find_dev>
   1425c:	e0bff815 	stw	r2,-32(fp)
   14260:	e0bff817 	ldw	r2,-32(fp)
   14264:	1000051e 	bne	r2,zero,1427c <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   14268:	e13ffd17 	ldw	r4,-12(fp)
   1426c:	001461c0 	call	1461c <alt_find_file>
   14270:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   14274:	00800044 	movi	r2,1
   14278:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   1427c:	e0bff817 	ldw	r2,-32(fp)
   14280:	10002926 	beq	r2,zero,14328 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
   14284:	e13ff817 	ldw	r4,-32(fp)
   14288:	00147300 	call	14730 <alt_get_fd>
   1428c:	e0bff915 	stw	r2,-28(fp)
   14290:	e0bff917 	ldw	r2,-28(fp)
   14294:	1000030e 	bge	r2,zero,142a4 <open+0x88>
    {
      status = index;
   14298:	e0bff917 	ldw	r2,-28(fp)
   1429c:	e0bffa15 	stw	r2,-24(fp)
   142a0:	00002306 	br	14330 <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
   142a4:	e0bff917 	ldw	r2,-28(fp)
   142a8:	10c00324 	muli	r3,r2,12
   142ac:	00800074 	movhi	r2,1
   142b0:	1099c004 	addi	r2,r2,26368
   142b4:	1885883a 	add	r2,r3,r2
   142b8:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   142bc:	e0fffe17 	ldw	r3,-8(fp)
   142c0:	00900034 	movhi	r2,16384
   142c4:	10bfffc4 	addi	r2,r2,-1
   142c8:	1886703a 	and	r3,r3,r2
   142cc:	e0bffc17 	ldw	r2,-16(fp)
   142d0:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   142d4:	e0bffb17 	ldw	r2,-20(fp)
   142d8:	1000051e 	bne	r2,zero,142f0 <open+0xd4>
   142dc:	e13ffc17 	ldw	r4,-16(fp)
   142e0:	00141500 	call	14150 <alt_file_locked>
   142e4:	e0bffa15 	stw	r2,-24(fp)
   142e8:	e0bffa17 	ldw	r2,-24(fp)
   142ec:	10001016 	blt	r2,zero,14330 <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   142f0:	e0bff817 	ldw	r2,-32(fp)
   142f4:	10800317 	ldw	r2,12(r2)
   142f8:	10000826 	beq	r2,zero,1431c <open+0x100>
   142fc:	e0bff817 	ldw	r2,-32(fp)
   14300:	10800317 	ldw	r2,12(r2)
   14304:	e13ffc17 	ldw	r4,-16(fp)
   14308:	e17ffd17 	ldw	r5,-12(fp)
   1430c:	e1bffe17 	ldw	r6,-8(fp)
   14310:	e1ffff17 	ldw	r7,-4(fp)
   14314:	103ee83a 	callr	r2
   14318:	00000106 	br	14320 <open+0x104>
   1431c:	0005883a 	mov	r2,zero
   14320:	e0bffa15 	stw	r2,-24(fp)
   14324:	00000206 	br	14330 <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
   14328:	00bffb44 	movi	r2,-19
   1432c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   14330:	e0bffa17 	ldw	r2,-24(fp)
   14334:	1000080e 	bge	r2,zero,14358 <open+0x13c>
  {
    alt_release_fd (index);  
   14338:	e13ff917 	ldw	r4,-28(fp)
   1433c:	00143700 	call	14370 <alt_release_fd>
    ALT_ERRNO = -status;
   14340:	00141000 	call	14100 <alt_get_errno>
   14344:	e0fffa17 	ldw	r3,-24(fp)
   14348:	00c7c83a 	sub	r3,zero,r3
   1434c:	10c00015 	stw	r3,0(r2)
    return -1;
   14350:	00bfffc4 	movi	r2,-1
   14354:	00000106 	br	1435c <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
   14358:	e0bff917 	ldw	r2,-28(fp)
}
   1435c:	e037883a 	mov	sp,fp
   14360:	dfc00117 	ldw	ra,4(sp)
   14364:	df000017 	ldw	fp,0(sp)
   14368:	dec00204 	addi	sp,sp,8
   1436c:	f800283a 	ret

00014370 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   14370:	defffe04 	addi	sp,sp,-8
   14374:	df000115 	stw	fp,4(sp)
   14378:	df000104 	addi	fp,sp,4
   1437c:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   14380:	e0bfff17 	ldw	r2,-4(fp)
   14384:	108000d0 	cmplti	r2,r2,3
   14388:	10000d1e 	bne	r2,zero,143c0 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   1438c:	00c00074 	movhi	r3,1
   14390:	18d9c004 	addi	r3,r3,26368
   14394:	e0bfff17 	ldw	r2,-4(fp)
   14398:	10800324 	muli	r2,r2,12
   1439c:	1885883a 	add	r2,r3,r2
   143a0:	10800204 	addi	r2,r2,8
   143a4:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   143a8:	00c00074 	movhi	r3,1
   143ac:	18d9c004 	addi	r3,r3,26368
   143b0:	e0bfff17 	ldw	r2,-4(fp)
   143b4:	10800324 	muli	r2,r2,12
   143b8:	1885883a 	add	r2,r3,r2
   143bc:	10000015 	stw	zero,0(r2)
  }
}
   143c0:	e037883a 	mov	sp,fp
   143c4:	df000017 	ldw	fp,0(sp)
   143c8:	dec00104 	addi	sp,sp,4
   143cc:	f800283a 	ret

000143d0 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
   143d0:	defffa04 	addi	sp,sp,-24
   143d4:	df000515 	stw	fp,20(sp)
   143d8:	df000504 	addi	fp,sp,20
   143dc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   143e0:	0005303a 	rdctl	r2,status
   143e4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   143e8:	e0fffc17 	ldw	r3,-16(fp)
   143ec:	00bfff84 	movi	r2,-2
   143f0:	1884703a 	and	r2,r3,r2
   143f4:	1001703a 	wrctl	status,r2
  
  return context;
   143f8:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
   143fc:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
   14400:	e0bfff17 	ldw	r2,-4(fp)
   14404:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   14408:	e0bffd17 	ldw	r2,-12(fp)
   1440c:	10800017 	ldw	r2,0(r2)
   14410:	e0fffd17 	ldw	r3,-12(fp)
   14414:	18c00117 	ldw	r3,4(r3)
   14418:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
   1441c:	e0bffd17 	ldw	r2,-12(fp)
   14420:	10800117 	ldw	r2,4(r2)
   14424:	e0fffd17 	ldw	r3,-12(fp)
   14428:	18c00017 	ldw	r3,0(r3)
   1442c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   14430:	e0bffd17 	ldw	r2,-12(fp)
   14434:	e0fffd17 	ldw	r3,-12(fp)
   14438:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
   1443c:	e0bffd17 	ldw	r2,-12(fp)
   14440:	e0fffd17 	ldw	r3,-12(fp)
   14444:	10c00015 	stw	r3,0(r2)
   14448:	e0bffb17 	ldw	r2,-20(fp)
   1444c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   14450:	e0bffe17 	ldw	r2,-8(fp)
   14454:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
   14458:	e037883a 	mov	sp,fp
   1445c:	df000017 	ldw	fp,0(sp)
   14460:	dec00104 	addi	sp,sp,4
   14464:	f800283a 	ret

00014468 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   14468:	defffb04 	addi	sp,sp,-20
   1446c:	dfc00415 	stw	ra,16(sp)
   14470:	df000315 	stw	fp,12(sp)
   14474:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   14478:	d0a00917 	ldw	r2,-32732(gp)
   1447c:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   14480:	d0a5b117 	ldw	r2,-26940(gp)
   14484:	10800044 	addi	r2,r2,1
   14488:	d0a5b115 	stw	r2,-26940(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   1448c:	00002e06 	br	14548 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
   14490:	e0bffd17 	ldw	r2,-12(fp)
   14494:	10800017 	ldw	r2,0(r2)
   14498:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
   1449c:	e0bffd17 	ldw	r2,-12(fp)
   144a0:	10800403 	ldbu	r2,16(r2)
   144a4:	10803fcc 	andi	r2,r2,255
   144a8:	10000426 	beq	r2,zero,144bc <alt_tick+0x54>
   144ac:	d0a5b117 	ldw	r2,-26940(gp)
   144b0:	1000021e 	bne	r2,zero,144bc <alt_tick+0x54>
    {
      alarm->rollover = 0;
   144b4:	e0bffd17 	ldw	r2,-12(fp)
   144b8:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
   144bc:	e0bffd17 	ldw	r2,-12(fp)
   144c0:	10800217 	ldw	r2,8(r2)
   144c4:	d0e5b117 	ldw	r3,-26940(gp)
   144c8:	18801d36 	bltu	r3,r2,14540 <alt_tick+0xd8>
   144cc:	e0bffd17 	ldw	r2,-12(fp)
   144d0:	10800403 	ldbu	r2,16(r2)
   144d4:	10803fcc 	andi	r2,r2,255
   144d8:	1000191e 	bne	r2,zero,14540 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
   144dc:	e0bffd17 	ldw	r2,-12(fp)
   144e0:	10c00317 	ldw	r3,12(r2)
   144e4:	e0bffd17 	ldw	r2,-12(fp)
   144e8:	10800517 	ldw	r2,20(r2)
   144ec:	1009883a 	mov	r4,r2
   144f0:	183ee83a 	callr	r3
   144f4:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   144f8:	e0bfff17 	ldw	r2,-4(fp)
   144fc:	1000031e 	bne	r2,zero,1450c <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
   14500:	e13ffd17 	ldw	r4,-12(fp)
   14504:	00143d00 	call	143d0 <alt_alarm_stop>
   14508:	00000d06 	br	14540 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
   1450c:	e0bffd17 	ldw	r2,-12(fp)
   14510:	10c00217 	ldw	r3,8(r2)
   14514:	e0bfff17 	ldw	r2,-4(fp)
   14518:	1887883a 	add	r3,r3,r2
   1451c:	e0bffd17 	ldw	r2,-12(fp)
   14520:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
   14524:	e0bffd17 	ldw	r2,-12(fp)
   14528:	10c00217 	ldw	r3,8(r2)
   1452c:	d0a5b117 	ldw	r2,-26940(gp)
   14530:	1880032e 	bgeu	r3,r2,14540 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
   14534:	e0bffd17 	ldw	r2,-12(fp)
   14538:	00c00044 	movi	r3,1
   1453c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
   14540:	e0bffe17 	ldw	r2,-8(fp)
   14544:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   14548:	e0fffd17 	ldw	r3,-12(fp)
   1454c:	d0a00904 	addi	r2,gp,-32732
   14550:	18bfcf1e 	bne	r3,r2,14490 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
   14554:	0001883a 	nop
}
   14558:	e037883a 	mov	sp,fp
   1455c:	dfc00117 	ldw	ra,4(sp)
   14560:	df000017 	ldw	fp,0(sp)
   14564:	dec00204 	addi	sp,sp,8
   14568:	f800283a 	ret

0001456c <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
   1456c:	deffff04 	addi	sp,sp,-4
   14570:	df000015 	stw	fp,0(sp)
   14574:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
   14578:	000170fa 	wrctl	ienable,zero
}
   1457c:	e037883a 	mov	sp,fp
   14580:	df000017 	ldw	fp,0(sp)
   14584:	dec00104 	addi	sp,sp,4
   14588:	f800283a 	ret

0001458c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   1458c:	defffa04 	addi	sp,sp,-24
   14590:	dfc00515 	stw	ra,20(sp)
   14594:	df000415 	stw	fp,16(sp)
   14598:	df000404 	addi	fp,sp,16
   1459c:	e13ffe15 	stw	r4,-8(fp)
   145a0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   145a4:	e0bfff17 	ldw	r2,-4(fp)
   145a8:	10800017 	ldw	r2,0(r2)
   145ac:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   145b0:	e13ffe17 	ldw	r4,-8(fp)
   145b4:	0014a300 	call	14a30 <strlen>
   145b8:	10800044 	addi	r2,r2,1
   145bc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   145c0:	00000d06 	br	145f8 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   145c4:	e0bffc17 	ldw	r2,-16(fp)
   145c8:	10c00217 	ldw	r3,8(r2)
   145cc:	e0bffd17 	ldw	r2,-12(fp)
   145d0:	1809883a 	mov	r4,r3
   145d4:	e17ffe17 	ldw	r5,-8(fp)
   145d8:	100d883a 	mov	r6,r2
   145dc:	00148bc0 	call	148bc <memcmp>
   145e0:	1000021e 	bne	r2,zero,145ec <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   145e4:	e0bffc17 	ldw	r2,-16(fp)
   145e8:	00000706 	br	14608 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   145ec:	e0bffc17 	ldw	r2,-16(fp)
   145f0:	10800017 	ldw	r2,0(r2)
   145f4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   145f8:	e0fffc17 	ldw	r3,-16(fp)
   145fc:	e0bfff17 	ldw	r2,-4(fp)
   14600:	18bff01e 	bne	r3,r2,145c4 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   14604:	0005883a 	mov	r2,zero
}
   14608:	e037883a 	mov	sp,fp
   1460c:	dfc00117 	ldw	ra,4(sp)
   14610:	df000017 	ldw	fp,0(sp)
   14614:	dec00204 	addi	sp,sp,8
   14618:	f800283a 	ret

0001461c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   1461c:	defffb04 	addi	sp,sp,-20
   14620:	dfc00415 	stw	ra,16(sp)
   14624:	df000315 	stw	fp,12(sp)
   14628:	df000304 	addi	fp,sp,12
   1462c:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   14630:	00800074 	movhi	r2,1
   14634:	109b2204 	addi	r2,r2,27784
   14638:	10800017 	ldw	r2,0(r2)
   1463c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   14640:	00003106 	br	14708 <alt_find_file+0xec>
  {
    len = strlen(next->name);
   14644:	e0bffd17 	ldw	r2,-12(fp)
   14648:	10800217 	ldw	r2,8(r2)
   1464c:	1009883a 	mov	r4,r2
   14650:	0014a300 	call	14a30 <strlen>
   14654:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   14658:	e0bffd17 	ldw	r2,-12(fp)
   1465c:	10c00217 	ldw	r3,8(r2)
   14660:	e0bffe17 	ldw	r2,-8(fp)
   14664:	10bfffc4 	addi	r2,r2,-1
   14668:	1885883a 	add	r2,r3,r2
   1466c:	10800003 	ldbu	r2,0(r2)
   14670:	10803fcc 	andi	r2,r2,255
   14674:	1080201c 	xori	r2,r2,128
   14678:	10bfe004 	addi	r2,r2,-128
   1467c:	10800bd8 	cmpnei	r2,r2,47
   14680:	1000031e 	bne	r2,zero,14690 <alt_find_file+0x74>
    {
      len -= 1;
   14684:	e0bffe17 	ldw	r2,-8(fp)
   14688:	10bfffc4 	addi	r2,r2,-1
   1468c:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   14690:	e0bffe17 	ldw	r2,-8(fp)
   14694:	e0ffff17 	ldw	r3,-4(fp)
   14698:	1885883a 	add	r2,r3,r2
   1469c:	10800003 	ldbu	r2,0(r2)
   146a0:	10803fcc 	andi	r2,r2,255
   146a4:	1080201c 	xori	r2,r2,128
   146a8:	10bfe004 	addi	r2,r2,-128
   146ac:	10800be0 	cmpeqi	r2,r2,47
   146b0:	1000081e 	bne	r2,zero,146d4 <alt_find_file+0xb8>
   146b4:	e0bffe17 	ldw	r2,-8(fp)
   146b8:	e0ffff17 	ldw	r3,-4(fp)
   146bc:	1885883a 	add	r2,r3,r2
   146c0:	10800003 	ldbu	r2,0(r2)
   146c4:	10803fcc 	andi	r2,r2,255
   146c8:	1080201c 	xori	r2,r2,128
   146cc:	10bfe004 	addi	r2,r2,-128
   146d0:	10000a1e 	bne	r2,zero,146fc <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
   146d4:	e0bffd17 	ldw	r2,-12(fp)
   146d8:	10c00217 	ldw	r3,8(r2)
   146dc:	e0bffe17 	ldw	r2,-8(fp)
   146e0:	1809883a 	mov	r4,r3
   146e4:	e17fff17 	ldw	r5,-4(fp)
   146e8:	100d883a 	mov	r6,r2
   146ec:	00148bc0 	call	148bc <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   146f0:	1000021e 	bne	r2,zero,146fc <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   146f4:	e0bffd17 	ldw	r2,-12(fp)
   146f8:	00000806 	br	1471c <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
   146fc:	e0bffd17 	ldw	r2,-12(fp)
   14700:	10800017 	ldw	r2,0(r2)
   14704:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   14708:	e0fffd17 	ldw	r3,-12(fp)
   1470c:	00800074 	movhi	r2,1
   14710:	109b2204 	addi	r2,r2,27784
   14714:	18bfcb1e 	bne	r3,r2,14644 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   14718:	0005883a 	mov	r2,zero
}
   1471c:	e037883a 	mov	sp,fp
   14720:	dfc00117 	ldw	ra,4(sp)
   14724:	df000017 	ldw	fp,0(sp)
   14728:	dec00204 	addi	sp,sp,8
   1472c:	f800283a 	ret

00014730 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   14730:	defffc04 	addi	sp,sp,-16
   14734:	df000315 	stw	fp,12(sp)
   14738:	df000304 	addi	fp,sp,12
   1473c:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
   14740:	00bffa04 	movi	r2,-24
   14744:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   14748:	e03ffd15 	stw	zero,-12(fp)
   1474c:	00001d06 	br	147c4 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
   14750:	00c00074 	movhi	r3,1
   14754:	18d9c004 	addi	r3,r3,26368
   14758:	e0bffd17 	ldw	r2,-12(fp)
   1475c:	10800324 	muli	r2,r2,12
   14760:	1885883a 	add	r2,r3,r2
   14764:	10800017 	ldw	r2,0(r2)
   14768:	1000131e 	bne	r2,zero,147b8 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
   1476c:	00c00074 	movhi	r3,1
   14770:	18d9c004 	addi	r3,r3,26368
   14774:	e0bffd17 	ldw	r2,-12(fp)
   14778:	10800324 	muli	r2,r2,12
   1477c:	1885883a 	add	r2,r3,r2
   14780:	e0ffff17 	ldw	r3,-4(fp)
   14784:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   14788:	00800074 	movhi	r2,1
   1478c:	109b2604 	addi	r2,r2,27800
   14790:	10c00017 	ldw	r3,0(r2)
   14794:	e0bffd17 	ldw	r2,-12(fp)
   14798:	1880040e 	bge	r3,r2,147ac <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
   1479c:	00800074 	movhi	r2,1
   147a0:	109b2604 	addi	r2,r2,27800
   147a4:	e0fffd17 	ldw	r3,-12(fp)
   147a8:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
   147ac:	e0bffd17 	ldw	r2,-12(fp)
   147b0:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
   147b4:	00000606 	br	147d0 <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   147b8:	e0bffd17 	ldw	r2,-12(fp)
   147bc:	10800044 	addi	r2,r2,1
   147c0:	e0bffd15 	stw	r2,-12(fp)
   147c4:	e0bffd17 	ldw	r2,-12(fp)
   147c8:	10800810 	cmplti	r2,r2,32
   147cc:	103fe01e 	bne	r2,zero,14750 <alt_get_fd+0x20>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   147d0:	e0bffe17 	ldw	r2,-8(fp)
}
   147d4:	e037883a 	mov	sp,fp
   147d8:	df000017 	ldw	fp,0(sp)
   147dc:	dec00104 	addi	sp,sp,4
   147e0:	f800283a 	ret

000147e4 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
   147e4:	defffb04 	addi	sp,sp,-20
   147e8:	df000415 	stw	fp,16(sp)
   147ec:	df000404 	addi	fp,sp,16
   147f0:	e13ffe15 	stw	r4,-8(fp)
   147f4:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   147f8:	e0bfff17 	ldw	r2,-4(fp)
   147fc:	10840070 	cmpltui	r2,r2,4097
   14800:	1000021e 	bne	r2,zero,1480c <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
   14804:	00840004 	movi	r2,4096
   14808:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
   1480c:	e0fffe17 	ldw	r3,-8(fp)
   14810:	e0bfff17 	ldw	r2,-4(fp)
   14814:	1885883a 	add	r2,r3,r2
   14818:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   1481c:	e0bffe17 	ldw	r2,-8(fp)
   14820:	e0bffc15 	stw	r2,-16(fp)
   14824:	00000506 	br	1483c <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   14828:	e0bffc17 	ldw	r2,-16(fp)
   1482c:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   14830:	e0bffc17 	ldw	r2,-16(fp)
   14834:	10800804 	addi	r2,r2,32
   14838:	e0bffc15 	stw	r2,-16(fp)
   1483c:	e0fffc17 	ldw	r3,-16(fp)
   14840:	e0bffd17 	ldw	r2,-12(fp)
   14844:	18bff836 	bltu	r3,r2,14828 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   14848:	e0bffe17 	ldw	r2,-8(fp)
   1484c:	108007cc 	andi	r2,r2,31
   14850:	10000226 	beq	r2,zero,1485c <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   14854:	e0bffc17 	ldw	r2,-16(fp)
   14858:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   1485c:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   14860:	e037883a 	mov	sp,fp
   14864:	df000017 	ldw	fp,0(sp)
   14868:	dec00104 	addi	sp,sp,4
   1486c:	f800283a 	ret

00014870 <atexit>:
   14870:	200b883a 	mov	r5,r4
   14874:	000d883a 	mov	r6,zero
   14878:	0009883a 	mov	r4,zero
   1487c:	000f883a 	mov	r7,zero
   14880:	0014abc1 	jmpi	14abc <__register_exitproc>

00014884 <exit>:
   14884:	defffe04 	addi	sp,sp,-8
   14888:	000b883a 	mov	r5,zero
   1488c:	dc000015 	stw	r16,0(sp)
   14890:	dfc00115 	stw	ra,4(sp)
   14894:	2021883a 	mov	r16,r4
   14898:	0014bec0 	call	14bec <__call_exitprocs>
   1489c:	00800074 	movhi	r2,1
   148a0:	109b2b04 	addi	r2,r2,27820
   148a4:	11000017 	ldw	r4,0(r2)
   148a8:	20800f17 	ldw	r2,60(r4)
   148ac:	10000126 	beq	r2,zero,148b4 <exit+0x30>
   148b0:	103ee83a 	callr	r2
   148b4:	8009883a 	mov	r4,r16
   148b8:	0014d8c0 	call	14d8c <_exit>

000148bc <memcmp>:
   148bc:	01c000c4 	movi	r7,3
   148c0:	3980192e 	bgeu	r7,r6,14928 <memcmp+0x6c>
   148c4:	2904b03a 	or	r2,r5,r4
   148c8:	11c4703a 	and	r2,r2,r7
   148cc:	10000f26 	beq	r2,zero,1490c <memcmp+0x50>
   148d0:	20c00003 	ldbu	r3,0(r4)
   148d4:	28800003 	ldbu	r2,0(r5)
   148d8:	1880151e 	bne	r3,r2,14930 <memcmp+0x74>
   148dc:	31bfff84 	addi	r6,r6,-2
   148e0:	01ffffc4 	movi	r7,-1
   148e4:	00000406 	br	148f8 <memcmp+0x3c>
   148e8:	20c00003 	ldbu	r3,0(r4)
   148ec:	28800003 	ldbu	r2,0(r5)
   148f0:	31bfffc4 	addi	r6,r6,-1
   148f4:	18800e1e 	bne	r3,r2,14930 <memcmp+0x74>
   148f8:	21000044 	addi	r4,r4,1
   148fc:	29400044 	addi	r5,r5,1
   14900:	31fff91e 	bne	r6,r7,148e8 <memcmp+0x2c>
   14904:	0005883a 	mov	r2,zero
   14908:	f800283a 	ret
   1490c:	20c00017 	ldw	r3,0(r4)
   14910:	28800017 	ldw	r2,0(r5)
   14914:	1880041e 	bne	r3,r2,14928 <memcmp+0x6c>
   14918:	31bfff04 	addi	r6,r6,-4
   1491c:	21000104 	addi	r4,r4,4
   14920:	29400104 	addi	r5,r5,4
   14924:	39bff936 	bltu	r7,r6,1490c <memcmp+0x50>
   14928:	303fe91e 	bne	r6,zero,148d0 <memcmp+0x14>
   1492c:	003ff506 	br	14904 <memcmp+0x48>
   14930:	1885c83a 	sub	r2,r3,r2
   14934:	f800283a 	ret

00014938 <memcpy>:
   14938:	00c003c4 	movi	r3,15
   1493c:	2005883a 	mov	r2,r4
   14940:	3009883a 	mov	r4,r6
   14944:	1980032e 	bgeu	r3,r6,14954 <memcpy+0x1c>
   14948:	2886b03a 	or	r3,r5,r2
   1494c:	18c000cc 	andi	r3,r3,3
   14950:	18000926 	beq	r3,zero,14978 <memcpy+0x40>
   14954:	1007883a 	mov	r3,r2
   14958:	290f883a 	add	r7,r5,r4
   1495c:	20000526 	beq	r4,zero,14974 <memcpy+0x3c>
   14960:	29800003 	ldbu	r6,0(r5)
   14964:	18c00044 	addi	r3,r3,1
   14968:	29400044 	addi	r5,r5,1
   1496c:	19bfffc5 	stb	r6,-1(r3)
   14970:	29fffb1e 	bne	r5,r7,14960 <memcpy+0x28>
   14974:	f800283a 	ret
   14978:	327ffc04 	addi	r9,r6,-16
   1497c:	4812d13a 	srli	r9,r9,4
   14980:	11000404 	addi	r4,r2,16
   14984:	1007883a 	mov	r3,r2
   14988:	4810913a 	slli	r8,r9,4
   1498c:	280f883a 	mov	r7,r5
   14990:	2209883a 	add	r4,r4,r8
   14994:	3a000017 	ldw	r8,0(r7)
   14998:	18c00404 	addi	r3,r3,16
   1499c:	39c00404 	addi	r7,r7,16
   149a0:	1a3ffc15 	stw	r8,-16(r3)
   149a4:	3a3ffd17 	ldw	r8,-12(r7)
   149a8:	1a3ffd15 	stw	r8,-12(r3)
   149ac:	3a3ffe17 	ldw	r8,-8(r7)
   149b0:	1a3ffe15 	stw	r8,-8(r3)
   149b4:	3a3fff17 	ldw	r8,-4(r7)
   149b8:	1a3fff15 	stw	r8,-4(r3)
   149bc:	193ff51e 	bne	r3,r4,14994 <memcpy+0x5c>
   149c0:	49c00044 	addi	r7,r9,1
   149c4:	380e913a 	slli	r7,r7,4
   149c8:	310003cc 	andi	r4,r6,15
   149cc:	018000c4 	movi	r6,3
   149d0:	11c7883a 	add	r3,r2,r7
   149d4:	29cb883a 	add	r5,r5,r7
   149d8:	313fdf2e 	bgeu	r6,r4,14958 <memcpy+0x20>
   149dc:	213fff04 	addi	r4,r4,-4
   149e0:	2014d0ba 	srli	r10,r4,2
   149e4:	1a400104 	addi	r9,r3,4
   149e8:	180d883a 	mov	r6,r3
   149ec:	528f883a 	add	r7,r10,r10
   149f0:	39cf883a 	add	r7,r7,r7
   149f4:	49d3883a 	add	r9,r9,r7
   149f8:	280f883a 	mov	r7,r5
   149fc:	3a000017 	ldw	r8,0(r7)
   14a00:	31800104 	addi	r6,r6,4
   14a04:	39c00104 	addi	r7,r7,4
   14a08:	323fff15 	stw	r8,-4(r6)
   14a0c:	327ffb1e 	bne	r6,r9,149fc <memcpy+0xc4>
   14a10:	51800044 	addi	r6,r10,1
   14a14:	52bfff24 	muli	r10,r10,-4
   14a18:	318d883a 	add	r6,r6,r6
   14a1c:	318d883a 	add	r6,r6,r6
   14a20:	5109883a 	add	r4,r10,r4
   14a24:	298b883a 	add	r5,r5,r6
   14a28:	1987883a 	add	r3,r3,r6
   14a2c:	003fca06 	br	14958 <memcpy+0x20>

00014a30 <strlen>:
   14a30:	208000cc 	andi	r2,r4,3
   14a34:	10001f1e 	bne	r2,zero,14ab4 <strlen+0x84>
   14a38:	20800017 	ldw	r2,0(r4)
   14a3c:	01ffbff4 	movhi	r7,65279
   14a40:	39ffbfc4 	addi	r7,r7,-257
   14a44:	01a02074 	movhi	r6,32897
   14a48:	31a02004 	addi	r6,r6,-32640
   14a4c:	11c7883a 	add	r3,r2,r7
   14a50:	0084303a 	nor	r2,zero,r2
   14a54:	1886703a 	and	r3,r3,r2
   14a58:	1986703a 	and	r3,r3,r6
   14a5c:	2005883a 	mov	r2,r4
   14a60:	1800101e 	bne	r3,zero,14aa4 <strlen+0x74>
   14a64:	10800104 	addi	r2,r2,4
   14a68:	10c00017 	ldw	r3,0(r2)
   14a6c:	19cb883a 	add	r5,r3,r7
   14a70:	00c6303a 	nor	r3,zero,r3
   14a74:	28c6703a 	and	r3,r5,r3
   14a78:	1986703a 	and	r3,r3,r6
   14a7c:	1800091e 	bne	r3,zero,14aa4 <strlen+0x74>
   14a80:	10800104 	addi	r2,r2,4
   14a84:	10c00017 	ldw	r3,0(r2)
   14a88:	19cb883a 	add	r5,r3,r7
   14a8c:	00c6303a 	nor	r3,zero,r3
   14a90:	28c6703a 	and	r3,r5,r3
   14a94:	1986703a 	and	r3,r3,r6
   14a98:	183ff226 	beq	r3,zero,14a64 <strlen+0x34>
   14a9c:	00000106 	br	14aa4 <strlen+0x74>
   14aa0:	10800044 	addi	r2,r2,1
   14aa4:	10c00007 	ldb	r3,0(r2)
   14aa8:	183ffd1e 	bne	r3,zero,14aa0 <strlen+0x70>
   14aac:	1105c83a 	sub	r2,r2,r4
   14ab0:	f800283a 	ret
   14ab4:	2005883a 	mov	r2,r4
   14ab8:	003ffa06 	br	14aa4 <strlen+0x74>

00014abc <__register_exitproc>:
   14abc:	defffa04 	addi	sp,sp,-24
   14ac0:	00800074 	movhi	r2,1
   14ac4:	109b2b04 	addi	r2,r2,27820
   14ac8:	dc000315 	stw	r16,12(sp)
   14acc:	14000017 	ldw	r16,0(r2)
   14ad0:	dc400415 	stw	r17,16(sp)
   14ad4:	dfc00515 	stw	ra,20(sp)
   14ad8:	80805217 	ldw	r2,328(r16)
   14adc:	2023883a 	mov	r17,r4
   14ae0:	10003e26 	beq	r2,zero,14bdc <__register_exitproc+0x120>
   14ae4:	10c00117 	ldw	r3,4(r2)
   14ae8:	020007c4 	movi	r8,31
   14aec:	40c0180e 	bge	r8,r3,14b50 <__register_exitproc+0x94>
   14af0:	00800034 	movhi	r2,0
   14af4:	10800004 	addi	r2,r2,0
   14af8:	1000061e 	bne	r2,zero,14b14 <__register_exitproc+0x58>
   14afc:	00bfffc4 	movi	r2,-1
   14b00:	dfc00517 	ldw	ra,20(sp)
   14b04:	dc400417 	ldw	r17,16(sp)
   14b08:	dc000317 	ldw	r16,12(sp)
   14b0c:	dec00604 	addi	sp,sp,24
   14b10:	f800283a 	ret
   14b14:	01006404 	movi	r4,400
   14b18:	d9400015 	stw	r5,0(sp)
   14b1c:	d9800115 	stw	r6,4(sp)
   14b20:	d9c00215 	stw	r7,8(sp)
   14b24:	00000000 	call	0 <__reset-0x10000>
   14b28:	d9400017 	ldw	r5,0(sp)
   14b2c:	d9800117 	ldw	r6,4(sp)
   14b30:	d9c00217 	ldw	r7,8(sp)
   14b34:	103ff126 	beq	r2,zero,14afc <__register_exitproc+0x40>
   14b38:	80c05217 	ldw	r3,328(r16)
   14b3c:	10000115 	stw	zero,4(r2)
   14b40:	10c00015 	stw	r3,0(r2)
   14b44:	80805215 	stw	r2,328(r16)
   14b48:	10006215 	stw	zero,392(r2)
   14b4c:	10006315 	stw	zero,396(r2)
   14b50:	10c00117 	ldw	r3,4(r2)
   14b54:	88000d1e 	bne	r17,zero,14b8c <__register_exitproc+0xd0>
   14b58:	19000084 	addi	r4,r3,2
   14b5c:	2109883a 	add	r4,r4,r4
   14b60:	18c00044 	addi	r3,r3,1
   14b64:	2109883a 	add	r4,r4,r4
   14b68:	1109883a 	add	r4,r2,r4
   14b6c:	10c00115 	stw	r3,4(r2)
   14b70:	0005883a 	mov	r2,zero
   14b74:	21400015 	stw	r5,0(r4)
   14b78:	dfc00517 	ldw	ra,20(sp)
   14b7c:	dc400417 	ldw	r17,16(sp)
   14b80:	dc000317 	ldw	r16,12(sp)
   14b84:	dec00604 	addi	sp,sp,24
   14b88:	f800283a 	ret
   14b8c:	02400044 	movi	r9,1
   14b90:	12806217 	ldw	r10,392(r2)
   14b94:	48d2983a 	sll	r9,r9,r3
   14b98:	19000804 	addi	r4,r3,32
   14b9c:	18d1883a 	add	r8,r3,r3
   14ba0:	2109883a 	add	r4,r4,r4
   14ba4:	4211883a 	add	r8,r8,r8
   14ba8:	2109883a 	add	r4,r4,r4
   14bac:	1109883a 	add	r4,r2,r4
   14bb0:	1211883a 	add	r8,r2,r8
   14bb4:	5254b03a 	or	r10,r10,r9
   14bb8:	21c02215 	stw	r7,136(r4)
   14bbc:	41802215 	stw	r6,136(r8)
   14bc0:	12806215 	stw	r10,392(r2)
   14bc4:	01000084 	movi	r4,2
   14bc8:	893fe31e 	bne	r17,r4,14b58 <__register_exitproc+0x9c>
   14bcc:	11006317 	ldw	r4,396(r2)
   14bd0:	2252b03a 	or	r9,r4,r9
   14bd4:	12406315 	stw	r9,396(r2)
   14bd8:	003fdf06 	br	14b58 <__register_exitproc+0x9c>
   14bdc:	008000b4 	movhi	r2,2
   14be0:	10a25004 	addi	r2,r2,-30400
   14be4:	80805215 	stw	r2,328(r16)
   14be8:	003fbe06 	br	14ae4 <__register_exitproc+0x28>

00014bec <__call_exitprocs>:
   14bec:	00800074 	movhi	r2,1
   14bf0:	109b2b04 	addi	r2,r2,27820
   14bf4:	10800017 	ldw	r2,0(r2)
   14bf8:	defff304 	addi	sp,sp,-52
   14bfc:	df000b15 	stw	fp,44(sp)
   14c00:	d8800015 	stw	r2,0(sp)
   14c04:	10805204 	addi	r2,r2,328
   14c08:	dd400815 	stw	r21,32(sp)
   14c0c:	dfc00c15 	stw	ra,48(sp)
   14c10:	ddc00a15 	stw	r23,40(sp)
   14c14:	dd800915 	stw	r22,36(sp)
   14c18:	dd000715 	stw	r20,28(sp)
   14c1c:	dcc00615 	stw	r19,24(sp)
   14c20:	dc800515 	stw	r18,20(sp)
   14c24:	dc400415 	stw	r17,16(sp)
   14c28:	dc000315 	stw	r16,12(sp)
   14c2c:	d9000115 	stw	r4,4(sp)
   14c30:	2839883a 	mov	fp,r5
   14c34:	d8800215 	stw	r2,8(sp)
   14c38:	057fffc4 	movi	r21,-1
   14c3c:	d8800017 	ldw	r2,0(sp)
   14c40:	ddc00217 	ldw	r23,8(sp)
   14c44:	14805217 	ldw	r18,328(r2)
   14c48:	90001726 	beq	r18,zero,14ca8 <__call_exitprocs+0xbc>
   14c4c:	94400117 	ldw	r17,4(r18)
   14c50:	8c3fffc4 	addi	r16,r17,-1
   14c54:	80001116 	blt	r16,zero,14c9c <__call_exitprocs+0xb0>
   14c58:	8c400044 	addi	r17,r17,1
   14c5c:	8427883a 	add	r19,r16,r16
   14c60:	8c63883a 	add	r17,r17,r17
   14c64:	95802204 	addi	r22,r18,136
   14c68:	9ce7883a 	add	r19,r19,r19
   14c6c:	8c63883a 	add	r17,r17,r17
   14c70:	b4e7883a 	add	r19,r22,r19
   14c74:	9463883a 	add	r17,r18,r17
   14c78:	e0001726 	beq	fp,zero,14cd8 <__call_exitprocs+0xec>
   14c7c:	8c87c83a 	sub	r3,r17,r18
   14c80:	b0c7883a 	add	r3,r22,r3
   14c84:	18c01e17 	ldw	r3,120(r3)
   14c88:	1f001326 	beq	r3,fp,14cd8 <__call_exitprocs+0xec>
   14c8c:	843fffc4 	addi	r16,r16,-1
   14c90:	9cffff04 	addi	r19,r19,-4
   14c94:	8c7fff04 	addi	r17,r17,-4
   14c98:	857ff71e 	bne	r16,r21,14c78 <__call_exitprocs+0x8c>
   14c9c:	00800034 	movhi	r2,0
   14ca0:	10800004 	addi	r2,r2,0
   14ca4:	10002a1e 	bne	r2,zero,14d50 <__call_exitprocs+0x164>
   14ca8:	dfc00c17 	ldw	ra,48(sp)
   14cac:	df000b17 	ldw	fp,44(sp)
   14cb0:	ddc00a17 	ldw	r23,40(sp)
   14cb4:	dd800917 	ldw	r22,36(sp)
   14cb8:	dd400817 	ldw	r21,32(sp)
   14cbc:	dd000717 	ldw	r20,28(sp)
   14cc0:	dcc00617 	ldw	r19,24(sp)
   14cc4:	dc800517 	ldw	r18,20(sp)
   14cc8:	dc400417 	ldw	r17,16(sp)
   14ccc:	dc000317 	ldw	r16,12(sp)
   14cd0:	dec00d04 	addi	sp,sp,52
   14cd4:	f800283a 	ret
   14cd8:	91000117 	ldw	r4,4(r18)
   14cdc:	88c00017 	ldw	r3,0(r17)
   14ce0:	213fffc4 	addi	r4,r4,-1
   14ce4:	24001526 	beq	r4,r16,14d3c <__call_exitprocs+0x150>
   14ce8:	88000015 	stw	zero,0(r17)
   14cec:	183fe726 	beq	r3,zero,14c8c <__call_exitprocs+0xa0>
   14cf0:	00800044 	movi	r2,1
   14cf4:	1408983a 	sll	r4,r2,r16
   14cf8:	91406217 	ldw	r5,392(r18)
   14cfc:	95000117 	ldw	r20,4(r18)
   14d00:	214a703a 	and	r5,r4,r5
   14d04:	28000b26 	beq	r5,zero,14d34 <__call_exitprocs+0x148>
   14d08:	91406317 	ldw	r5,396(r18)
   14d0c:	2148703a 	and	r4,r4,r5
   14d10:	20000c1e 	bne	r4,zero,14d44 <__call_exitprocs+0x158>
   14d14:	99400017 	ldw	r5,0(r19)
   14d18:	d9000117 	ldw	r4,4(sp)
   14d1c:	183ee83a 	callr	r3
   14d20:	90c00117 	ldw	r3,4(r18)
   14d24:	1d3fc51e 	bne	r3,r20,14c3c <__call_exitprocs+0x50>
   14d28:	b8c00017 	ldw	r3,0(r23)
   14d2c:	1cbfd726 	beq	r3,r18,14c8c <__call_exitprocs+0xa0>
   14d30:	003fc206 	br	14c3c <__call_exitprocs+0x50>
   14d34:	183ee83a 	callr	r3
   14d38:	003ff906 	br	14d20 <__call_exitprocs+0x134>
   14d3c:	94000115 	stw	r16,4(r18)
   14d40:	003fea06 	br	14cec <__call_exitprocs+0x100>
   14d44:	99000017 	ldw	r4,0(r19)
   14d48:	183ee83a 	callr	r3
   14d4c:	003ff406 	br	14d20 <__call_exitprocs+0x134>
   14d50:	90c00117 	ldw	r3,4(r18)
   14d54:	1800071e 	bne	r3,zero,14d74 <__call_exitprocs+0x188>
   14d58:	90c00017 	ldw	r3,0(r18)
   14d5c:	18000926 	beq	r3,zero,14d84 <__call_exitprocs+0x198>
   14d60:	9009883a 	mov	r4,r18
   14d64:	b8c00015 	stw	r3,0(r23)
   14d68:	00000000 	call	0 <__reset-0x10000>
   14d6c:	bc800017 	ldw	r18,0(r23)
   14d70:	003fb506 	br	14c48 <__call_exitprocs+0x5c>
   14d74:	90c00017 	ldw	r3,0(r18)
   14d78:	902f883a 	mov	r23,r18
   14d7c:	1825883a 	mov	r18,r3
   14d80:	003fb106 	br	14c48 <__call_exitprocs+0x5c>
   14d84:	0007883a 	mov	r3,zero
   14d88:	003ffb06 	br	14d78 <__call_exitprocs+0x18c>

00014d8c <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   14d8c:	defffc04 	addi	sp,sp,-16
   14d90:	df000315 	stw	fp,12(sp)
   14d94:	df000304 	addi	fp,sp,12
   14d98:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   14d9c:	0001883a 	nop
   14da0:	e0bfff17 	ldw	r2,-4(fp)
   14da4:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
   14da8:	e0bffd17 	ldw	r2,-12(fp)
   14dac:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   14db0:	e0bffe17 	ldw	r2,-8(fp)
   14db4:	10000226 	beq	r2,zero,14dc0 <_exit+0x34>
    ALT_SIM_FAIL();
   14db8:	002af070 	cmpltui	zero,zero,43969
   14dbc:	00000106 	br	14dc4 <_exit+0x38>
  } else {
    ALT_SIM_PASS();
   14dc0:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   14dc4:	003fff06 	br	14dc4 <_exit+0x38>
