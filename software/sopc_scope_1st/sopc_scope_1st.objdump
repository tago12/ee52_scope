
sopc_scope_1st.elf:     file format elf32-littlenios2
sopc_scope_1st.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x001501b8

Program Header:
    LOAD off    0x00001000 vaddr 0x00150000 paddr 0x00150000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00150020 paddr 0x00150020 align 2**12
         filesz 0x00005728 memsz 0x00005728 flags r-x
    LOAD off    0x00006748 vaddr 0x00155748 paddr 0x00156d88 align 2**12
         filesz 0x00001640 memsz 0x00001640 flags rw-
    LOAD off    0x000083c8 vaddr 0x001583c8 paddr 0x001583c8 align 2**12
         filesz 0x00000000 memsz 0x000007e0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00150000  00150000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000198  00150020  00150020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00004ce0  001501b8  001501b8  000011b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000008b0  00154e98  00154e98  00005e98  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001640  00155748  00156d88  00006748  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000007e0  001583c8  001583c8  000083c8  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  00007d88  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000006c8  00000000  00000000  00007db0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00009357  00000000  00000000  00008478  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000313a  00000000  00000000  000117cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00003316  00000000  00000000  00014909  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000010f0  00000000  00000000  00017c20  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00001cbd  00000000  00000000  00018d10  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00001efe  00000000  00000000  0001a9cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000030  00000000  00000000  0001c8cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000118  00000000  00000000  0001c900  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000003  00000000  00000000  0001f2b7  2**0
                  CONTENTS, READONLY
 17 .cpu          00000004  00000000  00000000  0001f2ba  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  0001f2be  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  0001f2bf  2**0
                  CONTENTS, READONLY
 20 .stderr_dev   00000004  00000000  00000000  0001f2c0  2**0
                  CONTENTS, READONLY
 21 .stdin_dev    00000004  00000000  00000000  0001f2c4  2**0
                  CONTENTS, READONLY
 22 .stdout_dev   00000004  00000000  00000000  0001f2c8  2**0
                  CONTENTS, READONLY
 23 .sopc_system_name 0000000e  00000000  00000000  0001f2cc  2**0
                  CONTENTS, READONLY
 24 .quartus_project_dir 00000026  00000000  00000000  0001f2da  2**0
                  CONTENTS, READONLY
 25 .sopcinfo     0004a072  00000000  00000000  0001f300  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00150000 l    d  .entry	00000000 .entry
00150020 l    d  .exceptions	00000000 .exceptions
001501b8 l    d  .text	00000000 .text
00154e98 l    d  .rodata	00000000 .rodata
00155748 l    d  .rwdata	00000000 .rwdata
001583c8 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 C:/Users/tago/Dropbox/OUT/EE52/software/sopc_scope_1st_bsp//obj/HAL/src/crt0.o
00150200 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00150094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 char58.c
00000000 l    df *ABS*	00000000 keyproc.c
00000000 l    df *ABS*	00000000 lcdout.c
00000000 l    df *ABS*	00000000 mainloop.c
001507dc l     F .text	0000008c key_lookup
001552c4 l     O .rodata	00000030 process_key.1648
00155298 l     O .rodata	00000014 keys.1653
001552ac l     O .rodata	00000018 keycodes.1652
00000000 l    df *ABS*	00000000 menu.c
001583c8 l     O .bss	00000004 menu_display
0015532c l     O .rodata	00000070 menu
001583cc l     O .bss	00000004 menu_entry
00150c34 l     F .text	000000d0 display_entry
001553b8 l     O .rodata	0000001c process.1663
0015539c l     O .rodata	0000001c process.1668
00000000 l    df *ABS*	00000000 menuact.c
001583d0 l     O .bss	00000004 trigger_mode
001583d4 l     O .bss	00000004 scale
001583d8 l     O .bss	00000004 sweep
001583dc l     O .bss	00000004 level
001583e0 l     O .bss	00000004 slope
001583e4 l     O .bss	00000004 delay
0015545c l     O .rodata	00000088 sweep_rates
00155534 l     O .rodata	0000000c modes.1636
00155504 l     O .rodata	0000000c scale_stat.1649
00151578 l     F .text	000000c0 adjust_trg_delay
00151854 l     F .text	00000198 cvt_num_field
00156d54 l     O .rwdata	00000008 slopes.1689
00000000 l    df *ABS*	00000000 stubfncs.c
00000000 l    df *ABS*	00000000 testcode.c
00155540 l     O .rodata	000001e0 waveform.1500
00000000 l    df *ABS*	00000000 tracutil.c
001583e8 l     O .bss	00000004 trace_status
001583ec l     O .bss	00000004 sampling
001583f0 l     O .bss	00000004 sample_size
001583f4 l     O .bss	00000004 cur_scale
00158424 l     O .bss	000000b4 saved_axis_x
001584d8 l     O .bss	000000b0 saved_axis_y
00158588 l     O .bss	000002a0 saved_menu
00158828 l     O .bss	000000f0 saved_area
001583f8 l     O .bss	00000004 saved_pos_x
001583fc l     O .bss	00000004 saved_pos_y
00158400 l     O .bss	00000004 saved_end_x
00158404 l     O .bss	00000004 saved_end_y
00000000 l    df *ABS*	00000000 obj/default/keys.o
00155748 l       .rwdata	00000000 curr_key
00152b0c l       .text	00000000 keys_handler_push1
00152b14 l       .text	00000000 keys_handler_push2
00152b1c l       .text	00000000 keys_handler_rot1r
00152b24 l       .text	00000000 keys_handler_rot1l
00152b2c l       .text	00000000 keys_handler_rot2r
00152b34 l       .text	00000000 keys_handler_rot2l
00152b3c l       .text	00000000 keys_handler_done
00000000 l    df *ABS*	00000000 lib2-divmod.c
00152b88 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00152f80 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
001530e4 l     F .text	00000038 alt_dev_reg
0015574c l     O .rwdata	00001060 jtag
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
001533b8 l     F .text	00000204 altera_avalon_jtag_uart_irq
001535bc l     F .text	000000a4 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
00153d38 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
00153e94 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00153ec0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00154098 l     F .text	000000c0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
001541d0 l     F .text	00000050 alt_get_errno
00154220 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 impure.c
00156954 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
0015306c g     F .text	00000078 alt_main
00158918 g     O .bss	00000100 alt_irq
001514e4 g     F .text	00000048 trg_delay_down
00156d88 g       *ABS*	00000000 __flash_rwdata_start
00150fe8 g     F .text	00000068 display_scale
00151d4c g     F .text	00000028 trace_rearm
00151acc g     F .text	00000020 sample_done
00150d90 g     F .text	00000020 get_trigger_mode
00150d04 g     F .text	00000020 no_menu_action
00151a84 g     F .text	00000024 set_delay
00000000  w      *UND*	00000000 __errno
00150000 g     F .entry	0000001c __reset
00150020 g       *ABS*	00000000 __flash_exceptions_start
00152a78 g       .text	00000000 keys_init
00150204 g     F .text	00000024 no_action
00158420 g     O .bss	00000004 errno
00080000 g       *ABS*	00000000 __alt_mem_rom
00150308 g     F .text	00000030 menu_right
0015121c g     F .text	00000048 set_trg_level
00158410 g     O .bss	00000004 alt_argv
00150868 g     F .text	00000064 init_menu
0015ed54 g       *ABS*	00000000 _gp
00151cb4 g     F .text	00000020 is_sampling
001502d8 g     F .text	00000030 menu_left
001567d4 g     O .rwdata	00000180 alt_fd_list
0015465c g     F .text	00000090 alt_find_dev
00154a08 g     F .text	000000f8 memcpy
00150000 g       *ABS*	00000000 __alt_mem_temp_ram
00154158 g     F .text	00000078 alt_io_redirect
001512b4 g     F .text	00000054 trg_level_up
00154e98 g       *ABS*	00000000 __DTOR_END__
00150d50 g     F .text	00000040 set_trigger_mode
00151a0c g     F .text	0000002c plot_pixel
001537bc g     F .text	00000218 altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
00152ca8 g     F .text	00000008 __udivsi3
001524d0 g     F .text	00000110 restore_trace
001548b4 g     F .text	0000008c alt_icache_flush
00152410 g     F .text	000000c0 set_save_area
00120000 g       *ABS*	00000000 __alt_mem_ram
00151aa8 g     F .text	00000024 start_sample
00150f20 g     F .text	00000064 scale_down
00156d70 g     O .rwdata	00000004 alt_max_fd
00152b78 g       .text	00000000 key_available
001511b4 g     F .text	00000068 display_sweep
00151da0 g     F .text	000003cc set_display_scale
001525e0 g     F .text	00000048 do_trace
00156d80 g     O .rwdata	00000004 _global_impure_ptr
00158ba8 g       *ABS*	00000000 __bss_end
00152e90 g     F .text	000000f0 alt_iic_isr_register
00154538 g     F .text	00000104 alt_tick
00151c18 g     F .text	00000064 init_trace
00152e44 g     F .text	0000004c alt_ic_irq_enabled
001514a4 g     F .text	00000040 set_trg_delay
001544a0 g     F .text	00000098 alt_alarm_stop
001502a8 g     F .text	00000030 menu_down
00158408 g     O .bss	00000004 alt_irq_active
00151aec g     F .text	0000012c get_test_sample
001500ec g     F .exceptions	000000cc alt_irq_handler
001567ac g     O .rwdata	00000028 alt_dev_null
00150338 g     F .text	000000a8 clear_region
00154e98 g     O .rodata	00000400 char_patterns
00153e50 g     F .text	00000044 alt_dcache_flush_all
00150a88 g     F .text	0000006c previous_entry
00156d88 g       *ABS*	00000000 __ram_rwdata_end
00156d68 g     O .rwdata	00000008 alt_dev_list
00151c7c g     F .text	00000038 set_mode
00155748 g       *ABS*	00000000 __ram_rodata_end
00152cb0 g     F .text	00000008 __umodsi3
00150e78 g     F .text	00000068 display_mode
00158ba8 g       *ABS*	00000000 end
00150d24 g     F .text	0000002c no_display
00151308 g     F .text	0000009c display_trg_level
00151130 g     F .text	00000084 sweep_up
001509bc g     F .text	0000005c reset_menu
001508cc g     F .text	00000038 clear_menu
001532f8 g     F .text	000000c0 altera_avalon_jtag_uart_init
0015152c g     F .text	0000004c trg_delay_up
00154e98 g       *ABS*	00000000 __CTOR_LIST__
00159ca0 g       *ABS*	00000000 __alt_stack_pointer
001539d4 g     F .text	00000224 altera_avalon_jtag_uart_write
00154cbc g     F .text	000001a0 __call_exitprocs
001501b8 g     F .text	0000004c _start
00158418 g     O .bss	00000004 _alt_tick_rate
0015841c g     O .bss	00000004 _alt_nticks
001513ec g     F .text	00000054 trg_slope_toggle
00153150 g     F .text	00000044 alt_sys_init
00154b8c g     F .text	00000130 __register_exitproc
00153660 g     F .text	00000068 altera_avalon_jtag_uart_close
00155748 g       *ABS*	00000000 __ram_rwdata_start
00154e98 g       *ABS*	00000000 __ram_rodata_start
00153194 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00154800 g     F .text	000000b4 alt_get_fd
001519ec g     F .text	00000020 clear_display
0015498c g     F .text	0000007c memcmp
00153254 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
00158ba8 g       *ABS*	00000000 __alt_stack_base
001532a4 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0015230c g     F .text	00000104 restore_menu_trace
001546ec g     F .text	00000114 alt_find_file
00153f10 g     F .text	000000a0 alt_dev_llist_insert
00151d74 g     F .text	0000002c set_trace_size
001506a0 g     F .text	00000098 plot_string
001583c8 g       *ABS*	00000000 __bss_start
00150738 g     F .text	000000a4 main
00158414 g     O .bss	00000004 alt_envp
001531f4 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00152628 g     F .text	00000450 plot_trace
00158a18 g     O .bss	00000190 _atexit0
001510b0 g     F .text	00000080 sweep_down
00156d74 g     O .rwdata	00000004 alt_errno
00150db0 g     F .text	00000064 mode_down
00151a38 g     F .text	00000024 set_sample_rate
00152bfc g     F .text	00000050 __divsi3
00151a5c g     F .text	00000028 set_trigger
00154e98 g       *ABS*	00000000 __CTOR_END__
00150984 g     F .text	00000038 refresh_menu
00154e98 g       *ABS*	00000000 __flash_rodata_start
00154e98 g       *ABS*	00000000 __DTOR_LIST__
00150278 g     F .text	00000030 menu_up
00150b94 g     F .text	000000a0 menu_entry_right
0015311c g     F .text	00000034 alt_irq_init
00154440 g     F .text	00000060 alt_release_fd
00154940 g     F .text	00000014 atexit
00151d0c g     F .text	00000040 trace_done
00156d84 g     O .rwdata	00000004 _impure_ptr
0015840c g     O .bss	00000004 alt_argc
001513a4 g     F .text	00000048 set_trg_slope
00151264 g     F .text	00000050 trg_level_down
0015400c g     F .text	0000005c _do_dtors
00152b64 g       .text	00000000 getkey
00150538 g     F .text	00000168 plot_char
00150020 g       .exceptions	00000000 alt_irq_entry
00150af4 g     F .text	000000a0 menu_entry_left
00156d60 g     O .rwdata	00000008 alt_fs_list
0015216c g     F .text	000001a0 clear_saved_areas
001503e0 g     F .text	000000ac plot_hline
00150020 g       *ABS*	00000000 __ram_exceptions_start
00150ee0 g     F .text	00000040 set_scale
00152cb8 g     F .text	00000050 alt_ic_isr_register
00156d88 g       *ABS*	00000000 _edata
00158ba8 g       *ABS*	00000000 _end
00150e14 g     F .text	00000064 mode_up
001501b8 g       *ABS*	00000000 __ram_exceptions_end
001536c8 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
00152da4 g     F .text	000000a0 alt_ic_irq_disable
0015463c g     F .text	00000020 altera_nios2_qsys_irq_init
00154954 g     F .text	00000038 exit
00151638 g     F .text	0000021c display_trg_delay
00152c4c g     F .text	0000005c __modsi3
00159ca0 g       *ABS*	00000000 __alt_data_end
00150020 g     F .exceptions	00000000 alt_exception
00151440 g     F .text	00000064 display_trg_slope
00152acc g       .text	00000000 keys_handler
00154e5c g     F .text	0000003c _exit
00153bf8 g     F .text	00000140 alt_alarm_start
00154b00 g     F .text	0000008c strlen
001542ec g     F .text	00000154 open
00154068 g     F .text	00000030 alt_icache_flush_all
00156d5c g     O .rwdata	00000004 alt_priority_mask
00152d08 g     F .text	0000009c alt_ic_irq_enable
0015048c g     F .text	000000ac plot_vline
00150904 g     F .text	00000080 display_menu
00156d78 g     O .rwdata	00000008 alt_alarm_list
00153fb0 g     F .text	0000005c _do_ctors
00150a18 g     F .text	00000070 next_entry
00153d88 g     F .text	000000c8 close
00151cd4 g     F .text	00000038 trace_rdy
00152fec g     F .text	00000080 alt_load
00151050 g     F .text	00000060 set_sweep
00150f84 g     F .text	00000064 scale_up
00150228 g     F .text	00000050 menu_key
00000000  w      *UND*	00000000 free



Disassembly of section .entry:

00150000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
  150000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
  150004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
  150008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
  15000c:	00bffd16 	blt	zero,r2,150004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  150010:	00400574 	movhi	at,21
    ori r1, r1, %lo(_start)
  150014:	08406e14 	ori	at,at,440
    jmp r1
  150018:	0800683a 	jmp	at
  15001c:	00000000 	call	0 <__alt_mem_rom-0x80000>

Disassembly of section .exceptions:

00150020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  150020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  150024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  150028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  15002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  150030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  150034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  150038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  15003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  150040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  150044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  150048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  15004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  150050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  150054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  150058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  15005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  150060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  150064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  150068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  15006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  150070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  150074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  150078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  15007c:	10000326 	beq	r2,zero,15008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  150080:	20000226 	beq	r4,zero,15008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  150084:	01500ec0 	call	1500ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  150088:	00000306 	br	150098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  15008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  150090:	e8bfff17 	ldw	r2,-4(ea)

00150094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  150094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  150098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  15009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1500a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1500a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1500a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1500ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1500b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1500b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1500b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1500bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1500c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1500c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1500c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1500cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1500d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1500d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1500d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1500dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1500e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1500e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1500e8:	ef80083a 	eret

001500ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1500ec:	defff904 	addi	sp,sp,-28
  1500f0:	dfc00615 	stw	ra,24(sp)
  1500f4:	df000515 	stw	fp,20(sp)
  1500f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  1500fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  150100:	0005313a 	rdctl	r2,ipending
  150104:	e0bffe15 	stw	r2,-8(fp)

  return active;
  150108:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  15010c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  150110:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  150114:	00800044 	movi	r2,1
  150118:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  15011c:	e0fffb17 	ldw	r3,-20(fp)
  150120:	e0bffc17 	ldw	r2,-16(fp)
  150124:	1884703a 	and	r2,r3,r2
  150128:	10001726 	beq	r2,zero,150188 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  15012c:	00c005b4 	movhi	r3,22
  150130:	18e24604 	addi	r3,r3,-30440
  150134:	e0bffd17 	ldw	r2,-12(fp)
  150138:	100490fa 	slli	r2,r2,3
  15013c:	1885883a 	add	r2,r3,r2
  150140:	10c00017 	ldw	r3,0(r2)
  150144:	010005b4 	movhi	r4,22
  150148:	21224604 	addi	r4,r4,-30440
  15014c:	e0bffd17 	ldw	r2,-12(fp)
  150150:	100490fa 	slli	r2,r2,3
  150154:	2085883a 	add	r2,r4,r2
  150158:	10800104 	addi	r2,r2,4
  15015c:	10800017 	ldw	r2,0(r2)
  150160:	1009883a 	mov	r4,r2
  150164:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  150168:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  15016c:	0005313a 	rdctl	r2,ipending
  150170:	e0bfff15 	stw	r2,-4(fp)

  return active;
  150174:	e0bfff17 	ldw	r2,-4(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
  150178:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  15017c:	e0bffb17 	ldw	r2,-20(fp)
  150180:	103fe31e 	bne	r2,zero,150110 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  150184:	00000706 	br	1501a4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  150188:	e0bffc17 	ldw	r2,-16(fp)
  15018c:	1085883a 	add	r2,r2,r2
  150190:	e0bffc15 	stw	r2,-16(fp)
      i++;
  150194:	e0bffd17 	ldw	r2,-12(fp)
  150198:	10800044 	addi	r2,r2,1
  15019c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  1501a0:	003fde06 	br	15011c <alt_irq_handler+0x30>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
  1501a4:	e037883a 	mov	sp,fp
  1501a8:	dfc00117 	ldw	ra,4(sp)
  1501ac:	df000017 	ldw	fp,0(sp)
  1501b0:	dec00204 	addi	sp,sp,8
  1501b4:	f800283a 	ret

Disassembly of section .text:

001501b8 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
  1501b8:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
  1501bc:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
  1501c0:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
  1501c4:	00bffd16 	blt	zero,r2,1501bc <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  1501c8:	06c00574 	movhi	sp,21
    ori sp, sp, %lo(__alt_stack_pointer)
  1501cc:	dee72814 	ori	sp,sp,40096
    movhi gp, %hi(_gp)
  1501d0:	06800574 	movhi	gp,21
    ori gp, gp, %lo(_gp)
  1501d4:	d6bb5514 	ori	gp,gp,60756
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  1501d8:	00800574 	movhi	r2,21
    ori r2, r2, %lo(__bss_start)
  1501dc:	10a0f214 	ori	r2,r2,33736

    movhi r3, %hi(__bss_end)
  1501e0:	00c00574 	movhi	r3,21
    ori r3, r3, %lo(__bss_end)
  1501e4:	18e2ea14 	ori	r3,r3,35752

    beq r2, r3, 1f
  1501e8:	10c00326 	beq	r2,r3,1501f8 <_start+0x40>

0:
    stw zero, (r2)
  1501ec:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  1501f0:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  1501f4:	10fffd36 	bltu	r2,r3,1501ec <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  1501f8:	0152fec0 	call	152fec <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  1501fc:	015306c0 	call	15306c <alt_main>

00150200 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  150200:	003fff06 	br	150200 <alt_after_alt_main>

00150204 <no_action>:
   Last Modified:    Mar. 8, 1994

*/

enum status  no_action(enum status cur_state)
{
  150204:	defffe04 	addi	sp,sp,-8
  150208:	df000115 	stw	fp,4(sp)
  15020c:	df000104 	addi	fp,sp,4
  150210:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* return the current state */
    return  cur_state;
  150214:	e0bfff17 	ldw	r2,-4(fp)

}
  150218:	e037883a 	mov	sp,fp
  15021c:	df000017 	ldw	fp,0(sp)
  150220:	dec00104 	addi	sp,sp,4
  150224:	f800283a 	ret

00150228 <menu_key>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_key(enum status cur_state)
{
  150228:	defffd04 	addi	sp,sp,-12
  15022c:	dfc00215 	stw	ra,8(sp)
  150230:	df000115 	stw	fp,4(sp)
  150234:	df000104 	addi	fp,sp,4
  150238:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* check if need to turn the menu on or off */
    if (cur_state == MENU_ON)
  15023c:	e0bfff17 	ldw	r2,-4(fp)
  150240:	1000021e 	bne	r2,zero,15024c <menu_key+0x24>
        /* currently the menu is on, turn it off */
	clear_menu();
  150244:	01508cc0 	call	1508cc <clear_menu>
  150248:	00000106 	br	150250 <menu_key+0x28>
    else
        /* currently the menu is off, turn it on */
	display_menu();
  15024c:	01509040 	call	150904 <display_menu>


    /* all done, return the "opposite" of the current state */
    if (cur_state == MENU_ON)
  150250:	e0bfff17 	ldw	r2,-4(fp)
  150254:	1000021e 	bne	r2,zero,150260 <menu_key+0x38>
        /* state was MENU_ON, change it to MENU_OFF */
        return  MENU_OFF;
  150258:	00800044 	movi	r2,1
  15025c:	00000106 	br	150264 <menu_key+0x3c>
    else
        /* state was MENU_OFF, change it to MENU_ON */
        return  MENU_ON;
  150260:	0005883a 	mov	r2,zero

}
  150264:	e037883a 	mov	sp,fp
  150268:	dfc00117 	ldw	ra,4(sp)
  15026c:	df000017 	ldw	fp,0(sp)
  150270:	dec00204 	addi	sp,sp,8
  150274:	f800283a 	ret

00150278 <menu_up>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_up(enum status cur_state)
{
  150278:	defffd04 	addi	sp,sp,-12
  15027c:	dfc00215 	stw	ra,8(sp)
  150280:	df000115 	stw	fp,4(sp)
  150284:	df000104 	addi	fp,sp,4
  150288:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* go to the previous menu entry */
    previous_entry();
  15028c:	0150a880 	call	150a88 <previous_entry>


    /* return the current state */
    return  cur_state;
  150290:	e0bfff17 	ldw	r2,-4(fp)

}
  150294:	e037883a 	mov	sp,fp
  150298:	dfc00117 	ldw	ra,4(sp)
  15029c:	df000017 	ldw	fp,0(sp)
  1502a0:	dec00204 	addi	sp,sp,8
  1502a4:	f800283a 	ret

001502a8 <menu_down>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_down(enum status cur_state)
{
  1502a8:	defffd04 	addi	sp,sp,-12
  1502ac:	dfc00215 	stw	ra,8(sp)
  1502b0:	df000115 	stw	fp,4(sp)
  1502b4:	df000104 	addi	fp,sp,4
  1502b8:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* go to the next menu entry */
    next_entry();
  1502bc:	0150a180 	call	150a18 <next_entry>


    /* return the current state */
    return  cur_state;
  1502c0:	e0bfff17 	ldw	r2,-4(fp)

}
  1502c4:	e037883a 	mov	sp,fp
  1502c8:	dfc00117 	ldw	ra,4(sp)
  1502cc:	df000017 	ldw	fp,0(sp)
  1502d0:	dec00204 	addi	sp,sp,8
  1502d4:	f800283a 	ret

001502d8 <menu_left>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_left(enum status cur_state)
{
  1502d8:	defffd04 	addi	sp,sp,-12
  1502dc:	dfc00215 	stw	ra,8(sp)
  1502e0:	df000115 	stw	fp,4(sp)
  1502e4:	df000104 	addi	fp,sp,4
  1502e8:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* invoke the <Left> key function for the current menu entry */
    menu_entry_left();
  1502ec:	0150af40 	call	150af4 <menu_entry_left>


    /* return the current state */
    return  cur_state;
  1502f0:	e0bfff17 	ldw	r2,-4(fp)

}
  1502f4:	e037883a 	mov	sp,fp
  1502f8:	dfc00117 	ldw	ra,4(sp)
  1502fc:	df000017 	ldw	fp,0(sp)
  150300:	dec00204 	addi	sp,sp,8
  150304:	f800283a 	ret

00150308 <menu_right>:
   Last Modified:    Mar. 8, 1994

*/

enum status  menu_right(enum status cur_state)
{
  150308:	defffd04 	addi	sp,sp,-12
  15030c:	dfc00215 	stw	ra,8(sp)
  150310:	df000115 	stw	fp,4(sp)
  150314:	df000104 	addi	fp,sp,4
  150318:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* invoke the <Right> key function for the current menu entry */
    menu_entry_right();
  15031c:	0150b940 	call	150b94 <menu_entry_right>


    /* return the current state */
    return  cur_state;
  150320:	e0bfff17 	ldw	r2,-4(fp)

}
  150324:	e037883a 	mov	sp,fp
  150328:	dfc00117 	ldw	ra,4(sp)
  15032c:	df000017 	ldw	fp,0(sp)
  150330:	dec00204 	addi	sp,sp,8
  150334:	f800283a 	ret

00150338 <clear_region>:
   Last Modified:    Mar. 8, 1994

*/

void  clear_region(int x_ul, int y_ul, int x_size, int y_size)
{
  150338:	defff804 	addi	sp,sp,-32
  15033c:	dfc00715 	stw	ra,28(sp)
  150340:	df000615 	stw	fp,24(sp)
  150344:	df000604 	addi	fp,sp,24
  150348:	e13ffc15 	stw	r4,-16(fp)
  15034c:	e17ffd15 	stw	r5,-12(fp)
  150350:	e1bffe15 	stw	r6,-8(fp)
  150354:	e1ffff15 	stw	r7,-4(fp)
    int  y;		/* y coordinate to clear */



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
  150358:	e0bffc17 	ldw	r2,-16(fp)
  15035c:	e0bffa15 	stw	r2,-24(fp)
  150360:	00001406 	br	1503b4 <clear_region+0x7c>
        for (y = y_ul; y < (y_ul + y_size); y++)  {
  150364:	e0bffd17 	ldw	r2,-12(fp)
  150368:	e0bffb15 	stw	r2,-20(fp)
  15036c:	00000906 	br	150394 <clear_region+0x5c>

	    /* clear this pixel */
	    plot_pixel(x, y, PIXEL_WHITE);
  150370:	e0fffa17 	ldw	r3,-24(fp)
  150374:	e0bffb17 	ldw	r2,-20(fp)
  150378:	1809883a 	mov	r4,r3
  15037c:	100b883a 	mov	r5,r2
  150380:	000d883a 	mov	r6,zero
  150384:	0151a0c0 	call	151a0c <plot_pixel>



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
        for (y = y_ul; y < (y_ul + y_size); y++)  {
  150388:	e0bffb17 	ldw	r2,-20(fp)
  15038c:	10800044 	addi	r2,r2,1
  150390:	e0bffb15 	stw	r2,-20(fp)
  150394:	e0fffd17 	ldw	r3,-12(fp)
  150398:	e0bfff17 	ldw	r2,-4(fp)
  15039c:	1885883a 	add	r2,r3,r2
  1503a0:	e0fffb17 	ldw	r3,-20(fp)
  1503a4:	18bff216 	blt	r3,r2,150370 <clear_region+0x38>
    int  y;		/* y coordinate to clear */



    /* loop, clearing the display */
    for (x = x_ul; x < (x_ul + x_size); x++)  {
  1503a8:	e0bffa17 	ldw	r2,-24(fp)
  1503ac:	10800044 	addi	r2,r2,1
  1503b0:	e0bffa15 	stw	r2,-24(fp)
  1503b4:	e0fffc17 	ldw	r3,-16(fp)
  1503b8:	e0bffe17 	ldw	r2,-8(fp)
  1503bc:	1885883a 	add	r2,r3,r2
  1503c0:	e0fffa17 	ldw	r3,-24(fp)
  1503c4:	18bfe716 	blt	r3,r2,150364 <clear_region+0x2c>
        }
    }


    /* done clearing the display region - return */
    return;
  1503c8:	0001883a 	nop

}
  1503cc:	e037883a 	mov	sp,fp
  1503d0:	dfc00117 	ldw	ra,4(sp)
  1503d4:	df000017 	ldw	fp,0(sp)
  1503d8:	dec00204 	addi	sp,sp,8
  1503dc:	f800283a 	ret

001503e0 <plot_hline>:
   Last Modified:    Mar. 7, 1994

*/

void  plot_hline(int start_x, int start_y, int length)
{
  1503e0:	defff804 	addi	sp,sp,-32
  1503e4:	dfc00715 	stw	ra,28(sp)
  1503e8:	df000615 	stw	fp,24(sp)
  1503ec:	df000604 	addi	fp,sp,24
  1503f0:	e13ffd15 	stw	r4,-12(fp)
  1503f4:	e17ffe15 	stw	r5,-8(fp)
  1503f8:	e1bfff15 	stw	r6,-4(fp)
    int  end_x;		/* ending x position to plot */



    /* check if a line to the "right" or "left" */
    if (length > 0)  {
  1503fc:	e0bfff17 	ldw	r2,-4(fp)
  150400:	0080070e 	bge	zero,r2,150420 <plot_hline+0x40>

        /* line to the "right" - start at start_x, end at start_x + length */
	init_x = start_x;
  150404:	e0bffd17 	ldw	r2,-12(fp)
  150408:	e0bffb15 	stw	r2,-20(fp)
	end_x = start_x + length;
  15040c:	e0fffd17 	ldw	r3,-12(fp)
  150410:	e0bfff17 	ldw	r2,-4(fp)
  150414:	1885883a 	add	r2,r3,r2
  150418:	e0bffc15 	stw	r2,-16(fp)
  15041c:	00000606 	br	150438 <plot_hline+0x58>
    }
    else  {

        /* line to the "left" - start at start_x + length, end at start_x */
	init_x = start_x + length;
  150420:	e0fffd17 	ldw	r3,-12(fp)
  150424:	e0bfff17 	ldw	r2,-4(fp)
  150428:	1885883a 	add	r2,r3,r2
  15042c:	e0bffb15 	stw	r2,-20(fp)
	end_x = start_x;
  150430:	e0bffd17 	ldw	r2,-12(fp)
  150434:	e0bffc15 	stw	r2,-16(fp)
    }


    /* loop, outputting points for the line (always draw to the "right") */
    for (x = init_x; x < end_x; x++)
  150438:	e0bffb17 	ldw	r2,-20(fp)
  15043c:	e0bffa15 	stw	r2,-24(fp)
  150440:	00000906 	br	150468 <plot_hline+0x88>
        /* plot a point of the line */
	plot_pixel(x, start_y, PIXEL_BLACK);
  150444:	e0fffa17 	ldw	r3,-24(fp)
  150448:	e0bffe17 	ldw	r2,-8(fp)
  15044c:	1809883a 	mov	r4,r3
  150450:	100b883a 	mov	r5,r2
  150454:	01800044 	movi	r6,1
  150458:	0151a0c0 	call	151a0c <plot_pixel>
	end_x = start_x;
    }


    /* loop, outputting points for the line (always draw to the "right") */
    for (x = init_x; x < end_x; x++)
  15045c:	e0bffa17 	ldw	r2,-24(fp)
  150460:	10800044 	addi	r2,r2,1
  150464:	e0bffa15 	stw	r2,-24(fp)
  150468:	e0fffa17 	ldw	r3,-24(fp)
  15046c:	e0bffc17 	ldw	r2,-16(fp)
  150470:	18bff416 	blt	r3,r2,150444 <plot_hline+0x64>
        /* plot a point of the line */
	plot_pixel(x, start_y, PIXEL_BLACK);


    /* done plotting the line - return */
    return;
  150474:	0001883a 	nop

}
  150478:	e037883a 	mov	sp,fp
  15047c:	dfc00117 	ldw	ra,4(sp)
  150480:	df000017 	ldw	fp,0(sp)
  150484:	dec00204 	addi	sp,sp,8
  150488:	f800283a 	ret

0015048c <plot_vline>:
   Last Modified:    Mar. 7, 1994

*/

void  plot_vline(int start_x, int start_y, int length)
{
  15048c:	defff804 	addi	sp,sp,-32
  150490:	dfc00715 	stw	ra,28(sp)
  150494:	df000615 	stw	fp,24(sp)
  150498:	df000604 	addi	fp,sp,24
  15049c:	e13ffd15 	stw	r4,-12(fp)
  1504a0:	e17ffe15 	stw	r5,-8(fp)
  1504a4:	e1bfff15 	stw	r6,-4(fp)
    int  end_y;		/* ending y position to plot */



    /* check if an "up" or "down" line */
    if (length > 0)  {
  1504a8:	e0bfff17 	ldw	r2,-4(fp)
  1504ac:	0080070e 	bge	zero,r2,1504cc <plot_vline+0x40>

        /* line going "down" - start at start_y, end at start_y + length */
	init_y = start_y;
  1504b0:	e0bffe17 	ldw	r2,-8(fp)
  1504b4:	e0bffb15 	stw	r2,-20(fp)
	end_y = start_y + length;
  1504b8:	e0fffe17 	ldw	r3,-8(fp)
  1504bc:	e0bfff17 	ldw	r2,-4(fp)
  1504c0:	1885883a 	add	r2,r3,r2
  1504c4:	e0bffc15 	stw	r2,-16(fp)
  1504c8:	00000606 	br	1504e4 <plot_vline+0x58>
    }
    else  {

        /* line going "up" - start at start_y + length, end at start_y */
	init_y = start_y + length;
  1504cc:	e0fffe17 	ldw	r3,-8(fp)
  1504d0:	e0bfff17 	ldw	r2,-4(fp)
  1504d4:	1885883a 	add	r2,r3,r2
  1504d8:	e0bffb15 	stw	r2,-20(fp)
	end_y = start_y;
  1504dc:	e0bffe17 	ldw	r2,-8(fp)
  1504e0:	e0bffc15 	stw	r2,-16(fp)
    }


    /* loop, outputting points for the line (always draw "down") */
    for (y = init_y; y < end_y; y++)
  1504e4:	e0bffb17 	ldw	r2,-20(fp)
  1504e8:	e0bffa15 	stw	r2,-24(fp)
  1504ec:	00000906 	br	150514 <plot_vline+0x88>
        /* plot a point of the line */
	plot_pixel(start_x, y, PIXEL_BLACK);
  1504f0:	e0fffd17 	ldw	r3,-12(fp)
  1504f4:	e0bffa17 	ldw	r2,-24(fp)
  1504f8:	1809883a 	mov	r4,r3
  1504fc:	100b883a 	mov	r5,r2
  150500:	01800044 	movi	r6,1
  150504:	0151a0c0 	call	151a0c <plot_pixel>
	end_y = start_y;
    }


    /* loop, outputting points for the line (always draw "down") */
    for (y = init_y; y < end_y; y++)
  150508:	e0bffa17 	ldw	r2,-24(fp)
  15050c:	10800044 	addi	r2,r2,1
  150510:	e0bffa15 	stw	r2,-24(fp)
  150514:	e0fffa17 	ldw	r3,-24(fp)
  150518:	e0bffc17 	ldw	r2,-16(fp)
  15051c:	18bff416 	blt	r3,r2,1504f0 <plot_vline+0x64>
        /* plot a point of the line */
	plot_pixel(start_x, y, PIXEL_BLACK);


    /* done plotting the line - return */
    return;
  150520:	0001883a 	nop

}
  150524:	e037883a 	mov	sp,fp
  150528:	dfc00117 	ldw	ra,4(sp)
  15052c:	df000017 	ldw	fp,0(sp)
  150530:	dec00204 	addi	sp,sp,8
  150534:	f800283a 	ret

00150538 <plot_char>:
   Last Modified:    May 27, 2008

*/

void  plot_char(int pos_x, int pos_y, char c, enum char_style style)
{
  150538:	defff504 	addi	sp,sp,-44
  15053c:	dfc00a15 	stw	ra,40(sp)
  150540:	df000915 	stw	fp,36(sp)
  150544:	df000904 	addi	fp,sp,36
  150548:	e13ffc15 	stw	r4,-16(fp)
  15054c:	e17ffd15 	stw	r5,-12(fp)
  150550:	3005883a 	mov	r2,r6
  150554:	e1ffff15 	stw	r7,-4(fp)
  150558:	e0bffe05 	stb	r2,-8(fp)
    int  y;		/* y pixel position for the character */



    /* setup the pixel positions for the character */
    x = pos_x * HORIZ_SIZE;
  15055c:	e0bffc17 	ldw	r2,-16(fp)
  150560:	108001a4 	muli	r2,r2,6
  150564:	e0bffb15 	stw	r2,-20(fp)
    y = pos_y * VERT_SIZE;
  150568:	e0bffd17 	ldw	r2,-12(fp)
  15056c:	100490fa 	slli	r2,r2,3
  150570:	e0bffa15 	stw	r2,-24(fp)


    /* loop outputting the bits to the screen */
    for (row = 0; row < VERT_SIZE; row++)  {
  150574:	e03ff915 	stw	zero,-28(fp)
  150578:	00004006 	br	15067c <plot_char+0x144>

        /* get the character bits for this row from the character table */
	if (row == (VERT_SIZE - 1))
  15057c:	e0bff917 	ldw	r2,-28(fp)
  150580:	108001d8 	cmpnei	r2,r2,7
  150584:	1000021e 	bne	r2,zero,150590 <plot_char+0x58>
	    /* last row - blank it */
	    bits = 0;
  150588:	e03ff715 	stw	zero,-36(fp)
  15058c:	00000a06 	br	1505b8 <plot_char+0x80>
	else
	    /* in middle of character, get the row from the bit patterns */
            bits = char_patterns[(c * (VERT_SIZE - 1)) + row];
  150590:	e0bffe07 	ldb	r2,-8(fp)
  150594:	10c001e4 	muli	r3,r2,7
  150598:	e0bff917 	ldw	r2,-28(fp)
  15059c:	1885883a 	add	r2,r3,r2
  1505a0:	00c00574 	movhi	r3,21
  1505a4:	18d3a604 	addi	r3,r3,20120
  1505a8:	1885883a 	add	r2,r3,r2
  1505ac:	10800003 	ldbu	r2,0(r2)
  1505b0:	10803fcc 	andi	r2,r2,255
  1505b4:	e0bff715 	stw	r2,-36(fp)

	/* take care of "normal/reverse video" */
	if (style == REVERSE)
  1505b8:	e0bfff17 	ldw	r2,-4(fp)
  1505bc:	10800058 	cmpnei	r2,r2,1
  1505c0:	1000031e 	bne	r2,zero,1505d0 <plot_char+0x98>
	    /* invert the bits for "reverse video" */
	    bits = ~bits;
  1505c4:	e0bff717 	ldw	r2,-36(fp)
  1505c8:	0084303a 	nor	r2,zero,r2
  1505cc:	e0bff715 	stw	r2,-36(fp)

        /* get the bits "in position" (high bit is output first */
	bits <<= (8 - HORIZ_SIZE);
  1505d0:	e0bff717 	ldw	r2,-36(fp)
  1505d4:	1085883a 	add	r2,r2,r2
  1505d8:	1085883a 	add	r2,r2,r2
  1505dc:	e0bff715 	stw	r2,-36(fp)


	/* now output the row of the character, pixel by pixel */
	for (col = 0; col < HORIZ_SIZE; col++)  {
  1505e0:	e03ff815 	stw	zero,-32(fp)
  1505e4:	00001c06 	br	150658 <plot_char+0x120>

            /* output this pixel in the appropriate color */
	    if ((bits & 0x80) == 0)
  1505e8:	e0bff717 	ldw	r2,-36(fp)
  1505ec:	1080200c 	andi	r2,r2,128
  1505f0:	10000a1e 	bne	r2,zero,15061c <plot_char+0xe4>
	        /* blank pixel - output in PIXEL_WHITE */
		plot_pixel(x + col, y, PIXEL_WHITE);
  1505f4:	e0fffb17 	ldw	r3,-20(fp)
  1505f8:	e0bff817 	ldw	r2,-32(fp)
  1505fc:	1885883a 	add	r2,r3,r2
  150600:	1007883a 	mov	r3,r2
  150604:	e0bffa17 	ldw	r2,-24(fp)
  150608:	1809883a 	mov	r4,r3
  15060c:	100b883a 	mov	r5,r2
  150610:	000d883a 	mov	r6,zero
  150614:	0151a0c0 	call	151a0c <plot_pixel>
  150618:	00000906 	br	150640 <plot_char+0x108>
	    else
	        /* black pixel - output in PIXEL_BLACK */
		plot_pixel(x + col, y, PIXEL_BLACK);
  15061c:	e0fffb17 	ldw	r3,-20(fp)
  150620:	e0bff817 	ldw	r2,-32(fp)
  150624:	1885883a 	add	r2,r3,r2
  150628:	1007883a 	mov	r3,r2
  15062c:	e0bffa17 	ldw	r2,-24(fp)
  150630:	1809883a 	mov	r4,r3
  150634:	100b883a 	mov	r5,r2
  150638:	01800044 	movi	r6,1
  15063c:	0151a0c0 	call	151a0c <plot_pixel>

	    /* shift the next bit into position */
	    bits <<= 1;
  150640:	e0bff717 	ldw	r2,-36(fp)
  150644:	1085883a 	add	r2,r2,r2
  150648:	e0bff715 	stw	r2,-36(fp)
        /* get the bits "in position" (high bit is output first */
	bits <<= (8 - HORIZ_SIZE);


	/* now output the row of the character, pixel by pixel */
	for (col = 0; col < HORIZ_SIZE; col++)  {
  15064c:	e0bff817 	ldw	r2,-32(fp)
  150650:	10800044 	addi	r2,r2,1
  150654:	e0bff815 	stw	r2,-32(fp)
  150658:	e0bff817 	ldw	r2,-32(fp)
  15065c:	10800190 	cmplti	r2,r2,6
  150660:	103fe11e 	bne	r2,zero,1505e8 <plot_char+0xb0>
	    bits <<= 1;
        }


	/* next row - update the y position */
	y++;
  150664:	e0bffa17 	ldw	r2,-24(fp)
  150668:	10800044 	addi	r2,r2,1
  15066c:	e0bffa15 	stw	r2,-24(fp)
    x = pos_x * HORIZ_SIZE;
    y = pos_y * VERT_SIZE;


    /* loop outputting the bits to the screen */
    for (row = 0; row < VERT_SIZE; row++)  {
  150670:	e0bff917 	ldw	r2,-28(fp)
  150674:	10800044 	addi	r2,r2,1
  150678:	e0bff915 	stw	r2,-28(fp)
  15067c:	e0bff917 	ldw	r2,-28(fp)
  150680:	10800210 	cmplti	r2,r2,8
  150684:	103fbd1e 	bne	r2,zero,15057c <plot_char+0x44>
	y++;
    }


    /* all done, return */
    return;
  150688:	0001883a 	nop

}
  15068c:	e037883a 	mov	sp,fp
  150690:	dfc00117 	ldw	ra,4(sp)
  150694:	df000017 	ldw	fp,0(sp)
  150698:	dec00204 	addi	sp,sp,8
  15069c:	f800283a 	ret

001506a0 <plot_string>:
   Last Modified:    Mar. 17, 1997

*/

void  plot_string(int pos_x, int pos_y, const char *s, enum char_style style)
{
  1506a0:	defffa04 	addi	sp,sp,-24
  1506a4:	dfc00515 	stw	ra,20(sp)
  1506a8:	df000415 	stw	fp,16(sp)
  1506ac:	df000404 	addi	fp,sp,16
  1506b0:	e13ffc15 	stw	r4,-16(fp)
  1506b4:	e17ffd15 	stw	r5,-12(fp)
  1506b8:	e1bffe15 	stw	r6,-8(fp)
  1506bc:	e1ffff15 	stw	r7,-4(fp)
      /* none */



    /* loop, outputting characters from string s */
    while (*s != '\0')
  1506c0:	00001106 	br	150708 <plot_string+0x68>

        /* output this character and move to the next character and screen position */
	plot_char(pos_x++, pos_y, *s++, style);
  1506c4:	e0fffc17 	ldw	r3,-16(fp)
  1506c8:	e0bffc17 	ldw	r2,-16(fp)
  1506cc:	10800044 	addi	r2,r2,1
  1506d0:	e0bffc15 	stw	r2,-16(fp)
  1506d4:	e0bffe17 	ldw	r2,-8(fp)
  1506d8:	10800003 	ldbu	r2,0(r2)
  1506dc:	10803fcc 	andi	r2,r2,255
  1506e0:	1080201c 	xori	r2,r2,128
  1506e4:	10bfe004 	addi	r2,r2,-128
  1506e8:	e13ffe17 	ldw	r4,-8(fp)
  1506ec:	21000044 	addi	r4,r4,1
  1506f0:	e13ffe15 	stw	r4,-8(fp)
  1506f4:	1809883a 	mov	r4,r3
  1506f8:	e17ffd17 	ldw	r5,-12(fp)
  1506fc:	100d883a 	mov	r6,r2
  150700:	e1ffff17 	ldw	r7,-4(fp)
  150704:	01505380 	call	150538 <plot_char>
      /* none */



    /* loop, outputting characters from string s */
    while (*s != '\0')
  150708:	e0bffe17 	ldw	r2,-8(fp)
  15070c:	10800003 	ldbu	r2,0(r2)
  150710:	10803fcc 	andi	r2,r2,255
  150714:	1080201c 	xori	r2,r2,128
  150718:	10bfe004 	addi	r2,r2,-128
  15071c:	103fe91e 	bne	r2,zero,1506c4 <plot_string+0x24>
        /* output this character and move to the next character and screen position */
	plot_char(pos_x++, pos_y, *s++, style);


    /* all done, return */
    return;
  150720:	0001883a 	nop

}
  150724:	e037883a 	mov	sp,fp
  150728:	dfc00117 	ldw	ra,4(sp)
  15072c:	df000017 	ldw	fp,0(sp)
  150730:	dec00204 	addi	sp,sp,8
  150734:	f800283a 	ret

00150738 <main>:
   Last Modified:    May 27, 2008

*/

int  main()
{
  150738:	defffb04 	addi	sp,sp,-20
  15073c:	dfc00415 	stw	ra,16(sp)
  150740:	df000315 	stw	fp,12(sp)
  150744:	df000304 	addi	fp,sp,12
    /* variables */
    enum keycode        key;		    /* an input key */

    enum status
    state = MENU_ON;    /* current program state */
  150748:	e03ffd15 	stw	zero,-12(fp)
        {  no_action,   no_action   } }; /* illegal key */



    /* first initialize everything */
    clear_display();		/* clear the display */
  15074c:	01519ec0 	call	1519ec <clear_display>

    init_trace();		/* initialize the trace routines */
  150750:	0151c180 	call	151c18 <init_trace>
    init_menu();		/* initialize the menu system */
  150754:	01508680 	call	150868 <init_menu>
  150758:	00000106 	br	150760 <main+0x28>
	    key = key_lookup();

	    /* execute processing routine for that key */
	    state = process_key[key][state](state);
	}
    }
  15075c:	0001883a 	nop

    /* infinite loop processing input */
    while(TRUE)  {

        /* check if ready to do a trace */
	if (trace_rdy())
  150760:	0151cd40 	call	151cd4 <trace_rdy>
  150764:	10000126 	beq	r2,zero,15076c <main+0x34>
	    /* ready for a trace - do it */
	    do_trace();
  150768:	01525e00 	call	1525e0 <do_trace>


	/* check if have a trace to display */
	if (is_sampling() && ((sample = sample_done()) != NULL))  {
  15076c:	0151cb40 	call	151cb4 <is_sampling>
  150770:	10000726 	beq	r2,zero,150790 <main+0x58>
  150774:	0151acc0 	call	151acc <sample_done>
  150778:	e0bffe15 	stw	r2,-8(fp)
  15077c:	e0bffe17 	ldw	r2,-8(fp)
  150780:	10000326 	beq	r2,zero,150790 <main+0x58>

	    /* have a trace - output it */
	    plot_trace(sample);
  150784:	e13ffe17 	ldw	r4,-8(fp)
  150788:	01526280 	call	152628 <plot_trace>
	    /* done processing this trace */
	    trace_done();
  15078c:	0151d0c0 	call	151d0c <trace_done>
	}


	/* now check for keypad input */
	if (key_available())  {
  150790:	0152b780 	call	152b78 <key_available>
  150794:	10803fcc 	andi	r2,r2,255
  150798:	103ff026 	beq	r2,zero,15075c <main+0x24>

	    /* have keypad input - get the key */
	    key = key_lookup();
  15079c:	01507dc0 	call	1507dc <key_lookup>
  1507a0:	e0bfff15 	stw	r2,-4(fp)

	    /* execute processing routine for that key */
	    state = process_key[key][state](state);
  1507a4:	00c00574 	movhi	r3,21
  1507a8:	18d4b104 	addi	r3,r3,21188
  1507ac:	e0bfff17 	ldw	r2,-4(fp)
  1507b0:	1089883a 	add	r4,r2,r2
  1507b4:	e0bffd17 	ldw	r2,-12(fp)
  1507b8:	2085883a 	add	r2,r4,r2
  1507bc:	1085883a 	add	r2,r2,r2
  1507c0:	1085883a 	add	r2,r2,r2
  1507c4:	1885883a 	add	r2,r3,r2
  1507c8:	10800017 	ldw	r2,0(r2)
  1507cc:	e13ffd17 	ldw	r4,-12(fp)
  1507d0:	103ee83a 	callr	r2
  1507d4:	e0bffd15 	stw	r2,-12(fp)
	}
    }
  1507d8:	003fe006 	br	15075c <main+0x24>

001507dc <key_lookup>:
   Last Modified:    Mar. 17, 1997

*/

static  enum keycode  key_lookup()
{
  1507dc:	defffc04 	addi	sp,sp,-16
  1507e0:	dfc00315 	stw	ra,12(sp)
  1507e4:	df000215 	stw	fp,8(sp)
  1507e8:	df000204 	addi	fp,sp,8
    int  i;           	/* general loop index */



    /* get a key */
    key = getkey();
  1507ec:	0152b640 	call	152b64 <getkey>
  1507f0:	e0bfff15 	stw	r2,-4(fp)


    /* lookup key in keys array */
    for (i = 0; ((i < (sizeof(keys)/sizeof(int))) && (key != keys[i])); i++);
  1507f4:	e03ffe15 	stw	zero,-8(fp)
  1507f8:	00000306 	br	150808 <key_lookup+0x2c>
  1507fc:	e0bffe17 	ldw	r2,-8(fp)
  150800:	10800044 	addi	r2,r2,1
  150804:	e0bffe15 	stw	r2,-8(fp)
  150808:	e0bffe17 	ldw	r2,-8(fp)
  15080c:	10800168 	cmpgeui	r2,r2,5
  150810:	1000091e 	bne	r2,zero,150838 <key_lookup+0x5c>
  150814:	00c00574 	movhi	r3,21
  150818:	18d4a604 	addi	r3,r3,21144
  15081c:	e0bffe17 	ldw	r2,-8(fp)
  150820:	1085883a 	add	r2,r2,r2
  150824:	1085883a 	add	r2,r2,r2
  150828:	1885883a 	add	r2,r3,r2
  15082c:	10c00017 	ldw	r3,0(r2)
  150830:	e0bfff17 	ldw	r2,-4(fp)
  150834:	18bff11e 	bne	r3,r2,1507fc <key_lookup+0x20>


    /* return the appropriate key type */
    return  keycodes[i];
  150838:	00c00574 	movhi	r3,21
  15083c:	18d4ab04 	addi	r3,r3,21164
  150840:	e0bffe17 	ldw	r2,-8(fp)
  150844:	1085883a 	add	r2,r2,r2
  150848:	1085883a 	add	r2,r2,r2
  15084c:	1885883a 	add	r2,r3,r2
  150850:	10800017 	ldw	r2,0(r2)

}
  150854:	e037883a 	mov	sp,fp
  150858:	dfc00117 	ldw	ra,4(sp)
  15085c:	df000017 	ldw	fp,0(sp)
  150860:	dec00204 	addi	sp,sp,8
  150864:	f800283a 	ret

00150868 <init_menu>:
   Last Modified:    Mar. 17, 1997

*/

void  init_menu(void)
{
  150868:	defffe04 	addi	sp,sp,-8
  15086c:	dfc00115 	stw	ra,4(sp)
  150870:	df000015 	stw	fp,0(sp)
  150874:	d839883a 	mov	fp,sp
      /* none */



    /* set the menu parameters */
    menu_entry = 0;		/* first menu entry */
  150878:	d0259e15 	stw	zero,-27016(gp)
    menu_display = FALSE;	/* menu is not currently displayed (but it will be shortly) */
  15087c:	d0259d15 	stw	zero,-27020(gp)


    /* set the scope (option) parameters */
    set_trigger_mode(NORMAL_TRIGGER);	/* normal triggering */
  150880:	0009883a 	mov	r4,zero
  150884:	0150d500 	call	150d50 <set_trigger_mode>
    set_scale(SCALE_AXES);		/* scale is axes */
  150888:	01000044 	movi	r4,1
  15088c:	0150ee00 	call	150ee0 <set_scale>
    set_sweep(0);			/* first sweep rate */
  150890:	0009883a 	mov	r4,zero
  150894:	01510500 	call	151050 <set_sweep>
    set_trg_level((MIN_TRG_LEVEL_SET + MAX_TRG_LEVEL_SET) / 2);	/* middle trigger level */
  150898:	01000fc4 	movi	r4,63
  15089c:	015121c0 	call	15121c <set_trg_level>
    set_trg_slope(SLOPE_POSITIVE);	/* positive slope */
  1508a0:	0009883a 	mov	r4,zero
  1508a4:	01513a40 	call	1513a4 <set_trg_slope>
    set_trg_delay(MIN_DELAY);		/* minimum delay */
  1508a8:	0009883a 	mov	r4,zero
  1508ac:	01514a40 	call	1514a4 <set_trg_delay>


    /* now display the menu */
    display_menu();
  1508b0:	01509040 	call	150904 <display_menu>


    /* done initializing, return */
    return;
  1508b4:	0001883a 	nop

}
  1508b8:	e037883a 	mov	sp,fp
  1508bc:	dfc00117 	ldw	ra,4(sp)
  1508c0:	df000017 	ldw	fp,0(sp)
  1508c4:	dec00204 	addi	sp,sp,8
  1508c8:	f800283a 	ret

001508cc <clear_menu>:
   Last Modified:    Mar. 13, 1994

*/

void  clear_menu(void)
{
  1508cc:	defffe04 	addi	sp,sp,-8
  1508d0:	dfc00115 	stw	ra,4(sp)
  1508d4:	df000015 	stw	fp,0(sp)
  1508d8:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
  1508dc:	d0a59d17 	ldw	r2,-27020(gp)
  1508e0:	10000126 	beq	r2,zero,1508e8 <clear_menu+0x1c>

        /* menu is being displayed - turn it off and restore the trace in that area */
	restore_menu_trace();
  1508e4:	015230c0 	call	15230c <restore_menu_trace>
    }


    /* no longer displaying the menu */
    menu_display = FALSE;
  1508e8:	d0259d15 	stw	zero,-27020(gp)


    /* all done, return */
    return;
  1508ec:	0001883a 	nop

}
  1508f0:	e037883a 	mov	sp,fp
  1508f4:	dfc00117 	ldw	ra,4(sp)
  1508f8:	df000017 	ldw	fp,0(sp)
  1508fc:	dec00204 	addi	sp,sp,8
  150900:	f800283a 	ret

00150904 <display_menu>:
   Last Modified:    Mar. 13, 1994

*/

void  display_menu(void)
{
  150904:	defffd04 	addi	sp,sp,-12
  150908:	dfc00215 	stw	ra,8(sp)
  15090c:	df000115 	stw	fp,4(sp)
  150910:	df000104 	addi	fp,sp,4
    int  i;		/* loop index */



    /* check if the menu is currently being displayed */
    if (!menu_display)  {
  150914:	d0a59d17 	ldw	r2,-27020(gp)
  150918:	1000121e 	bne	r2,zero,150964 <display_menu+0x60>

        /* menu is not being displayed - turn it on */
	/* display it entry by entry */
	for (i = 0; i < NO_MENU_ENTRIES; i++)  {
  15091c:	e03fff15 	stw	zero,-4(fp)
  150920:	00000d06 	br	150958 <display_menu+0x54>

	    /* display this entry - check if it should be highlighted */
	    if (i == menu_entry)
  150924:	d0a59e17 	ldw	r2,-27016(gp)
  150928:	e0ffff17 	ldw	r3,-4(fp)
  15092c:	1880041e 	bne	r3,r2,150940 <display_menu+0x3c>
	        /* currently selected entry - highlight it */
	        display_entry(i, TRUE);
  150930:	e13fff17 	ldw	r4,-4(fp)
  150934:	01400044 	movi	r5,1
  150938:	0150c340 	call	150c34 <display_entry>
  15093c:	00000306 	br	15094c <display_menu+0x48>
	    else
	        /* not the currently selected entry - "normal video" */
	        display_entry(i, FALSE);
  150940:	e13fff17 	ldw	r4,-4(fp)
  150944:	000b883a 	mov	r5,zero
  150948:	0150c340 	call	150c34 <display_entry>
    /* check if the menu is currently being displayed */
    if (!menu_display)  {

        /* menu is not being displayed - turn it on */
	/* display it entry by entry */
	for (i = 0; i < NO_MENU_ENTRIES; i++)  {
  15094c:	e0bfff17 	ldw	r2,-4(fp)
  150950:	10800044 	addi	r2,r2,1
  150954:	e0bfff15 	stw	r2,-4(fp)
  150958:	e0bfff17 	ldw	r2,-4(fp)
  15095c:	108001f0 	cmpltui	r2,r2,7
  150960:	103ff01e 	bne	r2,zero,150924 <display_menu+0x20>
        }
    }


    /* now are displaying the menu */
    menu_display = TRUE;
  150964:	00800044 	movi	r2,1
  150968:	d0a59d15 	stw	r2,-27020(gp)


    /* all done, return */
    return;
  15096c:	0001883a 	nop

}
  150970:	e037883a 	mov	sp,fp
  150974:	dfc00117 	ldw	ra,4(sp)
  150978:	df000017 	ldw	fp,0(sp)
  15097c:	dec00204 	addi	sp,sp,8
  150980:	f800283a 	ret

00150984 <refresh_menu>:
   Last Modified:    Mar. 8, 1994

*/

void  refresh_menu(void)
{
  150984:	defffe04 	addi	sp,sp,-8
  150988:	dfc00115 	stw	ra,4(sp)
  15098c:	df000015 	stw	fp,0(sp)
  150990:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
  150994:	d0a59d17 	ldw	r2,-27020(gp)
  150998:	10000226 	beq	r2,zero,1509a4 <refresh_menu+0x20>

    	/* menu is currently being displayed - need to refresh it */
	/* do this by turning off the display, then forcing it back on */
	menu_display = FALSE;
  15099c:	d0259d15 	stw	zero,-27020(gp)
	display_menu();
  1509a0:	01509040 	call	150904 <display_menu>
    }


    /* refreshed the menu if it was displayed, now return */
    return;
  1509a4:	0001883a 	nop

}
  1509a8:	e037883a 	mov	sp,fp
  1509ac:	dfc00117 	ldw	ra,4(sp)
  1509b0:	df000017 	ldw	fp,0(sp)
  1509b4:	dec00204 	addi	sp,sp,8
  1509b8:	f800283a 	ret

001509bc <reset_menu>:
   Last Modified:    Mar. 17, 1997

*/

void  reset_menu(void)
{
  1509bc:	defffe04 	addi	sp,sp,-8
  1509c0:	dfc00115 	stw	ra,4(sp)
  1509c4:	df000015 	stw	fp,0(sp)
  1509c8:	d839883a 	mov	fp,sp
      /* none */



    /* check if the menu is currently being displayed */
    if (menu_display)  {
  1509cc:	d0a59d17 	ldw	r2,-27020(gp)
  1509d0:	10000426 	beq	r2,zero,1509e4 <reset_menu+0x28>

        /* menu is being displayed */
	/* remove highlight from currently selected entry */
	display_entry(menu_entry, FALSE);
  1509d4:	d0a59e17 	ldw	r2,-27016(gp)
  1509d8:	1009883a 	mov	r4,r2
  1509dc:	000b883a 	mov	r5,zero
  1509e0:	0150c340 	call	150c34 <display_entry>
    }


    /* reset the currently selected entry */
    menu_entry = 0;
  1509e4:	d0259e15 	stw	zero,-27016(gp)


    /* finally, highlight the first entry if the menu is being displayed */
    if (menu_display)
  1509e8:	d0a59d17 	ldw	r2,-27020(gp)
  1509ec:	10000426 	beq	r2,zero,150a00 <reset_menu+0x44>
	display_entry(menu_entry, TRUE);
  1509f0:	d0a59e17 	ldw	r2,-27016(gp)
  1509f4:	1009883a 	mov	r4,r2
  1509f8:	01400044 	movi	r5,1
  1509fc:	0150c340 	call	150c34 <display_entry>



    /* all done, return */
    return;
  150a00:	0001883a 	nop

}
  150a04:	e037883a 	mov	sp,fp
  150a08:	dfc00117 	ldw	ra,4(sp)
  150a0c:	df000017 	ldw	fp,0(sp)
  150a10:	dec00204 	addi	sp,sp,8
  150a14:	f800283a 	ret

00150a18 <next_entry>:
   Last Modified:    Mar. 13, 1994

*/

void  next_entry(void)
{
  150a18:	defffe04 	addi	sp,sp,-8
  150a1c:	dfc00115 	stw	ra,4(sp)
  150a20:	df000015 	stw	fp,0(sp)
  150a24:	d839883a 	mov	fp,sp
      /* none */



    /* only update if not at end of the menu */
    if (menu_entry < (NO_MENU_ENTRIES - 1))  {
  150a28:	d0a59e17 	ldw	r2,-27016(gp)
  150a2c:	108001a8 	cmpgeui	r2,r2,6
  150a30:	10000f1e 	bne	r2,zero,150a70 <next_entry+0x58>

        /* not at the end of the menu */

	/* turn off current entry if displaying */
	if (menu_display)
  150a34:	d0a59d17 	ldw	r2,-27020(gp)
  150a38:	10000426 	beq	r2,zero,150a4c <next_entry+0x34>
            /* displaying menu - turn off currently selected entry */
	    display_entry(menu_entry, FALSE);
  150a3c:	d0a59e17 	ldw	r2,-27016(gp)
  150a40:	1009883a 	mov	r4,r2
  150a44:	000b883a 	mov	r5,zero
  150a48:	0150c340 	call	150c34 <display_entry>

	/* update the menu entry to the next one */
	menu_entry++;
  150a4c:	d0a59e17 	ldw	r2,-27016(gp)
  150a50:	10800044 	addi	r2,r2,1
  150a54:	d0a59e15 	stw	r2,-27016(gp)

	/* now highlight this entry if displaying the menu */
	if (menu_display)
  150a58:	d0a59d17 	ldw	r2,-27020(gp)
  150a5c:	10000426 	beq	r2,zero,150a70 <next_entry+0x58>
            /* displaying menu - highlight newly selected entry */
	    display_entry(menu_entry, TRUE);
  150a60:	d0a59e17 	ldw	r2,-27016(gp)
  150a64:	1009883a 	mov	r4,r2
  150a68:	01400044 	movi	r5,1
  150a6c:	0150c340 	call	150c34 <display_entry>
    }


    /* all done, return */
    return;
  150a70:	0001883a 	nop

}
  150a74:	e037883a 	mov	sp,fp
  150a78:	dfc00117 	ldw	ra,4(sp)
  150a7c:	df000017 	ldw	fp,0(sp)
  150a80:	dec00204 	addi	sp,sp,8
  150a84:	f800283a 	ret

00150a88 <previous_entry>:
   Last Modified:    Mar. 13, 1994

*/

void  previous_entry(void)
{
  150a88:	defffe04 	addi	sp,sp,-8
  150a8c:	dfc00115 	stw	ra,4(sp)
  150a90:	df000015 	stw	fp,0(sp)
  150a94:	d839883a 	mov	fp,sp
      /* none */



    /* only update if not at the start of the menu */
    if (menu_entry > 0)  {
  150a98:	d0a59e17 	ldw	r2,-27016(gp)
  150a9c:	00800f0e 	bge	zero,r2,150adc <previous_entry+0x54>

        /* not at the start of the menu */

	/* turn off current entry if displaying */
	if (menu_display)
  150aa0:	d0a59d17 	ldw	r2,-27020(gp)
  150aa4:	10000426 	beq	r2,zero,150ab8 <previous_entry+0x30>
            /* displaying menu - turn off currently selected entry */
	    display_entry(menu_entry, FALSE);
  150aa8:	d0a59e17 	ldw	r2,-27016(gp)
  150aac:	1009883a 	mov	r4,r2
  150ab0:	000b883a 	mov	r5,zero
  150ab4:	0150c340 	call	150c34 <display_entry>

	/* update the menu entry to the previous one */
	menu_entry--;
  150ab8:	d0a59e17 	ldw	r2,-27016(gp)
  150abc:	10bfffc4 	addi	r2,r2,-1
  150ac0:	d0a59e15 	stw	r2,-27016(gp)

	/* now highlight this entry if displaying the menu */
	if (menu_display)
  150ac4:	d0a59d17 	ldw	r2,-27020(gp)
  150ac8:	10000426 	beq	r2,zero,150adc <previous_entry+0x54>
            /* displaying menu - highlight newly selected entry */
	    display_entry(menu_entry, TRUE);
  150acc:	d0a59e17 	ldw	r2,-27016(gp)
  150ad0:	1009883a 	mov	r4,r2
  150ad4:	01400044 	movi	r5,1
  150ad8:	0150c340 	call	150c34 <display_entry>

    }


    /* all done, return */
    return;
  150adc:	0001883a 	nop

}
  150ae0:	e037883a 	mov	sp,fp
  150ae4:	dfc00117 	ldw	ra,4(sp)
  150ae8:	df000017 	ldw	fp,0(sp)
  150aec:	dec00204 	addi	sp,sp,8
  150af0:	f800283a 	ret

00150af4 <menu_entry_left>:
   Last Modified:    May 9, 2006

*/

void  menu_entry_left(void)
{
  150af4:	defffe04 	addi	sp,sp,-8
  150af8:	dfc00115 	stw	ra,4(sp)
  150afc:	df000015 	stw	fp,0(sp)
  150b00:	d839883a 	mov	fp,sp
       /*  Level           Slope             Delay                        */



    /* invoke the appropriate <Left> key function */
    process[menu_entry]();
  150b04:	d0a59e17 	ldw	r2,-27016(gp)
  150b08:	00c00574 	movhi	r3,21
  150b0c:	18d4ee04 	addi	r3,r3,21432
  150b10:	1085883a 	add	r2,r2,r2
  150b14:	1085883a 	add	r2,r2,r2
  150b18:	1885883a 	add	r2,r3,r2
  150b1c:	10800017 	ldw	r2,0(r2)
  150b20:	103ee83a 	callr	r2

    /* if displaying menu entries, display the new value */
    /* note: since it is being changed - know this option is selected */
    if (menu_display)  {
  150b24:	d0a59d17 	ldw	r2,-27020(gp)
  150b28:	10001426 	beq	r2,zero,150b7c <menu_entry_left+0x88>
        menu[menu_entry].display((MENU_X + menu[menu_entry].opt_off),
  150b2c:	d0a59e17 	ldw	r2,-27016(gp)
  150b30:	00c00574 	movhi	r3,21
  150b34:	18d4cb04 	addi	r3,r3,21292
  150b38:	1004913a 	slli	r2,r2,4
  150b3c:	1885883a 	add	r2,r3,r2
  150b40:	10800304 	addi	r2,r2,12
  150b44:	11c00017 	ldw	r7,0(r2)
  150b48:	d0a59e17 	ldw	r2,-27016(gp)
  150b4c:	00c00574 	movhi	r3,21
  150b50:	18d4cb04 	addi	r3,r3,21292
  150b54:	1004913a 	slli	r2,r2,4
  150b58:	1885883a 	add	r2,r3,r2
  150b5c:	10800204 	addi	r2,r2,8
  150b60:	10800017 	ldw	r2,0(r2)
  150b64:	10c00fc4 	addi	r3,r2,63
  150b68:	d0a59e17 	ldw	r2,-27016(gp)
  150b6c:	1809883a 	mov	r4,r3
  150b70:	100b883a 	mov	r5,r2
  150b74:	000d883a 	mov	r6,zero
  150b78:	383ee83a 	callr	r7
    			         (MENU_Y + menu_entry), OPTION_SELECTED);
    }


    /* all done, return */
    return;
  150b7c:	0001883a 	nop

}
  150b80:	e037883a 	mov	sp,fp
  150b84:	dfc00117 	ldw	ra,4(sp)
  150b88:	df000017 	ldw	fp,0(sp)
  150b8c:	dec00204 	addi	sp,sp,8
  150b90:	f800283a 	ret

00150b94 <menu_entry_right>:
   Last Modified:    May 9, 2006

*/

void  menu_entry_right(void)
{
  150b94:	defffe04 	addi	sp,sp,-8
  150b98:	dfc00115 	stw	ra,4(sp)
  150b9c:	df000015 	stw	fp,0(sp)
  150ba0:	d839883a 	mov	fp,sp
       /*  Level         Slope             Delay                        */



    /* invoke the appropriate <Right> key function */
    process[menu_entry]();
  150ba4:	d0a59e17 	ldw	r2,-27016(gp)
  150ba8:	00c00574 	movhi	r3,21
  150bac:	18d4e704 	addi	r3,r3,21404
  150bb0:	1085883a 	add	r2,r2,r2
  150bb4:	1085883a 	add	r2,r2,r2
  150bb8:	1885883a 	add	r2,r3,r2
  150bbc:	10800017 	ldw	r2,0(r2)
  150bc0:	103ee83a 	callr	r2

    /* if displaying menu entries, display the new value */
    /* note: since it is being changed - know this option is selected */
    if (menu_display)  {
  150bc4:	d0a59d17 	ldw	r2,-27020(gp)
  150bc8:	10001426 	beq	r2,zero,150c1c <menu_entry_right+0x88>
        menu[menu_entry].display((MENU_X + menu[menu_entry].opt_off),
  150bcc:	d0a59e17 	ldw	r2,-27016(gp)
  150bd0:	00c00574 	movhi	r3,21
  150bd4:	18d4cb04 	addi	r3,r3,21292
  150bd8:	1004913a 	slli	r2,r2,4
  150bdc:	1885883a 	add	r2,r3,r2
  150be0:	10800304 	addi	r2,r2,12
  150be4:	11c00017 	ldw	r7,0(r2)
  150be8:	d0a59e17 	ldw	r2,-27016(gp)
  150bec:	00c00574 	movhi	r3,21
  150bf0:	18d4cb04 	addi	r3,r3,21292
  150bf4:	1004913a 	slli	r2,r2,4
  150bf8:	1885883a 	add	r2,r3,r2
  150bfc:	10800204 	addi	r2,r2,8
  150c00:	10800017 	ldw	r2,0(r2)
  150c04:	10c00fc4 	addi	r3,r2,63
  150c08:	d0a59e17 	ldw	r2,-27016(gp)
  150c0c:	1809883a 	mov	r4,r3
  150c10:	100b883a 	mov	r5,r2
  150c14:	000d883a 	mov	r6,zero
  150c18:	383ee83a 	callr	r7
    			         (MENU_Y + menu_entry), OPTION_SELECTED);
    }


    /* all done, return */
    return;
  150c1c:	0001883a 	nop

}
  150c20:	e037883a 	mov	sp,fp
  150c24:	dfc00117 	ldw	ra,4(sp)
  150c28:	df000017 	ldw	fp,0(sp)
  150c2c:	dec00204 	addi	sp,sp,8
  150c30:	f800283a 	ret

00150c34 <display_entry>:
   Last Modified:    Aug. 13, 2004

*/

static void  display_entry(int entry, int selected)
{
  150c34:	defffc04 	addi	sp,sp,-16
  150c38:	dfc00315 	stw	ra,12(sp)
  150c3c:	df000215 	stw	fp,8(sp)
  150c40:	df000204 	addi	fp,sp,8
  150c44:	e13ffe15 	stw	r4,-8(fp)
  150c48:	e17fff15 	stw	r5,-4(fp)
      /* none */



    /* output the menu entry with the appropriate color */
    plot_string((MENU_X + menu[entry].h_off), (MENU_Y + entry), menu[entry].s,
  150c4c:	00c00574 	movhi	r3,21
  150c50:	18d4cb04 	addi	r3,r3,21292
  150c54:	e0bffe17 	ldw	r2,-8(fp)
  150c58:	1004913a 	slli	r2,r2,4
  150c5c:	1885883a 	add	r2,r3,r2
  150c60:	10800104 	addi	r2,r2,4
  150c64:	10800017 	ldw	r2,0(r2)
  150c68:	11000fc4 	addi	r4,r2,63
  150c6c:	00c00574 	movhi	r3,21
  150c70:	18d4cb04 	addi	r3,r3,21292
  150c74:	e0bffe17 	ldw	r2,-8(fp)
  150c78:	1004913a 	slli	r2,r2,4
  150c7c:	1885883a 	add	r2,r3,r2
  150c80:	10c00017 	ldw	r3,0(r2)
  150c84:	e0bfff17 	ldw	r2,-4(fp)
  150c88:	1004c03a 	cmpne	r2,r2,zero
  150c8c:	10803fcc 	andi	r2,r2,255
  150c90:	e17ffe17 	ldw	r5,-8(fp)
  150c94:	180d883a 	mov	r6,r3
  150c98:	100f883a 	mov	r7,r2
  150c9c:	01506a00 	call	1506a0 <plot_string>
    		(selected ? SELECTED : NORMAL));
    /* also output the menu option with the appropriate color */
    menu[entry].display((MENU_X + menu[entry].opt_off), (MENU_Y + entry),
  150ca0:	00c00574 	movhi	r3,21
  150ca4:	18d4cb04 	addi	r3,r3,21292
  150ca8:	e0bffe17 	ldw	r2,-8(fp)
  150cac:	1004913a 	slli	r2,r2,4
  150cb0:	1885883a 	add	r2,r3,r2
  150cb4:	10800304 	addi	r2,r2,12
  150cb8:	10c00017 	ldw	r3,0(r2)
  150cbc:	01000574 	movhi	r4,21
  150cc0:	2114cb04 	addi	r4,r4,21292
  150cc4:	e0bffe17 	ldw	r2,-8(fp)
  150cc8:	1004913a 	slli	r2,r2,4
  150ccc:	2085883a 	add	r2,r4,r2
  150cd0:	10800204 	addi	r2,r2,8
  150cd4:	10800017 	ldw	r2,0(r2)
  150cd8:	10800fc4 	addi	r2,r2,63
  150cdc:	1009883a 	mov	r4,r2
  150ce0:	e17ffe17 	ldw	r5,-8(fp)
  150ce4:	000d883a 	mov	r6,zero
  150ce8:	183ee83a 	callr	r3
    			(selected ? OPTION_SELECTED : OPTION_NORMAL));


    /* all done outputting this menu entry - return */
    return;
  150cec:	0001883a 	nop

}
  150cf0:	e037883a 	mov	sp,fp
  150cf4:	dfc00117 	ldw	ra,4(sp)
  150cf8:	df000017 	ldw	fp,0(sp)
  150cfc:	dec00204 	addi	sp,sp,8
  150d00:	f800283a 	ret

00150d04 <no_menu_action>:
   Last Modified:    Mar. 8, 1994

*/

void  no_menu_action()
{
  150d04:	deffff04 	addi	sp,sp,-4
  150d08:	df000015 	stw	fp,0(sp)
  150d0c:	d839883a 	mov	fp,sp
      /* none */



    /* nothing to do - return */
    return;
  150d10:	0001883a 	nop

}
  150d14:	e037883a 	mov	sp,fp
  150d18:	df000017 	ldw	fp,0(sp)
  150d1c:	dec00104 	addi	sp,sp,4
  150d20:	f800283a 	ret

00150d24 <no_display>:
   Last Modified:    Mar. 8, 1994

*/

void  no_display(int x_pos, int y_pos, int style)
{
  150d24:	defffc04 	addi	sp,sp,-16
  150d28:	df000315 	stw	fp,12(sp)
  150d2c:	df000304 	addi	fp,sp,12
  150d30:	e13ffd15 	stw	r4,-12(fp)
  150d34:	e17ffe15 	stw	r5,-8(fp)
  150d38:	e1bfff15 	stw	r6,-4(fp)
      /* none */



    /* nothing to do - return */
    return;
  150d3c:	0001883a 	nop

}
  150d40:	e037883a 	mov	sp,fp
  150d44:	df000017 	ldw	fp,0(sp)
  150d48:	dec00104 	addi	sp,sp,4
  150d4c:	f800283a 	ret

00150d50 <set_trigger_mode>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trigger_mode(enum trigger_type m)
{
  150d50:	defffd04 	addi	sp,sp,-12
  150d54:	dfc00215 	stw	ra,8(sp)
  150d58:	df000115 	stw	fp,4(sp)
  150d5c:	df000104 	addi	fp,sp,4
  150d60:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger mode */
    trigger_mode = m;
  150d64:	e0bfff17 	ldw	r2,-4(fp)
  150d68:	d0a59f15 	stw	r2,-27012(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  150d6c:	d0a59f17 	ldw	r2,-27012(gp)
  150d70:	1009883a 	mov	r4,r2
  150d74:	0151c7c0 	call	151c7c <set_mode>


    /* all done setting the trigger mode - return */
    return;
  150d78:	0001883a 	nop

}
  150d7c:	e037883a 	mov	sp,fp
  150d80:	dfc00117 	ldw	ra,4(sp)
  150d84:	df000017 	ldw	fp,0(sp)
  150d88:	dec00204 	addi	sp,sp,8
  150d8c:	f800283a 	ret

00150d90 <get_trigger_mode>:
   Last Modified:    May 9, 2006

*/

enum trigger_type  get_trigger_mode()
{
  150d90:	deffff04 	addi	sp,sp,-4
  150d94:	df000015 	stw	fp,0(sp)
  150d98:	d839883a 	mov	fp,sp
      /* none */



    /* return the current trigger mode */
    return  trigger_mode;
  150d9c:	d0a59f17 	ldw	r2,-27012(gp)

}
  150da0:	e037883a 	mov	sp,fp
  150da4:	df000017 	ldw	fp,0(sp)
  150da8:	dec00104 	addi	sp,sp,4
  150dac:	f800283a 	ret

00150db0 <mode_down>:
   Last Modified:    May 9, 2006

*/

void  mode_down()
{
  150db0:	defffe04 	addi	sp,sp,-8
  150db4:	dfc00115 	stw	ra,4(sp)
  150db8:	df000015 	stw	fp,0(sp)
  150dbc:	d839883a 	mov	fp,sp
      /* none */



    /* move to the "next" triggering mode */
    if (trigger_mode == NORMAL_TRIGGER)
  150dc0:	d0a59f17 	ldw	r2,-27012(gp)
  150dc4:	1000031e 	bne	r2,zero,150dd4 <mode_down+0x24>
        trigger_mode = AUTO_TRIGGER;
  150dc8:	00800044 	movi	r2,1
  150dcc:	d0a59f15 	stw	r2,-27012(gp)
  150dd0:	00000706 	br	150df0 <mode_down+0x40>
    else if (trigger_mode == AUTO_TRIGGER)
  150dd4:	d0a59f17 	ldw	r2,-27012(gp)
  150dd8:	10800058 	cmpnei	r2,r2,1
  150ddc:	1000031e 	bne	r2,zero,150dec <mode_down+0x3c>
        trigger_mode = ONESHOT_TRIGGER;
  150de0:	00800084 	movi	r2,2
  150de4:	d0a59f15 	stw	r2,-27012(gp)
  150de8:	00000106 	br	150df0 <mode_down+0x40>
    else
        trigger_mode = NORMAL_TRIGGER;
  150dec:	d0259f15 	stw	zero,-27012(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  150df0:	d0a59f17 	ldw	r2,-27012(gp)
  150df4:	1009883a 	mov	r4,r2
  150df8:	0151c7c0 	call	151c7c <set_mode>


    /* all done with the trigger mode - return */
    return;
  150dfc:	0001883a 	nop

}
  150e00:	e037883a 	mov	sp,fp
  150e04:	dfc00117 	ldw	ra,4(sp)
  150e08:	df000017 	ldw	fp,0(sp)
  150e0c:	dec00204 	addi	sp,sp,8
  150e10:	f800283a 	ret

00150e14 <mode_up>:
   Last Modified:    May 9, 2006

*/

void  mode_up()
{
  150e14:	defffe04 	addi	sp,sp,-8
  150e18:	dfc00115 	stw	ra,4(sp)
  150e1c:	df000015 	stw	fp,0(sp)
  150e20:	d839883a 	mov	fp,sp
      /* none */



    /* move to the "previous" triggering mode */
    if (trigger_mode == NORMAL_TRIGGER)
  150e24:	d0a59f17 	ldw	r2,-27012(gp)
  150e28:	1000031e 	bne	r2,zero,150e38 <mode_up+0x24>
        trigger_mode = ONESHOT_TRIGGER;
  150e2c:	00800084 	movi	r2,2
  150e30:	d0a59f15 	stw	r2,-27012(gp)
  150e34:	00000706 	br	150e54 <mode_up+0x40>
    else if (trigger_mode == AUTO_TRIGGER)
  150e38:	d0a59f17 	ldw	r2,-27012(gp)
  150e3c:	10800058 	cmpnei	r2,r2,1
  150e40:	1000021e 	bne	r2,zero,150e4c <mode_up+0x38>
        trigger_mode = NORMAL_TRIGGER;
  150e44:	d0259f15 	stw	zero,-27012(gp)
  150e48:	00000206 	br	150e54 <mode_up+0x40>
    else
        trigger_mode = AUTO_TRIGGER;
  150e4c:	00800044 	movi	r2,1
  150e50:	d0a59f15 	stw	r2,-27012(gp)

    /* set the new mode */
    set_mode(trigger_mode);
  150e54:	d0a59f17 	ldw	r2,-27012(gp)
  150e58:	1009883a 	mov	r4,r2
  150e5c:	0151c7c0 	call	151c7c <set_mode>


    /* all done with the trigger mode - return */
    return;
  150e60:	0001883a 	nop

}
  150e64:	e037883a 	mov	sp,fp
  150e68:	dfc00117 	ldw	ra,4(sp)
  150e6c:	df000017 	ldw	fp,0(sp)
  150e70:	dec00204 	addi	sp,sp,8
  150e74:	f800283a 	ret

00150e78 <display_mode>:
   Last Modified:    May 9, 2006

*/

void  display_mode(int x_pos, int y_pos, int style)
{
  150e78:	defffb04 	addi	sp,sp,-20
  150e7c:	dfc00415 	stw	ra,16(sp)
  150e80:	df000315 	stw	fp,12(sp)
  150e84:	df000304 	addi	fp,sp,12
  150e88:	e13ffd15 	stw	r4,-12(fp)
  150e8c:	e17ffe15 	stw	r5,-8(fp)
  150e90:	e1bfff15 	stw	r6,-4(fp)
                                             " One-Shot "  };



    /* display the trigger mode */
    plot_string(x_pos, y_pos, modes[trigger_mode], style);
  150e94:	d0a59f17 	ldw	r2,-27012(gp)
  150e98:	00c00574 	movhi	r3,21
  150e9c:	18d54d04 	addi	r3,r3,21812
  150ea0:	1085883a 	add	r2,r2,r2
  150ea4:	1085883a 	add	r2,r2,r2
  150ea8:	1885883a 	add	r2,r3,r2
  150eac:	10c00017 	ldw	r3,0(r2)
  150eb0:	e0bfff17 	ldw	r2,-4(fp)
  150eb4:	e13ffd17 	ldw	r4,-12(fp)
  150eb8:	e17ffe17 	ldw	r5,-8(fp)
  150ebc:	180d883a 	mov	r6,r3
  150ec0:	100f883a 	mov	r7,r2
  150ec4:	01506a00 	call	1506a0 <plot_string>


    /* all done displaying the trigger mode - return */
    return;
  150ec8:	0001883a 	nop

}
  150ecc:	e037883a 	mov	sp,fp
  150ed0:	dfc00117 	ldw	ra,4(sp)
  150ed4:	df000017 	ldw	fp,0(sp)
  150ed8:	dec00204 	addi	sp,sp,8
  150edc:	f800283a 	ret

00150ee0 <set_scale>:
   Last Modified:    Mar. 13, 1994

*/

void  set_scale(enum scale_type s)
{
  150ee0:	defffd04 	addi	sp,sp,-12
  150ee4:	dfc00215 	stw	ra,8(sp)
  150ee8:	df000115 	stw	fp,4(sp)
  150eec:	df000104 	addi	fp,sp,4
  150ef0:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the scale type */
    scale = s;
  150ef4:	e0bfff17 	ldw	r2,-4(fp)
  150ef8:	d0a5a015 	stw	r2,-27008(gp)

    /* output the scale appropriately */
    set_display_scale(scale);
  150efc:	d0a5a017 	ldw	r2,-27008(gp)
  150f00:	1009883a 	mov	r4,r2
  150f04:	0151da00 	call	151da0 <set_display_scale>


    /* all done setting the scale type - return */
    return;
  150f08:	0001883a 	nop

}
  150f0c:	e037883a 	mov	sp,fp
  150f10:	dfc00117 	ldw	ra,4(sp)
  150f14:	df000017 	ldw	fp,0(sp)
  150f18:	dec00204 	addi	sp,sp,8
  150f1c:	f800283a 	ret

00150f20 <scale_down>:
   Last Modified:    May 9, 2006

*/

void  scale_down()
{
  150f20:	defffe04 	addi	sp,sp,-8
  150f24:	dfc00115 	stw	ra,4(sp)
  150f28:	df000015 	stw	fp,0(sp)
  150f2c:	d839883a 	mov	fp,sp
      /* none */



    /* change to the "next" scale type */
    if (scale == SCALE_NONE)
  150f30:	d0a5a017 	ldw	r2,-27008(gp)
  150f34:	1000031e 	bne	r2,zero,150f44 <scale_down+0x24>
        scale = SCALE_AXES;
  150f38:	00800044 	movi	r2,1
  150f3c:	d0a5a015 	stw	r2,-27008(gp)
  150f40:	00000706 	br	150f60 <scale_down+0x40>
    else if (scale == SCALE_AXES)
  150f44:	d0a5a017 	ldw	r2,-27008(gp)
  150f48:	10800058 	cmpnei	r2,r2,1
  150f4c:	1000031e 	bne	r2,zero,150f5c <scale_down+0x3c>
        scale = SCALE_GRID;
  150f50:	00800084 	movi	r2,2
  150f54:	d0a5a015 	stw	r2,-27008(gp)
  150f58:	00000106 	br	150f60 <scale_down+0x40>
    else
        scale = SCALE_NONE;
  150f5c:	d025a015 	stw	zero,-27008(gp)

    /* set the scale type */
    set_display_scale(scale);
  150f60:	d0a5a017 	ldw	r2,-27008(gp)
  150f64:	1009883a 	mov	r4,r2
  150f68:	0151da00 	call	151da0 <set_display_scale>


    /* all done with toggling the scale type - return */
    return;
  150f6c:	0001883a 	nop

}
  150f70:	e037883a 	mov	sp,fp
  150f74:	dfc00117 	ldw	ra,4(sp)
  150f78:	df000017 	ldw	fp,0(sp)
  150f7c:	dec00204 	addi	sp,sp,8
  150f80:	f800283a 	ret

00150f84 <scale_up>:
   Last Modified:    May 9, 2006

*/

void  scale_up()
{
  150f84:	defffe04 	addi	sp,sp,-8
  150f88:	dfc00115 	stw	ra,4(sp)
  150f8c:	df000015 	stw	fp,0(sp)
  150f90:	d839883a 	mov	fp,sp
      /* none */



    /* change to the "previous" scale type */
    if (scale == SCALE_NONE)
  150f94:	d0a5a017 	ldw	r2,-27008(gp)
  150f98:	1000031e 	bne	r2,zero,150fa8 <scale_up+0x24>
        scale = SCALE_GRID;
  150f9c:	00800084 	movi	r2,2
  150fa0:	d0a5a015 	stw	r2,-27008(gp)
  150fa4:	00000706 	br	150fc4 <scale_up+0x40>
    else if (scale == SCALE_AXES)
  150fa8:	d0a5a017 	ldw	r2,-27008(gp)
  150fac:	10800058 	cmpnei	r2,r2,1
  150fb0:	1000021e 	bne	r2,zero,150fbc <scale_up+0x38>
        scale = SCALE_NONE;
  150fb4:	d025a015 	stw	zero,-27008(gp)
  150fb8:	00000206 	br	150fc4 <scale_up+0x40>
    else
        scale = SCALE_AXES;
  150fbc:	00800044 	movi	r2,1
  150fc0:	d0a5a015 	stw	r2,-27008(gp)

    /* set the scale type */
    set_display_scale(scale);
  150fc4:	d0a5a017 	ldw	r2,-27008(gp)
  150fc8:	1009883a 	mov	r4,r2
  150fcc:	0151da00 	call	151da0 <set_display_scale>


    /* all done with toggling the scale type - return */
    return;
  150fd0:	0001883a 	nop

}
  150fd4:	e037883a 	mov	sp,fp
  150fd8:	dfc00117 	ldw	ra,4(sp)
  150fdc:	df000017 	ldw	fp,0(sp)
  150fe0:	dec00204 	addi	sp,sp,8
  150fe4:	f800283a 	ret

00150fe8 <display_scale>:
   Last Modified:    Mar. 13, 1994

*/

void  display_scale(int x_pos, int y_pos, int style)
{
  150fe8:	defffb04 	addi	sp,sp,-20
  150fec:	dfc00415 	stw	ra,16(sp)
  150ff0:	df000315 	stw	fp,12(sp)
  150ff4:	df000304 	addi	fp,sp,12
  150ff8:	e13ffd15 	stw	r4,-12(fp)
  150ffc:	e17ffe15 	stw	r5,-8(fp)
  151000:	e1bfff15 	stw	r6,-4(fp)
                                                  " Grid"  };



    /* display the scale status */
    plot_string(x_pos, y_pos, scale_stat[scale], style);
  151004:	d0a5a017 	ldw	r2,-27008(gp)
  151008:	00c00574 	movhi	r3,21
  15100c:	18d54104 	addi	r3,r3,21764
  151010:	1085883a 	add	r2,r2,r2
  151014:	1085883a 	add	r2,r2,r2
  151018:	1885883a 	add	r2,r3,r2
  15101c:	10c00017 	ldw	r3,0(r2)
  151020:	e0bfff17 	ldw	r2,-4(fp)
  151024:	e13ffd17 	ldw	r4,-12(fp)
  151028:	e17ffe17 	ldw	r5,-8(fp)
  15102c:	180d883a 	mov	r6,r3
  151030:	100f883a 	mov	r7,r2
  151034:	01506a00 	call	1506a0 <plot_string>


    /* all done displaying the scale status - return */
    return;
  151038:	0001883a 	nop

}
  15103c:	e037883a 	mov	sp,fp
  151040:	dfc00117 	ldw	ra,4(sp)
  151044:	df000017 	ldw	fp,0(sp)
  151048:	dec00204 	addi	sp,sp,8
  15104c:	f800283a 	ret

00151050 <set_sweep>:
   Last Modified:    Mar. 8, 1994

*/

void  set_sweep(int s)
{
  151050:	defffc04 	addi	sp,sp,-16
  151054:	dfc00315 	stw	ra,12(sp)
  151058:	df000215 	stw	fp,8(sp)
  15105c:	df000204 	addi	fp,sp,8
  151060:	e13fff15 	stw	r4,-4(fp)
    int  sample_size;		/* sample size for this sweep rate */



    /* set the new sweep rate */
    sweep = s;
  151064:	e0bfff17 	ldw	r2,-4(fp)
  151068:	d0a5a115 	stw	r2,-27004(gp)

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  15106c:	d0a5a117 	ldw	r2,-27004(gp)
  151070:	00c00574 	movhi	r3,21
  151074:	18d51704 	addi	r3,r3,21596
  151078:	100490fa 	slli	r2,r2,3
  15107c:	1885883a 	add	r2,r3,r2
  151080:	10800017 	ldw	r2,0(r2)
  151084:	1009883a 	mov	r4,r2
  151088:	0151a380 	call	151a38 <set_sample_rate>
  15108c:	e0bffe15 	stw	r2,-8(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  151090:	e13ffe17 	ldw	r4,-8(fp)
  151094:	0151d740 	call	151d74 <set_trace_size>


    /* all done initializing the sweep rate - return */
    return;
  151098:	0001883a 	nop

}
  15109c:	e037883a 	mov	sp,fp
  1510a0:	dfc00117 	ldw	ra,4(sp)
  1510a4:	df000017 	ldw	fp,0(sp)
  1510a8:	dec00204 	addi	sp,sp,8
  1510ac:	f800283a 	ret

001510b0 <sweep_down>:
   Last Modified:    Mar. 8, 1994

*/

void  sweep_down()
{
  1510b0:	defffd04 	addi	sp,sp,-12
  1510b4:	dfc00215 	stw	ra,8(sp)
  1510b8:	df000115 	stw	fp,4(sp)
  1510bc:	df000104 	addi	fp,sp,4
    int  sample_size;		/* sample size for the new sweep rate */



    /* decrease the sweep rate, if not already the minimum */
    if (sweep > 0)  {
  1510c0:	d0a5a117 	ldw	r2,-27004(gp)
  1510c4:	0080090e 	bge	zero,r2,1510ec <sweep_down+0x3c>
        /* not at minimum, adjust delay for new sweep */
	adjust_trg_delay(sweep, (sweep - 1));
  1510c8:	d0e5a117 	ldw	r3,-27004(gp)
  1510cc:	d0a5a117 	ldw	r2,-27004(gp)
  1510d0:	10bfffc4 	addi	r2,r2,-1
  1510d4:	1809883a 	mov	r4,r3
  1510d8:	100b883a 	mov	r5,r2
  1510dc:	01515780 	call	151578 <adjust_trg_delay>
	/* now set new sweep rate */
        sweep--;
  1510e0:	d0a5a117 	ldw	r2,-27004(gp)
  1510e4:	10bfffc4 	addi	r2,r2,-1
  1510e8:	d0a5a115 	stw	r2,-27004(gp)
    }

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  1510ec:	d0a5a117 	ldw	r2,-27004(gp)
  1510f0:	00c00574 	movhi	r3,21
  1510f4:	18d51704 	addi	r3,r3,21596
  1510f8:	100490fa 	slli	r2,r2,3
  1510fc:	1885883a 	add	r2,r3,r2
  151100:	10800017 	ldw	r2,0(r2)
  151104:	1009883a 	mov	r4,r2
  151108:	0151a380 	call	151a38 <set_sample_rate>
  15110c:	e0bfff15 	stw	r2,-4(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  151110:	e13fff17 	ldw	r4,-4(fp)
  151114:	0151d740 	call	151d74 <set_trace_size>


    /* all done with lowering the sweep rate - return */
    return;
  151118:	0001883a 	nop

}
  15111c:	e037883a 	mov	sp,fp
  151120:	dfc00117 	ldw	ra,4(sp)
  151124:	df000017 	ldw	fp,0(sp)
  151128:	dec00204 	addi	sp,sp,8
  15112c:	f800283a 	ret

00151130 <sweep_up>:
   Last Modified:    Mar. 8, 1994

*/

void  sweep_up()
{
  151130:	defffd04 	addi	sp,sp,-12
  151134:	dfc00215 	stw	ra,8(sp)
  151138:	df000115 	stw	fp,4(sp)
  15113c:	df000104 	addi	fp,sp,4
    int  sample_size;		/* sample size for the new sweep rate */



    /* increase the sweep rate, if not already the maximum */
    if (sweep < (NO_SWEEP_RATES - 1))  {
  151140:	d0a5a117 	ldw	r2,-27004(gp)
  151144:	10800428 	cmpgeui	r2,r2,16
  151148:	1000091e 	bne	r2,zero,151170 <sweep_up+0x40>
        /* not at maximum, adjust delay for new sweep */
	adjust_trg_delay(sweep, (sweep + 1));
  15114c:	d0e5a117 	ldw	r3,-27004(gp)
  151150:	d0a5a117 	ldw	r2,-27004(gp)
  151154:	10800044 	addi	r2,r2,1
  151158:	1809883a 	mov	r4,r3
  15115c:	100b883a 	mov	r5,r2
  151160:	01515780 	call	151578 <adjust_trg_delay>
	/* now set new sweep rate */
        sweep++;
  151164:	d0a5a117 	ldw	r2,-27004(gp)
  151168:	10800044 	addi	r2,r2,1
  15116c:	d0a5a115 	stw	r2,-27004(gp)
    }

    /* set the sweep rate for the hardware */
    sample_size = set_sample_rate(sweep_rates[sweep].sample_rate);
  151170:	d0a5a117 	ldw	r2,-27004(gp)
  151174:	00c00574 	movhi	r3,21
  151178:	18d51704 	addi	r3,r3,21596
  15117c:	100490fa 	slli	r2,r2,3
  151180:	1885883a 	add	r2,r3,r2
  151184:	10800017 	ldw	r2,0(r2)
  151188:	1009883a 	mov	r4,r2
  15118c:	0151a380 	call	151a38 <set_sample_rate>
  151190:	e0bfff15 	stw	r2,-4(fp)
    /* also set the sample size for the trace capture */
    set_trace_size(sample_size);
  151194:	e13fff17 	ldw	r4,-4(fp)
  151198:	0151d740 	call	151d74 <set_trace_size>


    /* all done with raising the sweep rate - return */
    return;
  15119c:	0001883a 	nop

}
  1511a0:	e037883a 	mov	sp,fp
  1511a4:	dfc00117 	ldw	ra,4(sp)
  1511a8:	df000017 	ldw	fp,0(sp)
  1511ac:	dec00204 	addi	sp,sp,8
  1511b0:	f800283a 	ret

001511b4 <display_sweep>:
   Last Modified:    Mar. 8, 1994

*/

void  display_sweep(int x_pos, int y_pos, int style)
{
  1511b4:	defffb04 	addi	sp,sp,-20
  1511b8:	dfc00415 	stw	ra,16(sp)
  1511bc:	df000315 	stw	fp,12(sp)
  1511c0:	df000304 	addi	fp,sp,12
  1511c4:	e13ffd15 	stw	r4,-12(fp)
  1511c8:	e17ffe15 	stw	r5,-8(fp)
  1511cc:	e1bfff15 	stw	r6,-4(fp)
      /* none */



    /* display the sweep rate */
    plot_string(x_pos, y_pos, sweep_rates[sweep].s, style);
  1511d0:	d0a5a117 	ldw	r2,-27004(gp)
  1511d4:	00c00574 	movhi	r3,21
  1511d8:	18d51704 	addi	r3,r3,21596
  1511dc:	100490fa 	slli	r2,r2,3
  1511e0:	1885883a 	add	r2,r3,r2
  1511e4:	10800104 	addi	r2,r2,4
  1511e8:	10c00017 	ldw	r3,0(r2)
  1511ec:	e0bfff17 	ldw	r2,-4(fp)
  1511f0:	e13ffd17 	ldw	r4,-12(fp)
  1511f4:	e17ffe17 	ldw	r5,-8(fp)
  1511f8:	180d883a 	mov	r6,r3
  1511fc:	100f883a 	mov	r7,r2
  151200:	01506a00 	call	1506a0 <plot_string>


    /* all done displaying the sweep rate - return */
    return;
  151204:	0001883a 	nop

}
  151208:	e037883a 	mov	sp,fp
  15120c:	dfc00117 	ldw	ra,4(sp)
  151210:	df000017 	ldw	fp,0(sp)
  151214:	dec00204 	addi	sp,sp,8
  151218:	f800283a 	ret

0015121c <set_trg_level>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_level(int l)
{
  15121c:	defffd04 	addi	sp,sp,-12
  151220:	dfc00215 	stw	ra,8(sp)
  151224:	df000115 	stw	fp,4(sp)
  151228:	df000104 	addi	fp,sp,4
  15122c:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger level */
    level = l;
  151230:	e0bfff17 	ldw	r2,-4(fp)
  151234:	d0a5a215 	stw	r2,-27000(gp)

    /* set the trigger level in hardware too */
    set_trigger(level, slope);
  151238:	d0e5a217 	ldw	r3,-27000(gp)
  15123c:	d0a5a317 	ldw	r2,-26996(gp)
  151240:	1809883a 	mov	r4,r3
  151244:	100b883a 	mov	r5,r2
  151248:	0151a5c0 	call	151a5c <set_trigger>


    /* all done initializing the trigger level - return */
    return;
  15124c:	0001883a 	nop

}
  151250:	e037883a 	mov	sp,fp
  151254:	dfc00117 	ldw	ra,4(sp)
  151258:	df000017 	ldw	fp,0(sp)
  15125c:	dec00204 	addi	sp,sp,8
  151260:	f800283a 	ret

00151264 <trg_level_down>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_level_down()
{
  151264:	defffe04 	addi	sp,sp,-8
  151268:	dfc00115 	stw	ra,4(sp)
  15126c:	df000015 	stw	fp,0(sp)
  151270:	d839883a 	mov	fp,sp
      /* none */



    /* decrease the trigger level, if not already the minimum */
    if (level > MIN_TRG_LEVEL_SET)
  151274:	d0a5a217 	ldw	r2,-27000(gp)
  151278:	0080030e 	bge	zero,r2,151288 <trg_level_down+0x24>
        level--;
  15127c:	d0a5a217 	ldw	r2,-27000(gp)
  151280:	10bfffc4 	addi	r2,r2,-1
  151284:	d0a5a215 	stw	r2,-27000(gp)

    /* set the trigger level for the hardware */
    set_trigger(level, slope);
  151288:	d0e5a217 	ldw	r3,-27000(gp)
  15128c:	d0a5a317 	ldw	r2,-26996(gp)
  151290:	1809883a 	mov	r4,r3
  151294:	100b883a 	mov	r5,r2
  151298:	0151a5c0 	call	151a5c <set_trigger>


    /* all done with lowering the trigger level - return */
    return;
  15129c:	0001883a 	nop

}
  1512a0:	e037883a 	mov	sp,fp
  1512a4:	dfc00117 	ldw	ra,4(sp)
  1512a8:	df000017 	ldw	fp,0(sp)
  1512ac:	dec00204 	addi	sp,sp,8
  1512b0:	f800283a 	ret

001512b4 <trg_level_up>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_level_up()
{
  1512b4:	defffe04 	addi	sp,sp,-8
  1512b8:	dfc00115 	stw	ra,4(sp)
  1512bc:	df000015 	stw	fp,0(sp)
  1512c0:	d839883a 	mov	fp,sp
      /* none */



    /* increase the trigger level, if not already the maximum */
    if (level < MAX_TRG_LEVEL_SET)
  1512c4:	d0a5a217 	ldw	r2,-27000(gp)
  1512c8:	10801fc8 	cmpgei	r2,r2,127
  1512cc:	1000031e 	bne	r2,zero,1512dc <trg_level_up+0x28>
        level++;
  1512d0:	d0a5a217 	ldw	r2,-27000(gp)
  1512d4:	10800044 	addi	r2,r2,1
  1512d8:	d0a5a215 	stw	r2,-27000(gp)

    /* tell the hardware the new trigger level */
    set_trigger(level, slope);
  1512dc:	d0e5a217 	ldw	r3,-27000(gp)
  1512e0:	d0a5a317 	ldw	r2,-26996(gp)
  1512e4:	1809883a 	mov	r4,r3
  1512e8:	100b883a 	mov	r5,r2
  1512ec:	0151a5c0 	call	151a5c <set_trigger>


    /* all done raising the trigger level - return */
    return;
  1512f0:	0001883a 	nop

}
  1512f4:	e037883a 	mov	sp,fp
  1512f8:	dfc00117 	ldw	ra,4(sp)
  1512fc:	df000017 	ldw	fp,0(sp)
  151300:	dec00204 	addi	sp,sp,8
  151304:	f800283a 	ret

00151308 <display_trg_level>:
   Last Modified:    Mar. 10, 1995

*/

void  display_trg_level(int x_pos, int y_pos, int style)
{
  151308:	defff704 	addi	sp,sp,-36
  15130c:	dfc00815 	stw	ra,32(sp)
  151310:	df000715 	stw	fp,28(sp)
  151314:	df000704 	addi	fp,sp,28
  151318:	e13ffd15 	stw	r4,-12(fp)
  15131c:	e17ffe15 	stw	r5,-8(fp)
  151320:	e1bfff15 	stw	r6,-4(fp)
    /* variables */
    char      level_str[] = "        "; /* string containing the trigger level */
  151324:	00880834 	movhi	r2,8224
  151328:	10880804 	addi	r2,r2,8224
  15132c:	e0bffa15 	stw	r2,-24(fp)
  151330:	00880834 	movhi	r2,8224
  151334:	10880804 	addi	r2,r2,8224
  151338:	e0bffb15 	stw	r2,-20(fp)
  15133c:	e03ffc05 	stb	zero,-16(fp)
    long int  l;			/* trigger level in mV */



    /* compute the trigger level in millivolts */
    l = ((long int) MAX_LEVEL - MIN_LEVEL) * level / (MAX_TRG_LEVEL_SET - MIN_TRG_LEVEL_SET) + MIN_LEVEL;
  151340:	d0a5a217 	ldw	r2,-27000(gp)
  151344:	1084e224 	muli	r2,r2,5000
  151348:	1009883a 	mov	r4,r2
  15134c:	01401fc4 	movi	r5,127
  151350:	0152bfc0 	call	152bfc <__divsi3>
  151354:	e0bff915 	stw	r2,-28(fp)

    /* convert the level to the string (leave first character blank) */
    cvt_num_field(l, &level_str[1]);
  151358:	e0bffa04 	addi	r2,fp,-24
  15135c:	10800044 	addi	r2,r2,1
  151360:	e13ff917 	ldw	r4,-28(fp)
  151364:	100b883a 	mov	r5,r2
  151368:	01518540 	call	151854 <cvt_num_field>

    /* add in the units */
    level_str[7] = 'V';
  15136c:	00801584 	movi	r2,86
  151370:	e0bffbc5 	stb	r2,-17(fp)


    /* now finally display the trigger level */
    plot_string(x_pos, y_pos, level_str, style);
  151374:	e0bfff17 	ldw	r2,-4(fp)
  151378:	e0fffa04 	addi	r3,fp,-24
  15137c:	e13ffd17 	ldw	r4,-12(fp)
  151380:	e17ffe17 	ldw	r5,-8(fp)
  151384:	180d883a 	mov	r6,r3
  151388:	100f883a 	mov	r7,r2
  15138c:	01506a00 	call	1506a0 <plot_string>


    /* all done displaying the trigger level - return */
    return;

}
  151390:	e037883a 	mov	sp,fp
  151394:	dfc00117 	ldw	ra,4(sp)
  151398:	df000017 	ldw	fp,0(sp)
  15139c:	dec00204 	addi	sp,sp,8
  1513a0:	f800283a 	ret

001513a4 <set_trg_slope>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_slope(enum slope_type s)
{
  1513a4:	defffd04 	addi	sp,sp,-12
  1513a8:	dfc00215 	stw	ra,8(sp)
  1513ac:	df000115 	stw	fp,4(sp)
  1513b0:	df000104 	addi	fp,sp,4
  1513b4:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the slope type */
    slope = s;
  1513b8:	e0bfff17 	ldw	r2,-4(fp)
  1513bc:	d0a5a315 	stw	r2,-26996(gp)

    /* also tell the hardware what the slope is */
    set_trigger(level, slope);
  1513c0:	d0e5a217 	ldw	r3,-27000(gp)
  1513c4:	d0a5a317 	ldw	r2,-26996(gp)
  1513c8:	1809883a 	mov	r4,r3
  1513cc:	100b883a 	mov	r5,r2
  1513d0:	0151a5c0 	call	151a5c <set_trigger>


    /* all done setting the trigger slope - return */
    return;
  1513d4:	0001883a 	nop

}
  1513d8:	e037883a 	mov	sp,fp
  1513dc:	dfc00117 	ldw	ra,4(sp)
  1513e0:	df000017 	ldw	fp,0(sp)
  1513e4:	dec00204 	addi	sp,sp,8
  1513e8:	f800283a 	ret

001513ec <trg_slope_toggle>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_slope_toggle()
{
  1513ec:	defffe04 	addi	sp,sp,-8
  1513f0:	dfc00115 	stw	ra,4(sp)
  1513f4:	df000015 	stw	fp,0(sp)
  1513f8:	d839883a 	mov	fp,sp
      /* none */



    /* toggle the trigger slope */
    if (slope == SLOPE_POSITIVE)
  1513fc:	d0a5a317 	ldw	r2,-26996(gp)
  151400:	1000031e 	bne	r2,zero,151410 <trg_slope_toggle+0x24>
        slope = SLOPE_NEGATIVE;
  151404:	00800044 	movi	r2,1
  151408:	d0a5a315 	stw	r2,-26996(gp)
  15140c:	00000106 	br	151414 <trg_slope_toggle+0x28>
    else
        slope = SLOPE_POSITIVE;
  151410:	d025a315 	stw	zero,-26996(gp)

    /* set the new trigger slope */
    set_trigger(level, slope);
  151414:	d0e5a217 	ldw	r3,-27000(gp)
  151418:	d0a5a317 	ldw	r2,-26996(gp)
  15141c:	1809883a 	mov	r4,r3
  151420:	100b883a 	mov	r5,r2
  151424:	0151a5c0 	call	151a5c <set_trigger>


    /* all done with the trigger slope - return */
    return;
  151428:	0001883a 	nop

}
  15142c:	e037883a 	mov	sp,fp
  151430:	dfc00117 	ldw	ra,4(sp)
  151434:	df000017 	ldw	fp,0(sp)
  151438:	dec00204 	addi	sp,sp,8
  15143c:	f800283a 	ret

00151440 <display_trg_slope>:
   Last Modified:    Mar. 13, 1994

*/

void  display_trg_slope(int x_pos, int y_pos, int style)
{
  151440:	defffb04 	addi	sp,sp,-20
  151444:	dfc00415 	stw	ra,16(sp)
  151448:	df000315 	stw	fp,12(sp)
  15144c:	df000304 	addi	fp,sp,12
  151450:	e13ffd15 	stw	r4,-12(fp)
  151454:	e17ffe15 	stw	r5,-8(fp)
  151458:	e1bfff15 	stw	r6,-4(fp)
    const static char * const  slopes[] =  {  " +", " -"  };



    /* display the trigger slope */
    plot_string(x_pos, y_pos, slopes[slope], style);
  15145c:	d0a5a317 	ldw	r2,-26996(gp)
  151460:	1085883a 	add	r2,r2,r2
  151464:	1087883a 	add	r3,r2,r2
  151468:	d0a00004 	addi	r2,gp,-32768
  15146c:	1885883a 	add	r2,r3,r2
  151470:	10c00017 	ldw	r3,0(r2)
  151474:	e0bfff17 	ldw	r2,-4(fp)
  151478:	e13ffd17 	ldw	r4,-12(fp)
  15147c:	e17ffe17 	ldw	r5,-8(fp)
  151480:	180d883a 	mov	r6,r3
  151484:	100f883a 	mov	r7,r2
  151488:	01506a00 	call	1506a0 <plot_string>


    /* all done displaying the trigger slope - return */
    return;
  15148c:	0001883a 	nop

}
  151490:	e037883a 	mov	sp,fp
  151494:	dfc00117 	ldw	ra,4(sp)
  151498:	df000017 	ldw	fp,0(sp)
  15149c:	dec00204 	addi	sp,sp,8
  1514a0:	f800283a 	ret

001514a4 <set_trg_delay>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trg_delay(long int d)
{
  1514a4:	defffd04 	addi	sp,sp,-12
  1514a8:	dfc00215 	stw	ra,8(sp)
  1514ac:	df000115 	stw	fp,4(sp)
  1514b0:	df000104 	addi	fp,sp,4
  1514b4:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the trigger delay */
    delay = d;
  1514b8:	e0bfff17 	ldw	r2,-4(fp)
  1514bc:	d0a5a415 	stw	r2,-26992(gp)

    /* set the trigger delay in hardware too */
    set_delay(delay);
  1514c0:	d0a5a417 	ldw	r2,-26992(gp)
  1514c4:	1009883a 	mov	r4,r2
  1514c8:	0151a840 	call	151a84 <set_delay>


    /* all done initializing the trigger delay - return */
    return;
  1514cc:	0001883a 	nop

}
  1514d0:	e037883a 	mov	sp,fp
  1514d4:	dfc00117 	ldw	ra,4(sp)
  1514d8:	df000017 	ldw	fp,0(sp)
  1514dc:	dec00204 	addi	sp,sp,8
  1514e0:	f800283a 	ret

001514e4 <trg_delay_down>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_delay_down()
{
  1514e4:	defffe04 	addi	sp,sp,-8
  1514e8:	dfc00115 	stw	ra,4(sp)
  1514ec:	df000015 	stw	fp,0(sp)
  1514f0:	d839883a 	mov	fp,sp
      /* none */



    /* decrease the trigger delay, if not already the minimum */
    if (delay > MIN_DELAY)
  1514f4:	d0a5a417 	ldw	r2,-26992(gp)
  1514f8:	0080030e 	bge	zero,r2,151508 <trg_delay_down+0x24>
        delay--;
  1514fc:	d0a5a417 	ldw	r2,-26992(gp)
  151500:	10bfffc4 	addi	r2,r2,-1
  151504:	d0a5a415 	stw	r2,-26992(gp)

    /* set the trigger delay for the hardware */
    set_delay(delay);
  151508:	d0a5a417 	ldw	r2,-26992(gp)
  15150c:	1009883a 	mov	r4,r2
  151510:	0151a840 	call	151a84 <set_delay>


    /* all done with lowering the trigger delay - return */
    return;
  151514:	0001883a 	nop

}
  151518:	e037883a 	mov	sp,fp
  15151c:	dfc00117 	ldw	ra,4(sp)
  151520:	df000017 	ldw	fp,0(sp)
  151524:	dec00204 	addi	sp,sp,8
  151528:	f800283a 	ret

0015152c <trg_delay_up>:
   Last Modified:    Mar. 8, 1994

*/

void  trg_delay_up()
{
  15152c:	defffe04 	addi	sp,sp,-8
  151530:	dfc00115 	stw	ra,4(sp)
  151534:	df000015 	stw	fp,0(sp)
  151538:	d839883a 	mov	fp,sp
      /* none */



    /* increase the trigger delay, if not already the maximum */
    if (delay < MAX_DELAY)
  15153c:	d0a5a417 	ldw	r2,-26992(gp)
  151540:	00f0d3d4 	movui	r3,49999
  151544:	18800316 	blt	r3,r2,151554 <trg_delay_up+0x28>
        delay++;
  151548:	d0a5a417 	ldw	r2,-26992(gp)
  15154c:	10800044 	addi	r2,r2,1
  151550:	d0a5a415 	stw	r2,-26992(gp)

    /* tell the hardware the new trigger delay */
    set_delay(delay);
  151554:	d0a5a417 	ldw	r2,-26992(gp)
  151558:	1009883a 	mov	r4,r2
  15155c:	0151a840 	call	151a84 <set_delay>


    /* all done raising the trigger delay - return */
    return;
  151560:	0001883a 	nop

}
  151564:	e037883a 	mov	sp,fp
  151568:	dfc00117 	ldw	ra,4(sp)
  15156c:	df000017 	ldw	fp,0(sp)
  151570:	dec00204 	addi	sp,sp,8
  151574:	f800283a 	ret

00151578 <adjust_trg_delay>:
   Last Modified:    Mar. 8, 1994

*/

static void  adjust_trg_delay(int old_sweep, int new_sweep)
{
  151578:	defffc04 	addi	sp,sp,-16
  15157c:	dfc00315 	stw	ra,12(sp)
  151580:	df000215 	stw	fp,8(sp)
  151584:	df000204 	addi	fp,sp,8
  151588:	e13ffe15 	stw	r4,-8(fp)
  15158c:	e17fff15 	stw	r5,-4(fp)
      /* none */



    /* multiply by 10 times the ratio of sweep rates */
    delay *= (10 * sweep_rates[new_sweep].sample_rate) / sweep_rates[old_sweep].sample_rate;
  151590:	00c00574 	movhi	r3,21
  151594:	18d51704 	addi	r3,r3,21596
  151598:	e0bfff17 	ldw	r2,-4(fp)
  15159c:	100490fa 	slli	r2,r2,3
  1515a0:	1885883a 	add	r2,r3,r2
  1515a4:	10800017 	ldw	r2,0(r2)
  1515a8:	10c002a4 	muli	r3,r2,10
  1515ac:	01000574 	movhi	r4,21
  1515b0:	21151704 	addi	r4,r4,21596
  1515b4:	e0bffe17 	ldw	r2,-8(fp)
  1515b8:	100490fa 	slli	r2,r2,3
  1515bc:	2085883a 	add	r2,r4,r2
  1515c0:	10800017 	ldw	r2,0(r2)
  1515c4:	1809883a 	mov	r4,r3
  1515c8:	100b883a 	mov	r5,r2
  1515cc:	0152bfc0 	call	152bfc <__divsi3>
  1515d0:	1007883a 	mov	r3,r2
  1515d4:	d0a5a417 	ldw	r2,-26992(gp)
  1515d8:	1885383a 	mul	r2,r3,r2
  1515dc:	d0a5a415 	stw	r2,-26992(gp)
    /* now divide the factor of 10 back out */
    delay /= 10;
  1515e0:	d0a5a417 	ldw	r2,-26992(gp)
  1515e4:	1009883a 	mov	r4,r2
  1515e8:	01400284 	movi	r5,10
  1515ec:	0152bfc0 	call	152bfc <__divsi3>
  1515f0:	d0a5a415 	stw	r2,-26992(gp)

    /* make sure delay is not out of range */
    if (delay > MAX_DELAY)
  1515f4:	d0a5a417 	ldw	r2,-26992(gp)
  1515f8:	00f0d414 	movui	r3,50000
  1515fc:	1880020e 	bge	r3,r2,151608 <adjust_trg_delay+0x90>
        /* delay is too large - set to maximum */
        delay = MAX_DELAY;
  151600:	00b0d414 	movui	r2,50000
  151604:	d0a5a415 	stw	r2,-26992(gp)
    if (delay < MIN_DELAY)
  151608:	d0a5a417 	ldw	r2,-26992(gp)
  15160c:	1000010e 	bge	r2,zero,151614 <adjust_trg_delay+0x9c>
        /* delay is too small - set to minimum */
	delay = MIN_DELAY;
  151610:	d025a415 	stw	zero,-26992(gp)


    /* tell the hardware the new trigger delay */
    set_delay(delay);
  151614:	d0a5a417 	ldw	r2,-26992(gp)
  151618:	1009883a 	mov	r4,r2
  15161c:	0151a840 	call	151a84 <set_delay>


    /* all done adjusting the trigger delay - return */
    return;
  151620:	0001883a 	nop

}
  151624:	e037883a 	mov	sp,fp
  151628:	dfc00117 	ldw	ra,4(sp)
  15162c:	df000017 	ldw	fp,0(sp)
  151630:	dec00204 	addi	sp,sp,8
  151634:	f800283a 	ret

00151638 <display_trg_delay>:
   Last Modified:    May 3, 2006

*/

void  display_trg_delay(int x_pos, int y_pos, int style)
{
  151638:	defff604 	addi	sp,sp,-40
  15163c:	dfc00915 	stw	ra,36(sp)
  151640:	df000815 	stw	fp,32(sp)
  151644:	df000804 	addi	fp,sp,32
  151648:	e13ffd15 	stw	r4,-12(fp)
  15164c:	e17ffe15 	stw	r5,-8(fp)
  151650:	e1bfff15 	stw	r6,-4(fp)
    /* variables */
    char      delay_str[] = "         "; /* string containing the trigger delay */
  151654:	00880834 	movhi	r2,8224
  151658:	10880804 	addi	r2,r2,8224
  15165c:	e0bffa15 	stw	r2,-24(fp)
  151660:	00880834 	movhi	r2,8224
  151664:	10880804 	addi	r2,r2,8224
  151668:	e0bffb15 	stw	r2,-20(fp)
  15166c:	00800804 	movi	r2,32
  151670:	e0bffc0d 	sth	r2,-16(fp)
    long int  d;                         /* delay in appropriate units */


    /* compute the delay in the appropriate units */
    /* have to watch out for overflow, so be careful */
    if (sweep_rates[sweep].sample_rate > 1000000L)  {
  151674:	d0a5a117 	ldw	r2,-27004(gp)
  151678:	00c00574 	movhi	r3,21
  15167c:	18d51704 	addi	r3,r3,21596
  151680:	100490fa 	slli	r2,r2,3
  151684:	1885883a 	add	r2,r3,r2
  151688:	10800017 	ldw	r2,0(r2)
  15168c:	00c003f4 	movhi	r3,15
  151690:	18d09004 	addi	r3,r3,16960
  151694:	1880140e 	bge	r3,r2,1516e8 <display_trg_delay+0xb0>
        /* have a fast sweep rate, could overflow */
        /* first compute in units of 100 ns */
        d = delay * (10000000L / sweep_rates[sweep].sample_rate);
  151698:	d0a5a117 	ldw	r2,-27004(gp)
  15169c:	00c00574 	movhi	r3,21
  1516a0:	18d51704 	addi	r3,r3,21596
  1516a4:	100490fa 	slli	r2,r2,3
  1516a8:	1885883a 	add	r2,r3,r2
  1516ac:	10800017 	ldw	r2,0(r2)
  1516b0:	01002674 	movhi	r4,153
  1516b4:	2125a004 	addi	r4,r4,-27008
  1516b8:	100b883a 	mov	r5,r2
  1516bc:	0152bfc0 	call	152bfc <__divsi3>
  1516c0:	1007883a 	mov	r3,r2
  1516c4:	d0a5a417 	ldw	r2,-26992(gp)
  1516c8:	1885383a 	mul	r2,r3,r2
  1516cc:	e0bff915 	stw	r2,-28(fp)
	/* now convert to nanoseconds */
	d *= 100L;
  1516d0:	e0bff917 	ldw	r2,-28(fp)
  1516d4:	10801924 	muli	r2,r2,100
  1516d8:	e0bff915 	stw	r2,-28(fp)
	/* need to divide by 1000 to get to microseconds */
	units_adj = 1000;
  1516dc:	0080fa04 	movi	r2,1000
  1516e0:	e0bff815 	stw	r2,-32(fp)
  1516e4:	00001006 	br	151728 <display_trg_delay+0xf0>
    }
    else  {
        /* slow sweep rate, don't have to worry about overflow */
        d = delay * (1000000L / sweep_rates[sweep].sample_rate);
  1516e8:	d0a5a117 	ldw	r2,-27004(gp)
  1516ec:	00c00574 	movhi	r3,21
  1516f0:	18d51704 	addi	r3,r3,21596
  1516f4:	100490fa 	slli	r2,r2,3
  1516f8:	1885883a 	add	r2,r3,r2
  1516fc:	10800017 	ldw	r2,0(r2)
  151700:	010003f4 	movhi	r4,15
  151704:	21109004 	addi	r4,r4,16960
  151708:	100b883a 	mov	r5,r2
  15170c:	0152bfc0 	call	152bfc <__divsi3>
  151710:	1007883a 	mov	r3,r2
  151714:	d0a5a417 	ldw	r2,-26992(gp)
  151718:	1885383a 	mul	r2,r3,r2
  15171c:	e0bff915 	stw	r2,-28(fp)
	/* already in microseconds, so adjustment is 1 */
	units_adj = 1;
  151720:	00800044 	movi	r2,1
  151724:	e0bff815 	stw	r2,-32(fp)
    }

    /* convert it to the string (leave first character blank) */
    cvt_num_field(d, &delay_str[1]);
  151728:	e0bffa04 	addi	r2,fp,-24
  15172c:	10800044 	addi	r2,r2,1
  151730:	e13ff917 	ldw	r4,-28(fp)
  151734:	100b883a 	mov	r5,r2
  151738:	01518540 	call	151854 <cvt_num_field>

    /* add in the units */
    if (((d / units_adj) < 1000) && ((d / units_adj) > -1000) && (units_adj == 1000)) {
  15173c:	e13ff917 	ldw	r4,-28(fp)
  151740:	e17ff817 	ldw	r5,-32(fp)
  151744:	0152bfc0 	call	152bfc <__divsi3>
  151748:	1080fa08 	cmpgei	r2,r2,1000
  15174c:	10000d1e 	bne	r2,zero,151784 <display_trg_delay+0x14c>
  151750:	e13ff917 	ldw	r4,-28(fp)
  151754:	e17ff817 	ldw	r5,-32(fp)
  151758:	0152bfc0 	call	152bfc <__divsi3>
  15175c:	10bf0650 	cmplti	r2,r2,-999
  151760:	1000081e 	bne	r2,zero,151784 <display_trg_delay+0x14c>
  151764:	e0bff817 	ldw	r2,-32(fp)
  151768:	1080fa18 	cmpnei	r2,r2,1000
  15176c:	1000051e 	bne	r2,zero,151784 <display_trg_delay+0x14c>
        /* delay is in microseconds */
	delay_str[7] = '\004';
  151770:	00800104 	movi	r2,4
  151774:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
  151778:	00801cc4 	movi	r2,115
  15177c:	e0bffc05 	stb	r2,-16(fp)
  151780:	00002806 	br	151824 <display_trg_delay+0x1ec>
    }
    else if (((d / units_adj) < 1000000) && ((d / units_adj) > -1000000)) {
  151784:	e13ff917 	ldw	r4,-28(fp)
  151788:	e17ff817 	ldw	r5,-32(fp)
  15178c:	0152bfc0 	call	152bfc <__divsi3>
  151790:	00c003f4 	movhi	r3,15
  151794:	18d08fc4 	addi	r3,r3,16959
  151798:	18800c16 	blt	r3,r2,1517cc <display_trg_delay+0x194>
  15179c:	e13ff917 	ldw	r4,-28(fp)
  1517a0:	e17ff817 	ldw	r5,-32(fp)
  1517a4:	0152bfc0 	call	152bfc <__divsi3>
  1517a8:	1007883a 	mov	r3,r2
  1517ac:	00bffc74 	movhi	r2,65521
  1517b0:	10af7044 	addi	r2,r2,-16959
  1517b4:	18800516 	blt	r3,r2,1517cc <display_trg_delay+0x194>
        /* delay is in milliseconds */
	delay_str[7] = 'm';
  1517b8:	00801b44 	movi	r2,109
  1517bc:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
  1517c0:	00801cc4 	movi	r2,115
  1517c4:	e0bffc05 	stb	r2,-16(fp)
  1517c8:	00001606 	br	151824 <display_trg_delay+0x1ec>
    }
    else if (((d / units_adj) < 1000000000) && ((d / units_adj) > -1000000000))  {
  1517cc:	e13ff917 	ldw	r4,-28(fp)
  1517d0:	e17ff817 	ldw	r5,-32(fp)
  1517d4:	0152bfc0 	call	152bfc <__divsi3>
  1517d8:	00cee6f4 	movhi	r3,15259
  1517dc:	18f27fc4 	addi	r3,r3,-13825
  1517e0:	18800c16 	blt	r3,r2,151814 <display_trg_delay+0x1dc>
  1517e4:	e13ff917 	ldw	r4,-28(fp)
  1517e8:	e17ff817 	ldw	r5,-32(fp)
  1517ec:	0152bfc0 	call	152bfc <__divsi3>
  1517f0:	1007883a 	mov	r3,r2
  1517f4:	00b11974 	movhi	r2,50277
  1517f8:	108d8044 	addi	r2,r2,13825
  1517fc:	18800516 	blt	r3,r2,151814 <display_trg_delay+0x1dc>
        /* delay is in seconds */
	delay_str[7] = 's';
  151800:	00801cc4 	movi	r2,115
  151804:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = ' ';
  151808:	00800804 	movi	r2,32
  15180c:	e0bffc05 	stb	r2,-16(fp)
  151810:	00000406 	br	151824 <display_trg_delay+0x1ec>
    }
    else  {
        /* delay is in kiloseconds */
	delay_str[7] = 'k';
  151814:	00801ac4 	movi	r2,107
  151818:	e0bffbc5 	stb	r2,-17(fp)
	delay_str[8] = 's';
  15181c:	00801cc4 	movi	r2,115
  151820:	e0bffc05 	stb	r2,-16(fp)
    }


    /* now actually display the trigger delay */
    plot_string(x_pos, y_pos, delay_str, style);
  151824:	e0bfff17 	ldw	r2,-4(fp)
  151828:	e0fffa04 	addi	r3,fp,-24
  15182c:	e13ffd17 	ldw	r4,-12(fp)
  151830:	e17ffe17 	ldw	r5,-8(fp)
  151834:	180d883a 	mov	r6,r3
  151838:	100f883a 	mov	r7,r2
  15183c:	01506a00 	call	1506a0 <plot_string>


    /* all done displaying the trigger delay - return */
    return;

}
  151840:	e037883a 	mov	sp,fp
  151844:	dfc00117 	ldw	ra,4(sp)
  151848:	df000017 	ldw	fp,0(sp)
  15184c:	dec00204 	addi	sp,sp,8
  151850:	f800283a 	ret

00151854 <cvt_num_field>:
   Last Modified:    Mar. 8, 1994

*/

static void  cvt_num_field(long int n, char *s)
{
  151854:	defff804 	addi	sp,sp,-32
  151858:	dfc00715 	stw	ra,28(sp)
  15185c:	df000615 	stw	fp,24(sp)
  151860:	dc000515 	stw	r16,20(sp)
  151864:	df000504 	addi	fp,sp,20
  151868:	e13ffe15 	stw	r4,-8(fp)
  15186c:	e17fff15 	stw	r5,-4(fp)
    /* variables */
    int  dp = 3;		/* digits to right of decimal point */
  151870:	008000c4 	movi	r2,3
  151874:	e0bffb15 	stw	r2,-20(fp)
    int  d;			/* digit weight (power of 10) */

    int  i = 0;			/* string index */
  151878:	e03ffd15 	stw	zero,-12(fp)



    /* first get the sign (and make n positive for conversion) */
    if (n < 0)  {
  15187c:	e0bffe17 	ldw	r2,-8(fp)
  151880:	10000c0e 	bge	r2,zero,1518b4 <cvt_num_field+0x60>
        /* n is negative, set sign and convert to positive */
	s[i++] = '-';
  151884:	e0bffd17 	ldw	r2,-12(fp)
  151888:	e0ffff17 	ldw	r3,-4(fp)
  15188c:	1885883a 	add	r2,r3,r2
  151890:	00c00b44 	movi	r3,45
  151894:	10c00005 	stb	r3,0(r2)
  151898:	e0bffd17 	ldw	r2,-12(fp)
  15189c:	10800044 	addi	r2,r2,1
  1518a0:	e0bffd15 	stw	r2,-12(fp)
	n = -n;
  1518a4:	e0bffe17 	ldw	r2,-8(fp)
  1518a8:	0085c83a 	sub	r2,zero,r2
  1518ac:	e0bffe15 	stw	r2,-8(fp)
	s[i++] = '+';
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  1518b0:	00001106 	br	1518f8 <cvt_num_field+0xa4>
	s[i++] = '-';
	n = -n;
    }
    else  {
        /* n is positive, set sign only */
	s[i++] = '+';
  1518b4:	e0bffd17 	ldw	r2,-12(fp)
  1518b8:	e0ffff17 	ldw	r3,-4(fp)
  1518bc:	1885883a 	add	r2,r3,r2
  1518c0:	00c00ac4 	movi	r3,43
  1518c4:	10c00005 	stb	r3,0(r2)
  1518c8:	e0bffd17 	ldw	r2,-12(fp)
  1518cc:	10800044 	addi	r2,r2,1
  1518d0:	e0bffd15 	stw	r2,-12(fp)
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  1518d4:	00000806 	br	1518f8 <cvt_num_field+0xa4>
        /* have more than 4 digits - get rid of one */
	n /= 10;
  1518d8:	e0bffe17 	ldw	r2,-8(fp)
  1518dc:	1009883a 	mov	r4,r2
  1518e0:	01400284 	movi	r5,10
  1518e4:	0152bfc0 	call	152bfc <__divsi3>
  1518e8:	e0bffe15 	stw	r2,-8(fp)
	/* adjust the decimal point */
	dp--;
  1518ec:	e0bffb17 	ldw	r2,-20(fp)
  1518f0:	10bfffc4 	addi	r2,r2,-1
  1518f4:	e0bffb15 	stw	r2,-20(fp)
	s[i++] = '+';
    }


    /* make sure there are no more than 4 significant digits */
    while (n > 9999)  {
  1518f8:	e0bffe17 	ldw	r2,-8(fp)
  1518fc:	1089c408 	cmpgei	r2,r2,10000
  151900:	103ff51e 	bne	r2,zero,1518d8 <cvt_num_field+0x84>
	dp--;
    }

    /* if decimal point is non-positive, make positive */
    /* (assume will take care of adjustment with output units in this case) */
    while (dp <= 0)
  151904:	00000306 	br	151914 <cvt_num_field+0xc0>
       dp += 3;
  151908:	e0bffb17 	ldw	r2,-20(fp)
  15190c:	108000c4 	addi	r2,r2,3
  151910:	e0bffb15 	stw	r2,-20(fp)
	dp--;
    }

    /* if decimal point is non-positive, make positive */
    /* (assume will take care of adjustment with output units in this case) */
    while (dp <= 0)
  151914:	e0bffb17 	ldw	r2,-20(fp)
  151918:	00bffb0e 	bge	zero,r2,151908 <cvt_num_field+0xb4>
       dp += 3;


    /* adjust dp to be digits to the right of the decimal point */
    /* (assuming 4 digits) */
    dp = 4 - dp;
  15191c:	00c00104 	movi	r3,4
  151920:	e0bffb17 	ldw	r2,-20(fp)
  151924:	1885c83a 	sub	r2,r3,r2
  151928:	e0bffb15 	stw	r2,-20(fp)


    /* finally, loop getting and converting digits */
    for (d = 1000; d > 0; d /= 10)  {
  15192c:	0080fa04 	movi	r2,1000
  151930:	e0bffc15 	stw	r2,-16(fp)
  151934:	00002406 	br	1519c8 <cvt_num_field+0x174>

        /* check if need decimal the decimal point now */
	if (dp-- == 0)
  151938:	e0bffb17 	ldw	r2,-20(fp)
  15193c:	1005003a 	cmpeq	r2,r2,zero
  151940:	e0fffb17 	ldw	r3,-20(fp)
  151944:	18ffffc4 	addi	r3,r3,-1
  151948:	e0fffb15 	stw	r3,-20(fp)
  15194c:	10803fcc 	andi	r2,r2,255
  151950:	10000826 	beq	r2,zero,151974 <cvt_num_field+0x120>
	    /* time for decimal point */
	    s[i++] = '.';
  151954:	e0bffd17 	ldw	r2,-12(fp)
  151958:	e0ffff17 	ldw	r3,-4(fp)
  15195c:	1885883a 	add	r2,r3,r2
  151960:	00c00b84 	movi	r3,46
  151964:	10c00005 	stb	r3,0(r2)
  151968:	e0bffd17 	ldw	r2,-12(fp)
  15196c:	10800044 	addi	r2,r2,1
  151970:	e0bffd15 	stw	r2,-12(fp)

	/* get and convert this digit */
	s[i++] = (n / d) + '0';
  151974:	e0bffd17 	ldw	r2,-12(fp)
  151978:	e0ffff17 	ldw	r3,-4(fp)
  15197c:	18a1883a 	add	r16,r3,r2
  151980:	e13ffe17 	ldw	r4,-8(fp)
  151984:	e17ffc17 	ldw	r5,-16(fp)
  151988:	0152bfc0 	call	152bfc <__divsi3>
  15198c:	10800c04 	addi	r2,r2,48
  151990:	80800005 	stb	r2,0(r16)
  151994:	e0bffd17 	ldw	r2,-12(fp)
  151998:	10800044 	addi	r2,r2,1
  15199c:	e0bffd15 	stw	r2,-12(fp)
	/* remove this digit from n */
	n %= d;
  1519a0:	e0bffe17 	ldw	r2,-8(fp)
  1519a4:	1009883a 	mov	r4,r2
  1519a8:	e17ffc17 	ldw	r5,-16(fp)
  1519ac:	0152c4c0 	call	152c4c <__modsi3>
  1519b0:	e0bffe15 	stw	r2,-8(fp)
    /* (assuming 4 digits) */
    dp = 4 - dp;


    /* finally, loop getting and converting digits */
    for (d = 1000; d > 0; d /= 10)  {
  1519b4:	e0bffc17 	ldw	r2,-16(fp)
  1519b8:	1009883a 	mov	r4,r2
  1519bc:	01400284 	movi	r5,10
  1519c0:	0152bfc0 	call	152bfc <__divsi3>
  1519c4:	e0bffc15 	stw	r2,-16(fp)
  1519c8:	e0bffc17 	ldw	r2,-16(fp)
  1519cc:	00bfda16 	blt	zero,r2,151938 <cvt_num_field+0xe4>
	n %= d;
    }


    /* all done converting the number, return */
    return;
  1519d0:	0001883a 	nop

}
  1519d4:	e037883a 	mov	sp,fp
  1519d8:	dfc00217 	ldw	ra,8(sp)
  1519dc:	df000117 	ldw	fp,4(sp)
  1519e0:	dc000017 	ldw	r16,0(sp)
  1519e4:	dec00304 	addi	sp,sp,12
  1519e8:	f800283a 	ret

001519ec <clear_display>:


/* display functions  */

void  clear_display()
{
  1519ec:	deffff04 	addi	sp,sp,-4
  1519f0:	df000015 	stw	fp,0(sp)
  1519f4:	d839883a 	mov	fp,sp
    return;
  1519f8:	0001883a 	nop
}
  1519fc:	e037883a 	mov	sp,fp
  151a00:	df000017 	ldw	fp,0(sp)
  151a04:	dec00104 	addi	sp,sp,4
  151a08:	f800283a 	ret

00151a0c <plot_pixel>:

void  plot_pixel(unsigned int x, unsigned int y, int p)
{
  151a0c:	defffc04 	addi	sp,sp,-16
  151a10:	df000315 	stw	fp,12(sp)
  151a14:	df000304 	addi	fp,sp,12
  151a18:	e13ffd15 	stw	r4,-12(fp)
  151a1c:	e17ffe15 	stw	r5,-8(fp)
  151a20:	e1bfff15 	stw	r6,-4(fp)
    return;
  151a24:	0001883a 	nop
}
  151a28:	e037883a 	mov	sp,fp
  151a2c:	df000017 	ldw	fp,0(sp)
  151a30:	dec00104 	addi	sp,sp,4
  151a34:	f800283a 	ret

00151a38 <set_sample_rate>:


/* sampling parameter functions */

int  set_sample_rate(long int rate)
{
  151a38:	defffe04 	addi	sp,sp,-8
  151a3c:	df000115 	stw	fp,4(sp)
  151a40:	df000104 	addi	fp,sp,4
  151a44:	e13fff15 	stw	r4,-4(fp)
    return  SIZE_X;
  151a48:	00807804 	movi	r2,480
}
  151a4c:	e037883a 	mov	sp,fp
  151a50:	df000017 	ldw	fp,0(sp)
  151a54:	dec00104 	addi	sp,sp,4
  151a58:	f800283a 	ret

00151a5c <set_trigger>:

void  set_trigger(int level, int slope)
{
  151a5c:	defffd04 	addi	sp,sp,-12
  151a60:	df000215 	stw	fp,8(sp)
  151a64:	df000204 	addi	fp,sp,8
  151a68:	e13ffe15 	stw	r4,-8(fp)
  151a6c:	e17fff15 	stw	r5,-4(fp)
    return;
  151a70:	0001883a 	nop
}
  151a74:	e037883a 	mov	sp,fp
  151a78:	df000017 	ldw	fp,0(sp)
  151a7c:	dec00104 	addi	sp,sp,4
  151a80:	f800283a 	ret

00151a84 <set_delay>:

void  set_delay(long int delay)
{
  151a84:	defffe04 	addi	sp,sp,-8
  151a88:	df000115 	stw	fp,4(sp)
  151a8c:	df000104 	addi	fp,sp,4
  151a90:	e13fff15 	stw	r4,-4(fp)
    return;
  151a94:	0001883a 	nop
}
  151a98:	e037883a 	mov	sp,fp
  151a9c:	df000017 	ldw	fp,0(sp)
  151aa0:	dec00104 	addi	sp,sp,4
  151aa4:	f800283a 	ret

00151aa8 <start_sample>:


/* sampling functions */

void  start_sample(int auto_trigger)
{
  151aa8:	defffe04 	addi	sp,sp,-8
  151aac:	df000115 	stw	fp,4(sp)
  151ab0:	df000104 	addi	fp,sp,4
  151ab4:	e13fff15 	stw	r4,-4(fp)
    return;
  151ab8:	0001883a 	nop
}
  151abc:	e037883a 	mov	sp,fp
  151ac0:	df000017 	ldw	fp,0(sp)
  151ac4:	dec00104 	addi	sp,sp,4
  151ac8:	f800283a 	ret

00151acc <sample_done>:

unsigned char  *sample_done()
{
  151acc:	deffff04 	addi	sp,sp,-4
  151ad0:	df000015 	stw	fp,0(sp)
  151ad4:	d839883a 	mov	fp,sp
    return  NULL;
  151ad8:	0005883a 	mov	r2,zero
}
  151adc:	e037883a 	mov	sp,fp
  151ae0:	df000017 	ldw	fp,0(sp)
  151ae4:	dec00104 	addi	sp,sp,4
  151ae8:	f800283a 	ret

00151aec <get_test_sample>:
   Last Modified:    May 3, 2006

*/

void  get_test_sample(long int sample_rate, int sample_size, unsigned char *sample)
{
  151aec:	defff904 	addi	sp,sp,-28
  151af0:	dfc00615 	stw	ra,24(sp)
  151af4:	df000515 	stw	fp,20(sp)
  151af8:	df000504 	addi	fp,sp,20
  151afc:	e13ffd15 	stw	r4,-12(fp)
  151b00:	e17ffe15 	stw	r5,-8(fp)
  151b04:	e1bfff15 	stw	r6,-4(fp)
	    63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63,
	    63,  63,  63,  63,  63,  63,  64,  64,  64,  64,  64,  64,  64,
	    64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64,  64
	  };

    long int  sample_pt = 0;	/* current sample within the waveform */
  151b08:	e03ffb15 	stw	zero,-20(fp)

    int       sample_sign = 1;	/* sample waveform sign */
  151b0c:	00800044 	movi	r2,1
  151b10:	e0bffc15 	stw	r2,-16(fp)



    /* loop, getting sample points */
    while (sample_size-- > 0)  {
  151b14:	00003306 	br	151be4 <get_test_sample+0xf8>

        /* get this sample point (value based on sign) */
	if (sample_sign > 0)
  151b18:	e0bffc17 	ldw	r2,-16(fp)
  151b1c:	0080100e 	bge	zero,r2,151b60 <get_test_sample+0x74>
	    *sample++ = waveform[sample_pt/20] + 127;
  151b20:	e0bffb17 	ldw	r2,-20(fp)
  151b24:	1009883a 	mov	r4,r2
  151b28:	01400504 	movi	r5,20
  151b2c:	0152bfc0 	call	152bfc <__divsi3>
  151b30:	00c00574 	movhi	r3,21
  151b34:	18d55004 	addi	r3,r3,21824
  151b38:	1885883a 	add	r2,r3,r2
  151b3c:	10800003 	ldbu	r2,0(r2)
  151b40:	10801fc4 	addi	r2,r2,127
  151b44:	1007883a 	mov	r3,r2
  151b48:	e0bfff17 	ldw	r2,-4(fp)
  151b4c:	10c00005 	stb	r3,0(r2)
  151b50:	e0bfff17 	ldw	r2,-4(fp)
  151b54:	10800044 	addi	r2,r2,1
  151b58:	e0bfff15 	stw	r2,-4(fp)
  151b5c:	00001006 	br	151ba0 <get_test_sample+0xb4>
	else
	    *sample++ = 128 - waveform[sample_pt/20];
  151b60:	e0bffb17 	ldw	r2,-20(fp)
  151b64:	1009883a 	mov	r4,r2
  151b68:	01400504 	movi	r5,20
  151b6c:	0152bfc0 	call	152bfc <__divsi3>
  151b70:	00c00574 	movhi	r3,21
  151b74:	18d55004 	addi	r3,r3,21824
  151b78:	1885883a 	add	r2,r3,r2
  151b7c:	10800003 	ldbu	r2,0(r2)
  151b80:	00ffe004 	movi	r3,-128
  151b84:	1885c83a 	sub	r2,r3,r2
  151b88:	1007883a 	mov	r3,r2
  151b8c:	e0bfff17 	ldw	r2,-4(fp)
  151b90:	10c00005 	stb	r3,0(r2)
  151b94:	e0bfff17 	ldw	r2,-4(fp)
  151b98:	10800044 	addi	r2,r2,1
  151b9c:	e0bfff15 	stw	r2,-4(fp)

	/* compute the time for the next sample point */
	sample_pt += (10000000L / sample_rate);
  151ba0:	01002674 	movhi	r4,153
  151ba4:	2125a004 	addi	r4,r4,-27008
  151ba8:	e17ffd17 	ldw	r5,-12(fp)
  151bac:	0152bfc0 	call	152bfc <__divsi3>
  151bb0:	e0fffb17 	ldw	r3,-20(fp)
  151bb4:	1885883a 	add	r2,r3,r2
  151bb8:	e0bffb15 	stw	r2,-20(fp)
	/* keep sample_pt within the waveform (need to scale it) */
	while (sample_pt >= (20 * NO_TEST_PTS))  {
  151bbc:	00000606 	br	151bd8 <get_test_sample+0xec>
	    /* keep sample_pt within the test waveform */
	    sample_pt -= (20 * NO_TEST_PTS);
  151bc0:	e0bffb17 	ldw	r2,-20(fp)
  151bc4:	10b6a004 	addi	r2,r2,-9600
  151bc8:	e0bffb15 	stw	r2,-20(fp)
	    /* each time through the waveform, invert it */
	    sample_sign = -sample_sign;
  151bcc:	e0bffc17 	ldw	r2,-16(fp)
  151bd0:	0085c83a 	sub	r2,zero,r2
  151bd4:	e0bffc15 	stw	r2,-16(fp)
	    *sample++ = 128 - waveform[sample_pt/20];

	/* compute the time for the next sample point */
	sample_pt += (10000000L / sample_rate);
	/* keep sample_pt within the waveform (need to scale it) */
	while (sample_pt >= (20 * NO_TEST_PTS))  {
  151bd8:	e0bffb17 	ldw	r2,-20(fp)
  151bdc:	10896028 	cmpgeui	r2,r2,9600
  151be0:	103ff71e 	bne	r2,zero,151bc0 <get_test_sample+0xd4>
    int       sample_sign = 1;	/* sample waveform sign */



    /* loop, getting sample points */
    while (sample_size-- > 0)  {
  151be4:	e0bffe17 	ldw	r2,-8(fp)
  151be8:	0084803a 	cmplt	r2,zero,r2
  151bec:	e0fffe17 	ldw	r3,-8(fp)
  151bf0:	18ffffc4 	addi	r3,r3,-1
  151bf4:	e0fffe15 	stw	r3,-8(fp)
  151bf8:	10803fcc 	andi	r2,r2,255
  151bfc:	103fc61e 	bne	r2,zero,151b18 <get_test_sample+0x2c>
        }
    }


    /* done getting the sample - return */
    return;
  151c00:	0001883a 	nop

}
  151c04:	e037883a 	mov	sp,fp
  151c08:	dfc00117 	ldw	ra,4(sp)
  151c0c:	df000017 	ldw	fp,0(sp)
  151c10:	dec00204 	addi	sp,sp,8
  151c14:	f800283a 	ret

00151c18 <init_trace>:
   Last Modified:    May 9, 2006

*/

void  init_trace()
{
  151c18:	defffe04 	addi	sp,sp,-8
  151c1c:	dfc00115 	stw	ra,4(sp)
  151c20:	df000015 	stw	fp,0(sp)
  151c24:	d839883a 	mov	fp,sp


    /* initialize system status variables */

    /* ready for a trace */
    trace_status = TRUE;
  151c28:	00800044 	movi	r2,1
  151c2c:	d0a5a515 	stw	r2,-26988(gp)

    /* not currently sampling data */
    sampling = FALSE;
  151c30:	d025a615 	stw	zero,-26984(gp)

    /* turn off the displayed scale */
    cur_scale = SCALE_NONE;
  151c34:	d025a815 	stw	zero,-26976(gp)

    /* sample size is the screen size */
    sample_size = SIZE_X;
  151c38:	00807804 	movi	r2,480
  151c3c:	d0a5a715 	stw	r2,-26980(gp)


    /* clear save areas */
    clear_saved_areas();
  151c40:	015216c0 	call	15216c <clear_saved_areas>

    /* also clear the general saved area location variables (off-screen) */
    saved_pos_x = SIZE_X + 1;
  151c44:	00807844 	movi	r2,481
  151c48:	d0a5a915 	stw	r2,-26972(gp)
    saved_pos_y = SIZE_Y + 1;
  151c4c:	00802044 	movi	r2,129
  151c50:	d0a5aa15 	stw	r2,-26968(gp)
    saved_end_x = SIZE_X + 1;
  151c54:	00807844 	movi	r2,481
  151c58:	d0a5ab15 	stw	r2,-26964(gp)
    saved_end_y = SIZE_Y + 1;
  151c5c:	00802044 	movi	r2,129
  151c60:	d0a5ac15 	stw	r2,-26960(gp)


    /* done initializing, return */
    return;
  151c64:	0001883a 	nop

}
  151c68:	e037883a 	mov	sp,fp
  151c6c:	dfc00117 	ldw	ra,4(sp)
  151c70:	df000017 	ldw	fp,0(sp)
  151c74:	dec00204 	addi	sp,sp,8
  151c78:	f800283a 	ret

00151c7c <set_mode>:
   Last Modified:    May 27, 2008

*/

void  set_mode(enum trigger_type trigger_mode)
{
  151c7c:	defffe04 	addi	sp,sp,-8
  151c80:	df000115 	stw	fp,4(sp)
  151c84:	df000104 	addi	fp,sp,4
  151c88:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* if not one-shot triggering - ready for trace too */
    trace_status = (trigger_mode != ONESHOT_TRIGGER);
  151c8c:	e0bfff17 	ldw	r2,-4(fp)
  151c90:	10800098 	cmpnei	r2,r2,2
  151c94:	10803fcc 	andi	r2,r2,255
  151c98:	d0a5a515 	stw	r2,-26988(gp)


    /* turn off the sampling flag so will start a new sample */
    sampling = FALSE;
  151c9c:	d025a615 	stw	zero,-26984(gp)


    /* all done, return */
    return;
  151ca0:	0001883a 	nop

}
  151ca4:	e037883a 	mov	sp,fp
  151ca8:	df000017 	ldw	fp,0(sp)
  151cac:	dec00104 	addi	sp,sp,4
  151cb0:	f800283a 	ret

00151cb4 <is_sampling>:
   Last Modified:    May 27, 2008

*/

int  is_sampling()
{
  151cb4:	deffff04 	addi	sp,sp,-4
  151cb8:	df000015 	stw	fp,0(sp)
  151cbc:	d839883a 	mov	fp,sp
      /* none */



    /* currently sampling if sampling flag is set */
    return  sampling;
  151cc0:	d0a5a617 	ldw	r2,-26984(gp)

}
  151cc4:	e037883a 	mov	sp,fp
  151cc8:	df000017 	ldw	fp,0(sp)
  151ccc:	dec00104 	addi	sp,sp,4
  151cd0:	f800283a 	ret

00151cd4 <trace_rdy>:
   Last Modified:    Mar. 13, 1994

*/

int  trace_rdy()
{
  151cd4:	deffff04 	addi	sp,sp,-4
  151cd8:	df000015 	stw	fp,0(sp)
  151cdc:	d839883a 	mov	fp,sp
      /* none */



    /* ready for another trace if not sampling and trace is ready */
    return  (!sampling && trace_status);
  151ce0:	d0a5a617 	ldw	r2,-26984(gp)
  151ce4:	1000041e 	bne	r2,zero,151cf8 <trace_rdy+0x24>
  151ce8:	d0a5a517 	ldw	r2,-26988(gp)
  151cec:	10000226 	beq	r2,zero,151cf8 <trace_rdy+0x24>
  151cf0:	00800044 	movi	r2,1
  151cf4:	00000106 	br	151cfc <trace_rdy+0x28>
  151cf8:	0005883a 	mov	r2,zero

}
  151cfc:	e037883a 	mov	sp,fp
  151d00:	df000017 	ldw	fp,0(sp)
  151d04:	dec00104 	addi	sp,sp,4
  151d08:	f800283a 	ret

00151d0c <trace_done>:
   Last Modified:    May 9, 2006

*/

void  trace_done()
{
  151d0c:	defffe04 	addi	sp,sp,-8
  151d10:	dfc00115 	stw	ra,4(sp)
  151d14:	df000015 	stw	fp,0(sp)
  151d18:	d839883a 	mov	fp,sp
      /* none */



    /* done with a trace - if retriggering, ready for another one */
    if (get_trigger_mode() != ONESHOT_TRIGGER)
  151d1c:	0150d900 	call	150d90 <get_trigger_mode>
  151d20:	108000a0 	cmpeqi	r2,r2,2
  151d24:	1000021e 	bne	r2,zero,151d30 <trace_done+0x24>
        /* in a retriggering mode - set trace_status to TRUE (ready) */
	trace_status = TRUE;
  151d28:	00800044 	movi	r2,1
  151d2c:	d0a5a515 	stw	r2,-26988(gp)

    /* no longer sampling data */
    sampling = FALSE;
  151d30:	d025a615 	stw	zero,-26984(gp)


    /* done so return */
    return;
  151d34:	0001883a 	nop

}
  151d38:	e037883a 	mov	sp,fp
  151d3c:	dfc00117 	ldw	ra,4(sp)
  151d40:	df000017 	ldw	fp,0(sp)
  151d44:	dec00204 	addi	sp,sp,8
  151d48:	f800283a 	ret

00151d4c <trace_rearm>:
   Last Modified:    Mar. 8, 1994

*/

void  trace_rearm()
{
  151d4c:	deffff04 	addi	sp,sp,-4
  151d50:	df000015 	stw	fp,0(sp)
  151d54:	d839883a 	mov	fp,sp
      /* none */



    /* rearm the trace - set status to ready (TRUE) */
    trace_status = TRUE;
  151d58:	00800044 	movi	r2,1
  151d5c:	d0a5a515 	stw	r2,-26988(gp)


    /* all done - return */
    return;
  151d60:	0001883a 	nop

}
  151d64:	e037883a 	mov	sp,fp
  151d68:	df000017 	ldw	fp,0(sp)
  151d6c:	dec00104 	addi	sp,sp,4
  151d70:	f800283a 	ret

00151d74 <set_trace_size>:
   Last Modified:    Mar. 8, 1994

*/

void  set_trace_size(int size)
{
  151d74:	defffe04 	addi	sp,sp,-8
  151d78:	df000115 	stw	fp,4(sp)
  151d7c:	df000104 	addi	fp,sp,4
  151d80:	e13fff15 	stw	r4,-4(fp)
      /* none */



    /* set the locally global sample size */
    sample_size = size;
  151d84:	e0bfff17 	ldw	r2,-4(fp)
  151d88:	d0a5a715 	stw	r2,-26980(gp)


    /* all done, return */
    return;
  151d8c:	0001883a 	nop

}
  151d90:	e037883a 	mov	sp,fp
  151d94:	df000017 	ldw	fp,0(sp)
  151d98:	dec00104 	addi	sp,sp,4
  151d9c:	f800283a 	ret

00151da0 <set_display_scale>:
   Last Modified:    May 9, 2006

*/

void  set_display_scale(enum scale_type scale)
{
  151da0:	defffa04 	addi	sp,sp,-24
  151da4:	dfc00515 	stw	ra,20(sp)
  151da8:	df000415 	stw	fp,16(sp)
  151dac:	df000404 	addi	fp,sp,16
  151db0:	e13fff15 	stw	r4,-4(fp)



    /* whenever change scale type, need to clear out previous scale */
    /* unnecessary if going to SCALE_GRID or from SCALE_NONE or not changing the scale */
    if ((scale != SCALE_GRID) && (cur_scale != SCALE_NONE) && (scale != cur_scale))  {
  151db4:	e0bfff17 	ldw	r2,-4(fp)
  151db8:	108000a0 	cmpeqi	r2,r2,2
  151dbc:	10008d1e 	bne	r2,zero,151ff4 <set_display_scale+0x254>
  151dc0:	d0a5a817 	ldw	r2,-26976(gp)
  151dc4:	10008b26 	beq	r2,zero,151ff4 <set_display_scale+0x254>
  151dc8:	d0a5a817 	ldw	r2,-26976(gp)
  151dcc:	e0ffff17 	ldw	r3,-4(fp)
  151dd0:	18808826 	beq	r3,r2,151ff4 <set_display_scale+0x254>

        /* need to restore the trace under the lines (tick, grid, or axis) */

	/* go through all points on horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  151dd4:	00bfffc4 	movi	r2,-1
  151dd8:	e0bffe15 	stw	r2,-8(fp)
  151ddc:	00003e06 	br	151ed8 <set_display_scale+0x138>

	    /* get y position of the line */
	    p = X_AXIS_POS + j * Y_TICK_SIZE;
  151de0:	e0bffe17 	ldw	r2,-8(fp)
  151de4:	10800c24 	muli	r2,r2,48
  151de8:	10801004 	addi	r2,r2,64
  151dec:	e0bffc15 	stw	r2,-16(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_Y)
  151df0:	e0bffc17 	ldw	r2,-16(fp)
  151df4:	10802010 	cmplti	r2,r2,128
  151df8:	1000021e 	bne	r2,zero,151e04 <set_display_scale+0x64>
	        p = PLOT_SIZE_Y - 1;
  151dfc:	00801fc4 	movi	r2,127
  151e00:	e0bffc15 	stw	r2,-16(fp)
	    if (p < 0)
  151e04:	e0bffc17 	ldw	r2,-16(fp)
  151e08:	1000010e 	bge	r2,zero,151e10 <set_display_scale+0x70>
	        p = 0;
  151e0c:	e03ffc15 	stw	zero,-16(fp)

	    /* look at entire horizontal line */
	    for (i = 0; i < PLOT_SIZE_X; i++)  {
  151e10:	e03ffd15 	stw	zero,-12(fp)
  151e14:	00002a06 	br	151ec0 <set_display_scale+0x120>
	        /* check if this point is on or off (need to look at bits) */
		if ((saved_axis_x[j + Y_TICK_CNT][i / 8] & (0x80 >> (i % 8))) == 0)
  151e18:	e0bffe17 	ldw	r2,-8(fp)
  151e1c:	11000044 	addi	r4,r2,1
  151e20:	e0bffd17 	ldw	r2,-12(fp)
  151e24:	1000010e 	bge	r2,zero,151e2c <set_display_scale+0x8c>
  151e28:	108001c4 	addi	r2,r2,7
  151e2c:	1005d0fa 	srai	r2,r2,3
  151e30:	00c005b4 	movhi	r3,22
  151e34:	18e10904 	addi	r3,r3,-31708
  151e38:	21000f24 	muli	r4,r4,60
  151e3c:	2085883a 	add	r2,r4,r2
  151e40:	1885883a 	add	r2,r3,r2
  151e44:	10800003 	ldbu	r2,0(r2)
  151e48:	10c03fcc 	andi	r3,r2,255
  151e4c:	e13ffd17 	ldw	r4,-12(fp)
  151e50:	00a00034 	movhi	r2,32768
  151e54:	108001c4 	addi	r2,r2,7
  151e58:	2084703a 	and	r2,r4,r2
  151e5c:	1000040e 	bge	r2,zero,151e70 <set_display_scale+0xd0>
  151e60:	10bfffc4 	addi	r2,r2,-1
  151e64:	013ffe04 	movi	r4,-8
  151e68:	1104b03a 	or	r2,r2,r4
  151e6c:	10800044 	addi	r2,r2,1
  151e70:	01002004 	movi	r4,128
  151e74:	2085d83a 	sra	r2,r4,r2
  151e78:	1884703a 	and	r2,r3,r2
  151e7c:	1000071e 	bne	r2,zero,151e9c <set_display_scale+0xfc>
		    /* saved pixel is off */
		    plot_pixel(i, p, PIXEL_WHITE);
  151e80:	e0fffd17 	ldw	r3,-12(fp)
  151e84:	e0bffc17 	ldw	r2,-16(fp)
  151e88:	1809883a 	mov	r4,r3
  151e8c:	100b883a 	mov	r5,r2
  151e90:	000d883a 	mov	r6,zero
  151e94:	0151a0c0 	call	151a0c <plot_pixel>
  151e98:	00000606 	br	151eb4 <set_display_scale+0x114>
		else
		    /* saved pixel is on */
		    plot_pixel(i, p, PIXEL_BLACK);
  151e9c:	e0fffd17 	ldw	r3,-12(fp)
  151ea0:	e0bffc17 	ldw	r2,-16(fp)
  151ea4:	1809883a 	mov	r4,r3
  151ea8:	100b883a 	mov	r5,r2
  151eac:	01800044 	movi	r6,1
  151eb0:	0151a0c0 	call	151a0c <plot_pixel>
	        p = PLOT_SIZE_Y - 1;
	    if (p < 0)
	        p = 0;

	    /* look at entire horizontal line */
	    for (i = 0; i < PLOT_SIZE_X; i++)  {
  151eb4:	e0bffd17 	ldw	r2,-12(fp)
  151eb8:	10800044 	addi	r2,r2,1
  151ebc:	e0bffd15 	stw	r2,-12(fp)
  151ec0:	e0bffd17 	ldw	r2,-12(fp)
  151ec4:	10807810 	cmplti	r2,r2,480
  151ec8:	103fd31e 	bne	r2,zero,151e18 <set_display_scale+0x78>
    if ((scale != SCALE_GRID) && (cur_scale != SCALE_NONE) && (scale != cur_scale))  {

        /* need to restore the trace under the lines (tick, grid, or axis) */

	/* go through all points on horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  151ecc:	e0bffe17 	ldw	r2,-8(fp)
  151ed0:	10800044 	addi	r2,r2,1
  151ed4:	e0bffe15 	stw	r2,-8(fp)
  151ed8:	e0bffe17 	ldw	r2,-8(fp)
  151edc:	10800090 	cmplti	r2,r2,2
  151ee0:	103fbf1e 	bne	r2,zero,151de0 <set_display_scale+0x40>
		    plot_pixel(i, p, PIXEL_BLACK);
	    }
	}

	/* go through all points on vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  151ee4:	00bffec4 	movi	r2,-5
  151ee8:	e0bffe15 	stw	r2,-8(fp)
  151eec:	00003e06 	br	151fe8 <set_display_scale+0x248>

	    /* get x position of the line */
	    p = Y_AXIS_POS + j * X_TICK_SIZE;
  151ef0:	e0bffe17 	ldw	r2,-8(fp)
  151ef4:	10800c24 	muli	r2,r2,48
  151ef8:	10803c04 	addi	r2,r2,240
  151efc:	e0bffc15 	stw	r2,-16(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_X)
  151f00:	e0bffc17 	ldw	r2,-16(fp)
  151f04:	10807810 	cmplti	r2,r2,480
  151f08:	1000021e 	bne	r2,zero,151f14 <set_display_scale+0x174>
	        p = PLOT_SIZE_X - 1;
  151f0c:	008077c4 	movi	r2,479
  151f10:	e0bffc15 	stw	r2,-16(fp)
	    if (p < 0)
  151f14:	e0bffc17 	ldw	r2,-16(fp)
  151f18:	1000010e 	bge	r2,zero,151f20 <set_display_scale+0x180>
	        p = 0;
  151f1c:	e03ffc15 	stw	zero,-16(fp)

	    /* look at entire vertical line */
	    for (i = 0; i < PLOT_SIZE_Y; i++)  {
  151f20:	e03ffd15 	stw	zero,-12(fp)
  151f24:	00002a06 	br	151fd0 <set_display_scale+0x230>
	        /* check if this point is on or off (need to look at bits) */
		if ((saved_axis_y[j + X_TICK_CNT][i / 8] & (0x80 >> (i % 8))) == 0)
  151f28:	e0bffe17 	ldw	r2,-8(fp)
  151f2c:	11000144 	addi	r4,r2,5
  151f30:	e0bffd17 	ldw	r2,-12(fp)
  151f34:	1000010e 	bge	r2,zero,151f3c <set_display_scale+0x19c>
  151f38:	108001c4 	addi	r2,r2,7
  151f3c:	1005d0fa 	srai	r2,r2,3
  151f40:	00c005b4 	movhi	r3,22
  151f44:	18e13604 	addi	r3,r3,-31528
  151f48:	2008913a 	slli	r4,r4,4
  151f4c:	2085883a 	add	r2,r4,r2
  151f50:	1885883a 	add	r2,r3,r2
  151f54:	10800003 	ldbu	r2,0(r2)
  151f58:	10c03fcc 	andi	r3,r2,255
  151f5c:	e13ffd17 	ldw	r4,-12(fp)
  151f60:	00a00034 	movhi	r2,32768
  151f64:	108001c4 	addi	r2,r2,7
  151f68:	2084703a 	and	r2,r4,r2
  151f6c:	1000040e 	bge	r2,zero,151f80 <set_display_scale+0x1e0>
  151f70:	10bfffc4 	addi	r2,r2,-1
  151f74:	013ffe04 	movi	r4,-8
  151f78:	1104b03a 	or	r2,r2,r4
  151f7c:	10800044 	addi	r2,r2,1
  151f80:	01002004 	movi	r4,128
  151f84:	2085d83a 	sra	r2,r4,r2
  151f88:	1884703a 	and	r2,r3,r2
  151f8c:	1000071e 	bne	r2,zero,151fac <set_display_scale+0x20c>
		    /* saved pixel is off */
		    plot_pixel(p, i, PIXEL_WHITE);
  151f90:	e0fffc17 	ldw	r3,-16(fp)
  151f94:	e0bffd17 	ldw	r2,-12(fp)
  151f98:	1809883a 	mov	r4,r3
  151f9c:	100b883a 	mov	r5,r2
  151fa0:	000d883a 	mov	r6,zero
  151fa4:	0151a0c0 	call	151a0c <plot_pixel>
  151fa8:	00000606 	br	151fc4 <set_display_scale+0x224>
		else
		    /* saved pixel is on */
		    plot_pixel(p, i, PIXEL_BLACK);
  151fac:	e0fffc17 	ldw	r3,-16(fp)
  151fb0:	e0bffd17 	ldw	r2,-12(fp)
  151fb4:	1809883a 	mov	r4,r3
  151fb8:	100b883a 	mov	r5,r2
  151fbc:	01800044 	movi	r6,1
  151fc0:	0151a0c0 	call	151a0c <plot_pixel>
	        p = PLOT_SIZE_X - 1;
	    if (p < 0)
	        p = 0;

	    /* look at entire vertical line */
	    for (i = 0; i < PLOT_SIZE_Y; i++)  {
  151fc4:	e0bffd17 	ldw	r2,-12(fp)
  151fc8:	10800044 	addi	r2,r2,1
  151fcc:	e0bffd15 	stw	r2,-12(fp)
  151fd0:	e0bffd17 	ldw	r2,-12(fp)
  151fd4:	10802010 	cmplti	r2,r2,128
  151fd8:	103fd31e 	bne	r2,zero,151f28 <set_display_scale+0x188>
		    plot_pixel(i, p, PIXEL_BLACK);
	    }
	}

	/* go through all points on vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  151fdc:	e0bffe17 	ldw	r2,-8(fp)
  151fe0:	10800044 	addi	r2,r2,1
  151fe4:	e0bffe15 	stw	r2,-8(fp)
  151fe8:	e0bffe17 	ldw	r2,-8(fp)
  151fec:	10800190 	cmplti	r2,r2,6
  151ff0:	103fbf1e 	bne	r2,zero,151ef0 <set_display_scale+0x150>
	}
    }


    /* now handle the scale type appropriately */
    switch (scale)  {
  151ff4:	e0bfff17 	ldw	r2,-4(fp)
  151ff8:	10005326 	beq	r2,zero,152148 <set_display_scale+0x3a8>
  151ffc:	108000e8 	cmpgeui	r2,r2,3
  152000:	1000521e 	bne	r2,zero,15214c <set_display_scale+0x3ac>

    	case SCALE_AXES:    /* axes for the scale */
    	case SCALE_GRID:    /* grid for the scale */

		            /* draw x lines (grid or tick marks) */
			    for (i = -Y_TICK_CNT; i <= Y_TICK_CNT; i++)  {
  152004:	00bfffc4 	movi	r2,-1
  152008:	e0bffd15 	stw	r2,-12(fp)
  15200c:	00002206 	br	152098 <set_display_scale+0x2f8>

				/* get y position of the line */
				p = X_AXIS_POS + i * Y_TICK_SIZE;
  152010:	e0bffd17 	ldw	r2,-12(fp)
  152014:	10800c24 	muli	r2,r2,48
  152018:	10801004 	addi	r2,r2,64
  15201c:	e0bffc15 	stw	r2,-16(fp)
				/* make sure it is in range */
				if (p >= PLOT_SIZE_Y)
  152020:	e0bffc17 	ldw	r2,-16(fp)
  152024:	10802010 	cmplti	r2,r2,128
  152028:	1000021e 	bne	r2,zero,152034 <set_display_scale+0x294>
				    p = PLOT_SIZE_Y - 1;
  15202c:	00801fc4 	movi	r2,127
  152030:	e0bffc15 	stw	r2,-16(fp)
				if (p < 0)
  152034:	e0bffc17 	ldw	r2,-16(fp)
  152038:	1000010e 	bge	r2,zero,152040 <set_display_scale+0x2a0>
				    p = 0;
  15203c:	e03ffc15 	stw	zero,-16(fp)

				/* should we draw a grid, an axis, or a tick mark */
				if (scale == SCALE_GRID)
  152040:	e0bfff17 	ldw	r2,-4(fp)
  152044:	10800098 	cmpnei	r2,r2,2
  152048:	1000051e 	bne	r2,zero,152060 <set_display_scale+0x2c0>
				    /* drawing a grid line */
			            plot_hline(X_GRID_START, p, (X_GRID_END - X_GRID_START));
  15204c:	0009883a 	mov	r4,zero
  152050:	e17ffc17 	ldw	r5,-16(fp)
  152054:	018077c4 	movi	r6,479
  152058:	01503e00 	call	1503e0 <plot_hline>
  15205c:	00000b06 	br	15208c <set_display_scale+0x2ec>
				else if (i == 0)
  152060:	e0bffd17 	ldw	r2,-12(fp)
  152064:	1000051e 	bne	r2,zero,15207c <set_display_scale+0x2dc>
				    /* drawing the x axis */
			            plot_hline(X_AXIS_START, p, (X_AXIS_END - X_AXIS_START));
  152068:	0009883a 	mov	r4,zero
  15206c:	e17ffc17 	ldw	r5,-16(fp)
  152070:	018077c4 	movi	r6,479
  152074:	01503e00 	call	1503e0 <plot_hline>
  152078:	00000406 	br	15208c <set_display_scale+0x2ec>
				else
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
  15207c:	01003b84 	movi	r4,238
  152080:	e17ffc17 	ldw	r5,-16(fp)
  152084:	01800144 	movi	r6,5
  152088:	01503e00 	call	1503e0 <plot_hline>

    	case SCALE_AXES:    /* axes for the scale */
    	case SCALE_GRID:    /* grid for the scale */

		            /* draw x lines (grid or tick marks) */
			    for (i = -Y_TICK_CNT; i <= Y_TICK_CNT; i++)  {
  15208c:	e0bffd17 	ldw	r2,-12(fp)
  152090:	10800044 	addi	r2,r2,1
  152094:	e0bffd15 	stw	r2,-12(fp)
  152098:	e0bffd17 	ldw	r2,-12(fp)
  15209c:	10800090 	cmplti	r2,r2,2
  1520a0:	103fdb1e 	bne	r2,zero,152010 <set_display_scale+0x270>
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
			    }

		            /* draw y lines (grid or tick marks) */
			    for (i = -X_TICK_CNT; i <= X_TICK_CNT; i++)  {
  1520a4:	00bffec4 	movi	r2,-5
  1520a8:	e0bffd15 	stw	r2,-12(fp)
  1520ac:	00002206 	br	152138 <set_display_scale+0x398>

				/* get x position of the line */
				p = Y_AXIS_POS + i * X_TICK_SIZE;
  1520b0:	e0bffd17 	ldw	r2,-12(fp)
  1520b4:	10800c24 	muli	r2,r2,48
  1520b8:	10803c04 	addi	r2,r2,240
  1520bc:	e0bffc15 	stw	r2,-16(fp)
				/* make sure it is in range */
				if (p >= PLOT_SIZE_X)
  1520c0:	e0bffc17 	ldw	r2,-16(fp)
  1520c4:	10807810 	cmplti	r2,r2,480
  1520c8:	1000021e 	bne	r2,zero,1520d4 <set_display_scale+0x334>
				    p = PLOT_SIZE_X - 1;
  1520cc:	008077c4 	movi	r2,479
  1520d0:	e0bffc15 	stw	r2,-16(fp)
			        if (p < 0)
  1520d4:	e0bffc17 	ldw	r2,-16(fp)
  1520d8:	1000010e 	bge	r2,zero,1520e0 <set_display_scale+0x340>
				    p = 0;
  1520dc:	e03ffc15 	stw	zero,-16(fp)

				/* should we draw a grid, an axis, or a tick mark */
				if (scale == SCALE_GRID)
  1520e0:	e0bfff17 	ldw	r2,-4(fp)
  1520e4:	10800098 	cmpnei	r2,r2,2
  1520e8:	1000051e 	bne	r2,zero,152100 <set_display_scale+0x360>
				    /* drawing a grid line */
			            plot_vline(p, Y_GRID_START, (Y_GRID_END - Y_GRID_START));
  1520ec:	e13ffc17 	ldw	r4,-16(fp)
  1520f0:	000b883a 	mov	r5,zero
  1520f4:	01801fc4 	movi	r6,127
  1520f8:	015048c0 	call	15048c <plot_vline>
  1520fc:	00000b06 	br	15212c <set_display_scale+0x38c>
				else if (i == 0)
  152100:	e0bffd17 	ldw	r2,-12(fp)
  152104:	1000051e 	bne	r2,zero,15211c <set_display_scale+0x37c>
				    /* drawing the y axis */
			            plot_vline(p, Y_AXIS_START, (Y_AXIS_END - Y_AXIS_START));
  152108:	e13ffc17 	ldw	r4,-16(fp)
  15210c:	000b883a 	mov	r5,zero
  152110:	01801fc4 	movi	r6,127
  152114:	015048c0 	call	15048c <plot_vline>
  152118:	00000406 	br	15212c <set_display_scale+0x38c>
				else
				    /* must be drawing a tick mark */
			            plot_vline(p, (X_AXIS_POS - (TICK_LEN / 2)), TICK_LEN);
  15211c:	e13ffc17 	ldw	r4,-16(fp)
  152120:	01400f84 	movi	r5,62
  152124:	01800144 	movi	r6,5
  152128:	015048c0 	call	15048c <plot_vline>
				    /* must be drawing a tick mark */
			            plot_hline((Y_AXIS_POS - (TICK_LEN / 2)), p, TICK_LEN);
			    }

		            /* draw y lines (grid or tick marks) */
			    for (i = -X_TICK_CNT; i <= X_TICK_CNT; i++)  {
  15212c:	e0bffd17 	ldw	r2,-12(fp)
  152130:	10800044 	addi	r2,r2,1
  152134:	e0bffd15 	stw	r2,-12(fp)
  152138:	e0bffd17 	ldw	r2,-12(fp)
  15213c:	10800190 	cmplti	r2,r2,6
  152140:	103fdb1e 	bne	r2,zero,1520b0 <set_display_scale+0x310>
				    /* must be drawing a tick mark */
			            plot_vline(p, (X_AXIS_POS - (TICK_LEN / 2)), TICK_LEN);
			    }

			    /* done with the axes */
			    break;
  152144:	00000106 	br	15214c <set_display_scale+0x3ac>

        case SCALE_NONE:    /* there is no scale */
			    /* already restored plot so nothing to do */
			    break;
  152148:	0001883a 	nop

    }


    /* now remember the new (now current) scale type */
    cur_scale = scale;
  15214c:	e0bfff17 	ldw	r2,-4(fp)
  152150:	d0a5a815 	stw	r2,-26976(gp)


    /* scale is taken care of, return */
    return;
  152154:	0001883a 	nop

}
  152158:	e037883a 	mov	sp,fp
  15215c:	dfc00117 	ldw	ra,4(sp)
  152160:	df000017 	ldw	fp,0(sp)
  152164:	dec00204 	addi	sp,sp,8
  152168:	f800283a 	ret

0015216c <clear_saved_areas>:
   Last Modified:    May 9, 2006

*/

void  clear_saved_areas()
{
  15216c:	defffd04 	addi	sp,sp,-12
  152170:	df000215 	stw	fp,8(sp)
  152174:	df000204 	addi	fp,sp,8
    int  j;



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
  152178:	e03fff15 	stw	zero,-4(fp)
  15217c:	00001306 	br	1521cc <clear_saved_areas+0x60>
        for (i = 0; i < (SIZE_X / 8); i++)
  152180:	e03ffe15 	stw	zero,-8(fp)
  152184:	00000b06 	br	1521b4 <clear_saved_areas+0x48>
            saved_axis_x[j][i] = 0;
  152188:	00c005b4 	movhi	r3,22
  15218c:	18e10904 	addi	r3,r3,-31708
  152190:	e0bfff17 	ldw	r2,-4(fp)
  152194:	11000f24 	muli	r4,r2,60
  152198:	e0bffe17 	ldw	r2,-8(fp)
  15219c:	2085883a 	add	r2,r4,r2
  1521a0:	1885883a 	add	r2,r3,r2
  1521a4:	10000005 	stb	zero,0(r2)



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
  1521a8:	e0bffe17 	ldw	r2,-8(fp)
  1521ac:	10800044 	addi	r2,r2,1
  1521b0:	e0bffe15 	stw	r2,-8(fp)
  1521b4:	e0bffe17 	ldw	r2,-8(fp)
  1521b8:	10800f10 	cmplti	r2,r2,60
  1521bc:	103ff21e 	bne	r2,zero,152188 <clear_saved_areas+0x1c>
    int  j;



    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
  1521c0:	e0bfff17 	ldw	r2,-4(fp)
  1521c4:	10800044 	addi	r2,r2,1
  1521c8:	e0bfff15 	stw	r2,-4(fp)
  1521cc:	e0bfff17 	ldw	r2,-4(fp)
  1521d0:	108000d0 	cmplti	r2,r2,3
  1521d4:	103fea1e 	bne	r2,zero,152180 <clear_saved_areas+0x14>
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
  1521d8:	e03fff15 	stw	zero,-4(fp)
  1521dc:	00001306 	br	15222c <clear_saved_areas+0xc0>
        for (i = 0; i < (SIZE_Y / 8); i++)
  1521e0:	e03ffe15 	stw	zero,-8(fp)
  1521e4:	00000b06 	br	152214 <clear_saved_areas+0xa8>
            saved_axis_y[j][i] = 0;
  1521e8:	00c005b4 	movhi	r3,22
  1521ec:	18e13604 	addi	r3,r3,-31528
  1521f0:	e0bfff17 	ldw	r2,-4(fp)
  1521f4:	1008913a 	slli	r4,r2,4
  1521f8:	e0bffe17 	ldw	r2,-8(fp)
  1521fc:	2085883a 	add	r2,r4,r2
  152200:	1885883a 	add	r2,r3,r2
  152204:	10000005 	stb	zero,0(r2)
    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
        for (i = 0; i < (SIZE_Y / 8); i++)
  152208:	e0bffe17 	ldw	r2,-8(fp)
  15220c:	10800044 	addi	r2,r2,1
  152210:	e0bffe15 	stw	r2,-8(fp)
  152214:	e0bffe17 	ldw	r2,-8(fp)
  152218:	10800410 	cmplti	r2,r2,16
  15221c:	103ff21e 	bne	r2,zero,1521e8 <clear_saved_areas+0x7c>

    /* clear x-axis and y-axis save areas */
    for (j = 0; j <= (2 * Y_TICK_CNT); j++)
        for (i = 0; i < (SIZE_X / 8); i++)
            saved_axis_x[j][i] = 0;
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
  152220:	e0bfff17 	ldw	r2,-4(fp)
  152224:	10800044 	addi	r2,r2,1
  152228:	e0bfff15 	stw	r2,-4(fp)
  15222c:	e0bfff17 	ldw	r2,-4(fp)
  152230:	108002d0 	cmplti	r2,r2,11
  152234:	103fea1e 	bne	r2,zero,1521e0 <clear_saved_areas+0x74>
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
  152238:	e03ffe15 	stw	zero,-8(fp)
  15223c:	00001306 	br	15228c <clear_saved_areas+0x120>
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
  152240:	e03fff15 	stw	zero,-4(fp)
  152244:	00000b06 	br	152274 <clear_saved_areas+0x108>
	    saved_menu[i][j] = 0;
  152248:	00c005b4 	movhi	r3,22
  15224c:	18e16204 	addi	r3,r3,-31352
  152250:	e0bffe17 	ldw	r2,-8(fp)
  152254:	11000324 	muli	r4,r2,12
  152258:	e0bfff17 	ldw	r2,-4(fp)
  15225c:	2085883a 	add	r2,r4,r2
  152260:	1885883a 	add	r2,r3,r2
  152264:	10000005 	stb	zero,0(r2)
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
  152268:	e0bfff17 	ldw	r2,-4(fp)
  15226c:	10800044 	addi	r2,r2,1
  152270:	e0bfff15 	stw	r2,-4(fp)
  152274:	e0bfff17 	ldw	r2,-4(fp)
  152278:	10800310 	cmplti	r2,r2,12
  15227c:	103ff21e 	bne	r2,zero,152248 <clear_saved_areas+0xdc>
    for (j = 0; j <= (2 * X_TICK_CNT); j++)
        for (i = 0; i < (SIZE_Y / 8); i++)
            saved_axis_y[j][i] = 0;

    /* clear the menu save ares */
    for (i = 0; i < MENU_SIZE_Y; i++)
  152280:	e0bffe17 	ldw	r2,-8(fp)
  152284:	10800044 	addi	r2,r2,1
  152288:	e0bffe15 	stw	r2,-8(fp)
  15228c:	e0bffe17 	ldw	r2,-8(fp)
  152290:	10800e10 	cmplti	r2,r2,56
  152294:	103fea1e 	bne	r2,zero,152240 <clear_saved_areas+0xd4>
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
  152298:	e03ffe15 	stw	zero,-8(fp)
  15229c:	00001306 	br	1522ec <clear_saved_areas+0x180>
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
  1522a0:	e03fff15 	stw	zero,-4(fp)
  1522a4:	00000b06 	br	1522d4 <clear_saved_areas+0x168>
	    saved_area[i][j] = 0;
  1522a8:	00c005b4 	movhi	r3,22
  1522ac:	18e20a04 	addi	r3,r3,-30680
  1522b0:	e0bffe17 	ldw	r2,-8(fp)
  1522b4:	110003e4 	muli	r4,r2,15
  1522b8:	e0bfff17 	ldw	r2,-4(fp)
  1522bc:	2085883a 	add	r2,r4,r2
  1522c0:	1885883a 	add	r2,r3,r2
  1522c4:	10000005 	stb	zero,0(r2)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
  1522c8:	e0bfff17 	ldw	r2,-4(fp)
  1522cc:	10800044 	addi	r2,r2,1
  1522d0:	e0bfff15 	stw	r2,-4(fp)
  1522d4:	e0bfff17 	ldw	r2,-4(fp)
  1522d8:	108003d0 	cmplti	r2,r2,15
  1522dc:	103ff21e 	bne	r2,zero,1522a8 <clear_saved_areas+0x13c>
    for (i = 0; i < MENU_SIZE_Y; i++)
        for (j = 0; j < ((MENU_SIZE_X + 7) / 8); j++)
	    saved_menu[i][j] = 0;

    /* clear general save area */
    for (i = 0; i < SAVE_SIZE_Y; i++)
  1522e0:	e0bffe17 	ldw	r2,-8(fp)
  1522e4:	10800044 	addi	r2,r2,1
  1522e8:	e0bffe15 	stw	r2,-8(fp)
  1522ec:	e0bffe17 	ldw	r2,-8(fp)
  1522f0:	10800410 	cmplti	r2,r2,16
  1522f4:	103fea1e 	bne	r2,zero,1522a0 <clear_saved_areas+0x134>
        for (j = 0; j < (SAVE_SIZE_X / 8); j++)
	    saved_area[i][j] = 0;


    /* done clearing the saved areas - return */
    return;
  1522f8:	0001883a 	nop

}
  1522fc:	e037883a 	mov	sp,fp
  152300:	df000017 	ldw	fp,0(sp)
  152304:	dec00104 	addi	sp,sp,4
  152308:	f800283a 	ret

0015230c <restore_menu_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  restore_menu_trace()
{
  15230c:	defffa04 	addi	sp,sp,-24
  152310:	dfc00515 	stw	ra,20(sp)
  152314:	df000415 	stw	fp,16(sp)
  152318:	df000404 	addi	fp,sp,16
    int  y;



    /* loop, restoring the trace under the menu */
    for (y = MENU_UL_Y; y < (MENU_UL_Y + MENU_SIZE_Y); y++)  {
  15231c:	e03fff15 	stw	zero,-4(fp)
  152320:	00003206 	br	1523ec <restore_menu_trace+0xe0>

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
  152324:	00802004 	movi	r2,128
  152328:	e0bffc15 	stw	r2,-16(fp)
	bit_offset = 0;		/* first byte of the row */
  15232c:	e03ffd15 	stw	zero,-12(fp)

        for (x = MENU_UL_X; x < (MENU_UL_X + MENU_SIZE_X); x++)  {
  152330:	00805e84 	movi	r2,378
  152334:	e0bffe15 	stw	r2,-8(fp)
  152338:	00002606 	br	1523d4 <restore_menu_trace+0xc8>

	    /* check if this point is on or off (need to look at bits) */
	    if ((saved_menu[y - MENU_UL_Y][bit_offset] & bit_position) == 0)
  15233c:	00c005b4 	movhi	r3,22
  152340:	18e16204 	addi	r3,r3,-31352
  152344:	e0bfff17 	ldw	r2,-4(fp)
  152348:	11000324 	muli	r4,r2,12
  15234c:	e0bffd17 	ldw	r2,-12(fp)
  152350:	2085883a 	add	r2,r4,r2
  152354:	1885883a 	add	r2,r3,r2
  152358:	10800003 	ldbu	r2,0(r2)
  15235c:	10c03fcc 	andi	r3,r2,255
  152360:	e0bffc17 	ldw	r2,-16(fp)
  152364:	1884703a 	and	r2,r3,r2
  152368:	1000071e 	bne	r2,zero,152388 <restore_menu_trace+0x7c>
	        /* saved pixel is off */
		plot_pixel(x, y, PIXEL_WHITE);
  15236c:	e0fffe17 	ldw	r3,-8(fp)
  152370:	e0bfff17 	ldw	r2,-4(fp)
  152374:	1809883a 	mov	r4,r3
  152378:	100b883a 	mov	r5,r2
  15237c:	000d883a 	mov	r6,zero
  152380:	0151a0c0 	call	151a0c <plot_pixel>
  152384:	00000606 	br	1523a0 <restore_menu_trace+0x94>
	    else
	        /* saved pixel is on */
		plot_pixel(x, y, PIXEL_BLACK);
  152388:	e0fffe17 	ldw	r3,-8(fp)
  15238c:	e0bfff17 	ldw	r2,-4(fp)
  152390:	1809883a 	mov	r4,r3
  152394:	100b883a 	mov	r5,r2
  152398:	01800044 	movi	r6,1
  15239c:	0151a0c0 	call	151a0c <plot_pixel>

	    /* move to the next bit position */
	    bit_position >>= 1;
  1523a0:	e0bffc17 	ldw	r2,-16(fp)
  1523a4:	1005d07a 	srai	r2,r2,1
  1523a8:	e0bffc15 	stw	r2,-16(fp)
	    /* check if moving to next byte */
	    if (bit_position == 0)  {
  1523ac:	e0bffc17 	ldw	r2,-16(fp)
  1523b0:	1000051e 	bne	r2,zero,1523c8 <restore_menu_trace+0xbc>
	        /* now on high bit of next byte */
		bit_position = 0x80;
  1523b4:	00802004 	movi	r2,128
  1523b8:	e0bffc15 	stw	r2,-16(fp)
		bit_offset++;
  1523bc:	e0bffd17 	ldw	r2,-12(fp)
  1523c0:	10800044 	addi	r2,r2,1
  1523c4:	e0bffd15 	stw	r2,-12(fp)

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
	bit_offset = 0;		/* first byte of the row */

        for (x = MENU_UL_X; x < (MENU_UL_X + MENU_SIZE_X); x++)  {
  1523c8:	e0bffe17 	ldw	r2,-8(fp)
  1523cc:	10800044 	addi	r2,r2,1
  1523d0:	e0bffe15 	stw	r2,-8(fp)
  1523d4:	e0bffe17 	ldw	r2,-8(fp)
  1523d8:	10807690 	cmplti	r2,r2,474
  1523dc:	103fd71e 	bne	r2,zero,15233c <restore_menu_trace+0x30>
    int  y;



    /* loop, restoring the trace under the menu */
    for (y = MENU_UL_Y; y < (MENU_UL_Y + MENU_SIZE_Y); y++)  {
  1523e0:	e0bfff17 	ldw	r2,-4(fp)
  1523e4:	10800044 	addi	r2,r2,1
  1523e8:	e0bfff15 	stw	r2,-4(fp)
  1523ec:	e0bfff17 	ldw	r2,-4(fp)
  1523f0:	10800e10 	cmplti	r2,r2,56
  1523f4:	103fcb1e 	bne	r2,zero,152324 <restore_menu_trace+0x18>
        }
    }


    /* restored menu area - return */
    return;
  1523f8:	0001883a 	nop

}
  1523fc:	e037883a 	mov	sp,fp
  152400:	dfc00117 	ldw	ra,4(sp)
  152404:	df000017 	ldw	fp,0(sp)
  152408:	dec00204 	addi	sp,sp,8
  15240c:	f800283a 	ret

00152410 <set_save_area>:
   Last Modified:    Mar. 8, 1994

*/

void  set_save_area(int pos_x, int pos_y, int size_x, int size_y)
{
  152410:	defff904 	addi	sp,sp,-28
  152414:	df000615 	stw	fp,24(sp)
  152418:	df000604 	addi	fp,sp,24
  15241c:	e13ffc15 	stw	r4,-16(fp)
  152420:	e17ffd15 	stw	r5,-12(fp)
  152424:	e1bffe15 	stw	r6,-8(fp)
  152428:	e1ffff15 	stw	r7,-4(fp)
    int  y;



    /* just setup all the locally global variables from the passed values */
    saved_pos_x = pos_x;
  15242c:	e0bffc17 	ldw	r2,-16(fp)
  152430:	d0a5a915 	stw	r2,-26972(gp)
    saved_pos_y = pos_y;
  152434:	e0bffd17 	ldw	r2,-12(fp)
  152438:	d0a5aa15 	stw	r2,-26968(gp)
    saved_end_x = pos_x + size_x;
  15243c:	e0fffc17 	ldw	r3,-16(fp)
  152440:	e0bffe17 	ldw	r2,-8(fp)
  152444:	1885883a 	add	r2,r3,r2
  152448:	d0a5ab15 	stw	r2,-26964(gp)
    saved_end_y = pos_y + size_y;
  15244c:	e0fffd17 	ldw	r3,-12(fp)
  152450:	e0bfff17 	ldw	r2,-4(fp)
  152454:	1885883a 	add	r2,r3,r2
  152458:	d0a5ac15 	stw	r2,-26960(gp)


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
  15245c:	e03ffb15 	stw	zero,-20(fp)
  152460:	00001306 	br	1524b0 <set_save_area+0xa0>
        for (x = 0; x < (SAVE_SIZE_X / 8); x++)  {
  152464:	e03ffa15 	stw	zero,-24(fp)
  152468:	00000b06 	br	152498 <set_save_area+0x88>
	    saved_area[y][x] = 0;
  15246c:	00c005b4 	movhi	r3,22
  152470:	18e20a04 	addi	r3,r3,-30680
  152474:	e0bffb17 	ldw	r2,-20(fp)
  152478:	110003e4 	muli	r4,r2,15
  15247c:	e0bffa17 	ldw	r2,-24(fp)
  152480:	2085883a 	add	r2,r4,r2
  152484:	1885883a 	add	r2,r3,r2
  152488:	10000005 	stb	zero,0(r2)
    saved_end_y = pos_y + size_y;


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
        for (x = 0; x < (SAVE_SIZE_X / 8); x++)  {
  15248c:	e0bffa17 	ldw	r2,-24(fp)
  152490:	10800044 	addi	r2,r2,1
  152494:	e0bffa15 	stw	r2,-24(fp)
  152498:	e0bffa17 	ldw	r2,-24(fp)
  15249c:	108003d0 	cmplti	r2,r2,15
  1524a0:	103ff21e 	bne	r2,zero,15246c <set_save_area+0x5c>
    saved_end_x = pos_x + size_x;
    saved_end_y = pos_y + size_y;


    /* clear the save area */
    for (y = 0; y < SAVE_SIZE_Y; y++)  {
  1524a4:	e0bffb17 	ldw	r2,-20(fp)
  1524a8:	10800044 	addi	r2,r2,1
  1524ac:	e0bffb15 	stw	r2,-20(fp)
  1524b0:	e0bffb17 	ldw	r2,-20(fp)
  1524b4:	10800410 	cmplti	r2,r2,16
  1524b8:	103fea1e 	bne	r2,zero,152464 <set_save_area+0x54>
        }
    }


    /* setup the saved area - return */
    return;
  1524bc:	0001883a 	nop

}
  1524c0:	e037883a 	mov	sp,fp
  1524c4:	df000017 	ldw	fp,0(sp)
  1524c8:	dec00104 	addi	sp,sp,4
  1524cc:	f800283a 	ret

001524d0 <restore_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  restore_trace()
{
  1524d0:	defffa04 	addi	sp,sp,-24
  1524d4:	dfc00515 	stw	ra,20(sp)
  1524d8:	df000415 	stw	fp,16(sp)
  1524dc:	df000404 	addi	fp,sp,16
    int  y;



    /* loop, restoring the saved trace */
    for (y = saved_pos_y; y < saved_end_y; y++)  {
  1524e0:	d0a5aa17 	ldw	r2,-26968(gp)
  1524e4:	e0bfff15 	stw	r2,-4(fp)
  1524e8:	00003406 	br	1525bc <restore_trace+0xec>

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
  1524ec:	00802004 	movi	r2,128
  1524f0:	e0bffc15 	stw	r2,-16(fp)
	bit_offset = 0;		/* first byte of the row */
  1524f4:	e03ffd15 	stw	zero,-12(fp)

        for (x = saved_pos_x; x < saved_end_x; x++)  {
  1524f8:	d0a5a917 	ldw	r2,-26972(gp)
  1524fc:	e0bffe15 	stw	r2,-8(fp)
  152500:	00002806 	br	1525a4 <restore_trace+0xd4>

	    /* check if this point is on or off (need to look at bits) */
	    if ((saved_area[y - saved_pos_y][bit_offset] & bit_position) == 0)
  152504:	d0a5aa17 	ldw	r2,-26968(gp)
  152508:	e0ffff17 	ldw	r3,-4(fp)
  15250c:	1885c83a 	sub	r2,r3,r2
  152510:	00c005b4 	movhi	r3,22
  152514:	18e20a04 	addi	r3,r3,-30680
  152518:	110003e4 	muli	r4,r2,15
  15251c:	e0bffd17 	ldw	r2,-12(fp)
  152520:	2085883a 	add	r2,r4,r2
  152524:	1885883a 	add	r2,r3,r2
  152528:	10800003 	ldbu	r2,0(r2)
  15252c:	10c03fcc 	andi	r3,r2,255
  152530:	e0bffc17 	ldw	r2,-16(fp)
  152534:	1884703a 	and	r2,r3,r2
  152538:	1000071e 	bne	r2,zero,152558 <restore_trace+0x88>
	        /* saved pixel is off */
		plot_pixel(x, y, PIXEL_WHITE);
  15253c:	e0fffe17 	ldw	r3,-8(fp)
  152540:	e0bfff17 	ldw	r2,-4(fp)
  152544:	1809883a 	mov	r4,r3
  152548:	100b883a 	mov	r5,r2
  15254c:	000d883a 	mov	r6,zero
  152550:	0151a0c0 	call	151a0c <plot_pixel>
  152554:	00000606 	br	152570 <restore_trace+0xa0>
	    else
	        /* saved pixel is on */
		plot_pixel(x, y, PIXEL_BLACK);
  152558:	e0fffe17 	ldw	r3,-8(fp)
  15255c:	e0bfff17 	ldw	r2,-4(fp)
  152560:	1809883a 	mov	r4,r3
  152564:	100b883a 	mov	r5,r2
  152568:	01800044 	movi	r6,1
  15256c:	0151a0c0 	call	151a0c <plot_pixel>

	    /* move to the next bit position */
	    bit_position >>= 1;
  152570:	e0bffc17 	ldw	r2,-16(fp)
  152574:	1005d07a 	srai	r2,r2,1
  152578:	e0bffc15 	stw	r2,-16(fp)
	    /* check if moving to next byte */
	    if (bit_position == 0)  {
  15257c:	e0bffc17 	ldw	r2,-16(fp)
  152580:	1000051e 	bne	r2,zero,152598 <restore_trace+0xc8>
	        /* now on high bit of next byte */
		bit_position = 0x80;
  152584:	00802004 	movi	r2,128
  152588:	e0bffc15 	stw	r2,-16(fp)
		bit_offset++;
  15258c:	e0bffd17 	ldw	r2,-12(fp)
  152590:	10800044 	addi	r2,r2,1
  152594:	e0bffd15 	stw	r2,-12(fp)

        /* starting a row - initialize bit position */
	bit_position = 0x80;	/* start at high-order bit in the byte */
	bit_offset = 0;		/* first byte of the row */

        for (x = saved_pos_x; x < saved_end_x; x++)  {
  152598:	e0bffe17 	ldw	r2,-8(fp)
  15259c:	10800044 	addi	r2,r2,1
  1525a0:	e0bffe15 	stw	r2,-8(fp)
  1525a4:	d0a5ab17 	ldw	r2,-26964(gp)
  1525a8:	e0fffe17 	ldw	r3,-8(fp)
  1525ac:	18bfd516 	blt	r3,r2,152504 <restore_trace+0x34>
    int  y;



    /* loop, restoring the saved trace */
    for (y = saved_pos_y; y < saved_end_y; y++)  {
  1525b0:	e0bfff17 	ldw	r2,-4(fp)
  1525b4:	10800044 	addi	r2,r2,1
  1525b8:	e0bfff15 	stw	r2,-4(fp)
  1525bc:	d0a5ac17 	ldw	r2,-26960(gp)
  1525c0:	e0ffff17 	ldw	r3,-4(fp)
  1525c4:	18bfc916 	blt	r3,r2,1524ec <restore_trace+0x1c>
        }
    }


    /* restored the saved area - return */
    return;
  1525c8:	0001883a 	nop

}
  1525cc:	e037883a 	mov	sp,fp
  1525d0:	dfc00117 	ldw	ra,4(sp)
  1525d4:	df000017 	ldw	fp,0(sp)
  1525d8:	dec00204 	addi	sp,sp,8
  1525dc:	f800283a 	ret

001525e0 <do_trace>:
   Last Modified:    Mar. 13, 1994

*/

void  do_trace()
{
  1525e0:	defffe04 	addi	sp,sp,-8
  1525e4:	dfc00115 	stw	ra,4(sp)
  1525e8:	df000015 	stw	fp,0(sp)
  1525ec:	d839883a 	mov	fp,sp



    /* start up the trace */
    /* indicate whether using automatic triggering or not */
    start_sample(get_trigger_mode() == AUTO_TRIGGER);
  1525f0:	0150d900 	call	150d90 <get_trigger_mode>
  1525f4:	10800060 	cmpeqi	r2,r2,1
  1525f8:	10803fcc 	andi	r2,r2,255
  1525fc:	1009883a 	mov	r4,r2
  152600:	0151aa80 	call	151aa8 <start_sample>

    /* now not ready for another trace (currently doing one) */
    trace_status = FALSE;
  152604:	d025a515 	stw	zero,-26988(gp)

    /* and are currently sampling data */
    sampling = TRUE;
  152608:	00800044 	movi	r2,1
  15260c:	d0a5a615 	stw	r2,-26984(gp)


    /* trace is going, return */
    return;
  152610:	0001883a 	nop

}
  152614:	e037883a 	mov	sp,fp
  152618:	dfc00117 	ldw	ra,4(sp)
  15261c:	df000017 	ldw	fp,0(sp)
  152620:	dec00204 	addi	sp,sp,8
  152624:	f800283a 	ret

00152628 <plot_trace>:
   Last Modified:    May 9, 2006

*/

void  plot_trace(unsigned char *sample)
{
  152628:	defff704 	addi	sp,sp,-36
  15262c:	dfc00815 	stw	ra,32(sp)
  152630:	df000715 	stw	fp,28(sp)
  152634:	df000704 	addi	fp,sp,28
  152638:	e13fff15 	stw	r4,-4(fp)
    /* variables */
    int  x = 0;				/* current x position to plot */
  15263c:	e03ff915 	stw	zero,-28(fp)
    int  x_pos = (PLOT_SIZE_X / 2);	/* "fine" x position for multiple point plotting */
  152640:	00803c04 	movi	r2,240
  152644:	e0bffa15 	stw	r2,-24(fp)
    int  j;



    /* first, clear the display to get rid of old plots */
    clear_display();
  152648:	01519ec0 	call	1519ec <clear_display>

    /* clear the saved areas too */
    clear_saved_areas();
  15264c:	015216c0 	call	15216c <clear_saved_areas>

    /* re-display the menu (if it was on) */
    refresh_menu();
  152650:	01509840 	call	150984 <refresh_menu>


    /* plot the sample */
    for (i = 0; i < sample_size; i++)  {
  152654:	e03ffc15 	stw	zero,-16(fp)
  152658:	0000fb06 	br	152a48 <plot_trace+0x420>

        /* determine y position of point (note: screen coordinates invert) */
	y = (PLOT_SIZE_Y - 1) - ((sample[i] * (PLOT_SIZE_Y - 1)) / 255);
  15265c:	e0bffc17 	ldw	r2,-16(fp)
  152660:	e0ffff17 	ldw	r3,-4(fp)
  152664:	1885883a 	add	r2,r3,r2
  152668:	10800003 	ldbu	r2,0(r2)
  15266c:	10803fcc 	andi	r2,r2,255
  152670:	10801fe4 	muli	r2,r2,127
  152674:	1009883a 	mov	r4,r2
  152678:	01403fc4 	movi	r5,255
  15267c:	0152bfc0 	call	152bfc <__divsi3>
  152680:	00c01fc4 	movi	r3,127
  152684:	1885c83a 	sub	r2,r3,r2
  152688:	e0bffe15 	stw	r2,-8(fp)

        /* plot this point */
	plot_pixel(x, y, PIXEL_BLACK);
  15268c:	e0fff917 	ldw	r3,-28(fp)
  152690:	e0bffe17 	ldw	r2,-8(fp)
  152694:	1809883a 	mov	r4,r3
  152698:	100b883a 	mov	r5,r2
  15269c:	01800044 	movi	r6,1
  1526a0:	0151a0c0 	call	151a0c <plot_pixel>


	/* check if the point is in a save area */

	/* check if in the menu area */
	if ((x >= MENU_UL_X) && (x < (MENU_UL_X + MENU_SIZE_X)) &&
  1526a4:	e0bff917 	ldw	r2,-28(fp)
  1526a8:	10805e90 	cmplti	r2,r2,378
  1526ac:	10002b1e 	bne	r2,zero,15275c <plot_trace+0x134>
  1526b0:	e0bff917 	ldw	r2,-28(fp)
  1526b4:	10807688 	cmpgei	r2,r2,474
  1526b8:	1000281e 	bne	r2,zero,15275c <plot_trace+0x134>
  1526bc:	e0bffe17 	ldw	r2,-8(fp)
  1526c0:	10002616 	blt	r2,zero,15275c <plot_trace+0x134>
	    (y >= MENU_UL_Y) && (y < (MENU_UL_Y + MENU_SIZE_Y)))
  1526c4:	e0bffe17 	ldw	r2,-8(fp)
  1526c8:	10800e08 	cmpgei	r2,r2,56
  1526cc:	1000231e 	bne	r2,zero,15275c <plot_trace+0x134>
	    /* point is in the menu area - save it */
	    saved_menu[y - MENU_UL_Y][(x - MENU_UL_X)/8] |= (0x80 >> ((x - MENU_UL_X) % 8));
  1526d0:	e0bff917 	ldw	r2,-28(fp)
  1526d4:	10bfa184 	addi	r2,r2,-378
  1526d8:	1000010e 	bge	r2,zero,1526e0 <plot_trace+0xb8>
  1526dc:	108001c4 	addi	r2,r2,7
  1526e0:	1005d0fa 	srai	r2,r2,3
  1526e4:	1007883a 	mov	r3,r2
  1526e8:	010005b4 	movhi	r4,22
  1526ec:	21216204 	addi	r4,r4,-31352
  1526f0:	e0bffe17 	ldw	r2,-8(fp)
  1526f4:	10800324 	muli	r2,r2,12
  1526f8:	10c5883a 	add	r2,r2,r3
  1526fc:	2085883a 	add	r2,r4,r2
  152700:	10800003 	ldbu	r2,0(r2)
  152704:	1009883a 	mov	r4,r2
  152708:	e0bff917 	ldw	r2,-28(fp)
  15270c:	117fa184 	addi	r5,r2,-378
  152710:	00a00034 	movhi	r2,32768
  152714:	108001c4 	addi	r2,r2,7
  152718:	2884703a 	and	r2,r5,r2
  15271c:	1000040e 	bge	r2,zero,152730 <plot_trace+0x108>
  152720:	10bfffc4 	addi	r2,r2,-1
  152724:	017ffe04 	movi	r5,-8
  152728:	1144b03a 	or	r2,r2,r5
  15272c:	10800044 	addi	r2,r2,1
  152730:	01402004 	movi	r5,128
  152734:	2885d83a 	sra	r2,r5,r2
  152738:	2084b03a 	or	r2,r4,r2
  15273c:	1009883a 	mov	r4,r2
  152740:	014005b4 	movhi	r5,22
  152744:	29616204 	addi	r5,r5,-31352
  152748:	e0bffe17 	ldw	r2,-8(fp)
  15274c:	10800324 	muli	r2,r2,12
  152750:	10c5883a 	add	r2,r2,r3
  152754:	2885883a 	add	r2,r5,r2
  152758:	11000005 	stb	r4,0(r2)

	/* check if in the saved area */
	if ((x >= saved_pos_x) && (x <= saved_end_x) && (y >= saved_pos_y) && (y <= saved_end_y))
  15275c:	d0a5a917 	ldw	r2,-26972(gp)
  152760:	e0fff917 	ldw	r3,-28(fp)
  152764:	18803216 	blt	r3,r2,152830 <plot_trace+0x208>
  152768:	d0e5ab17 	ldw	r3,-26964(gp)
  15276c:	e0bff917 	ldw	r2,-28(fp)
  152770:	18802f16 	blt	r3,r2,152830 <plot_trace+0x208>
  152774:	d0a5aa17 	ldw	r2,-26968(gp)
  152778:	e0fffe17 	ldw	r3,-8(fp)
  15277c:	18802c16 	blt	r3,r2,152830 <plot_trace+0x208>
  152780:	d0e5ac17 	ldw	r3,-26960(gp)
  152784:	e0bffe17 	ldw	r2,-8(fp)
  152788:	18802916 	blt	r3,r2,152830 <plot_trace+0x208>
	    /* point is in the save area - save it */
	    saved_area[y - saved_pos_y][(x - saved_pos_x)/8] |= (0x80 >> ((x - saved_pos_x) % 8));
  15278c:	d0a5aa17 	ldw	r2,-26968(gp)
  152790:	e0fffe17 	ldw	r3,-8(fp)
  152794:	188dc83a 	sub	r6,r3,r2
  152798:	d0a5a917 	ldw	r2,-26972(gp)
  15279c:	e0fff917 	ldw	r3,-28(fp)
  1527a0:	1885c83a 	sub	r2,r3,r2
  1527a4:	1000010e 	bge	r2,zero,1527ac <plot_trace+0x184>
  1527a8:	108001c4 	addi	r2,r2,7
  1527ac:	1005d0fa 	srai	r2,r2,3
  1527b0:	1007883a 	mov	r3,r2
  1527b4:	d0a5aa17 	ldw	r2,-26968(gp)
  1527b8:	e13ffe17 	ldw	r4,-8(fp)
  1527bc:	2085c83a 	sub	r2,r4,r2
  1527c0:	010005b4 	movhi	r4,22
  1527c4:	21220a04 	addi	r4,r4,-30680
  1527c8:	108003e4 	muli	r2,r2,15
  1527cc:	10c5883a 	add	r2,r2,r3
  1527d0:	2085883a 	add	r2,r4,r2
  1527d4:	10800003 	ldbu	r2,0(r2)
  1527d8:	1009883a 	mov	r4,r2
  1527dc:	d0a5a917 	ldw	r2,-26972(gp)
  1527e0:	e17ff917 	ldw	r5,-28(fp)
  1527e4:	288bc83a 	sub	r5,r5,r2
  1527e8:	00a00034 	movhi	r2,32768
  1527ec:	108001c4 	addi	r2,r2,7
  1527f0:	2884703a 	and	r2,r5,r2
  1527f4:	1000040e 	bge	r2,zero,152808 <plot_trace+0x1e0>
  1527f8:	10bfffc4 	addi	r2,r2,-1
  1527fc:	017ffe04 	movi	r5,-8
  152800:	1144b03a 	or	r2,r2,r5
  152804:	10800044 	addi	r2,r2,1
  152808:	01402004 	movi	r5,128
  15280c:	2885d83a 	sra	r2,r5,r2
  152810:	2084b03a 	or	r2,r4,r2
  152814:	1009883a 	mov	r4,r2
  152818:	014005b4 	movhi	r5,22
  15281c:	29620a04 	addi	r5,r5,-30680
  152820:	308003e4 	muli	r2,r6,15
  152824:	10c5883a 	add	r2,r2,r3
  152828:	2885883a 	add	r2,r5,r2
  15282c:	11000005 	stb	r4,0(r2)

	/* check if on a grid line */
	/* go through all the horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  152830:	00bfffc4 	movi	r2,-1
  152834:	e0bffd15 	stw	r2,-12(fp)
  152838:	00003506 	br	152910 <plot_trace+0x2e8>

	    /* get y position of the line */
	    p = X_AXIS_POS + j * Y_TICK_SIZE;
  15283c:	e0bffd17 	ldw	r2,-12(fp)
  152840:	10800c24 	muli	r2,r2,48
  152844:	10801004 	addi	r2,r2,64
  152848:	e0bffb15 	stw	r2,-20(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_Y)
  15284c:	e0bffb17 	ldw	r2,-20(fp)
  152850:	10802010 	cmplti	r2,r2,128
  152854:	1000021e 	bne	r2,zero,152860 <plot_trace+0x238>
	        p = PLOT_SIZE_Y - 1;
  152858:	00801fc4 	movi	r2,127
  15285c:	e0bffb15 	stw	r2,-20(fp)
	    if (p < 0)
  152860:	e0bffb17 	ldw	r2,-20(fp)
  152864:	1000010e 	bge	r2,zero,15286c <plot_trace+0x244>
	        p = 0;
  152868:	e03ffb15 	stw	zero,-20(fp)

	    /* if the point is on this line, save it */
	    if (y == p)
  15286c:	e0fffe17 	ldw	r3,-8(fp)
  152870:	e0bffb17 	ldw	r2,-20(fp)
  152874:	1880231e 	bne	r3,r2,152904 <plot_trace+0x2dc>
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
  152878:	e0bffd17 	ldw	r2,-12(fp)
  15287c:	11800044 	addi	r6,r2,1
  152880:	e0bff917 	ldw	r2,-28(fp)
  152884:	1000010e 	bge	r2,zero,15288c <plot_trace+0x264>
  152888:	108001c4 	addi	r2,r2,7
  15288c:	1005d0fa 	srai	r2,r2,3
  152890:	1007883a 	mov	r3,r2
  152894:	e0bffd17 	ldw	r2,-12(fp)
  152898:	10800044 	addi	r2,r2,1
  15289c:	010005b4 	movhi	r4,22
  1528a0:	21210904 	addi	r4,r4,-31708
  1528a4:	10800f24 	muli	r2,r2,60
  1528a8:	10c5883a 	add	r2,r2,r3
  1528ac:	2085883a 	add	r2,r4,r2
  1528b0:	10800003 	ldbu	r2,0(r2)
  1528b4:	1009883a 	mov	r4,r2
  1528b8:	e17ff917 	ldw	r5,-28(fp)
  1528bc:	00a00034 	movhi	r2,32768
  1528c0:	108001c4 	addi	r2,r2,7
  1528c4:	2884703a 	and	r2,r5,r2
  1528c8:	1000040e 	bge	r2,zero,1528dc <plot_trace+0x2b4>
  1528cc:	10bfffc4 	addi	r2,r2,-1
  1528d0:	017ffe04 	movi	r5,-8
  1528d4:	1144b03a 	or	r2,r2,r5
  1528d8:	10800044 	addi	r2,r2,1
  1528dc:	01402004 	movi	r5,128
  1528e0:	2885d83a 	sra	r2,r5,r2
  1528e4:	2084b03a 	or	r2,r4,r2
  1528e8:	1009883a 	mov	r4,r2
  1528ec:	014005b4 	movhi	r5,22
  1528f0:	29610904 	addi	r5,r5,-31708
  1528f4:	30800f24 	muli	r2,r6,60
  1528f8:	10c5883a 	add	r2,r2,r3
  1528fc:	2885883a 	add	r2,r5,r2
  152900:	11000005 	stb	r4,0(r2)
	    /* point is in the save area - save it */
	    saved_area[y - saved_pos_y][(x - saved_pos_x)/8] |= (0x80 >> ((x - saved_pos_x) % 8));

	/* check if on a grid line */
	/* go through all the horizontal lines */
	for (j = -Y_TICK_CNT; j <= Y_TICK_CNT; j++)  {
  152904:	e0bffd17 	ldw	r2,-12(fp)
  152908:	10800044 	addi	r2,r2,1
  15290c:	e0bffd15 	stw	r2,-12(fp)
  152910:	e0bffd17 	ldw	r2,-12(fp)
  152914:	10800090 	cmplti	r2,r2,2
  152918:	103fc81e 	bne	r2,zero,15283c <plot_trace+0x214>
	    if (y == p)
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
	}

	/* go through all the vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  15291c:	00bffec4 	movi	r2,-5
  152920:	e0bffd15 	stw	r2,-12(fp)
  152924:	00003506 	br	1529fc <plot_trace+0x3d4>

	    /* get x position of the line */
	    p = Y_AXIS_POS + j * X_TICK_SIZE;
  152928:	e0bffd17 	ldw	r2,-12(fp)
  15292c:	10800c24 	muli	r2,r2,48
  152930:	10803c04 	addi	r2,r2,240
  152934:	e0bffb15 	stw	r2,-20(fp)
	    /* make sure it is in range */
	    if (p >= PLOT_SIZE_X)
  152938:	e0bffb17 	ldw	r2,-20(fp)
  15293c:	10807810 	cmplti	r2,r2,480
  152940:	1000021e 	bne	r2,zero,15294c <plot_trace+0x324>
	        p = PLOT_SIZE_X - 1;
  152944:	008077c4 	movi	r2,479
  152948:	e0bffb15 	stw	r2,-20(fp)
	    if (p < 0)
  15294c:	e0bffb17 	ldw	r2,-20(fp)
  152950:	1000010e 	bge	r2,zero,152958 <plot_trace+0x330>
	        p = 0;
  152954:	e03ffb15 	stw	zero,-20(fp)

	    /* if the point is on this line, save it */
	    if (x == p)
  152958:	e0fff917 	ldw	r3,-28(fp)
  15295c:	e0bffb17 	ldw	r2,-20(fp)
  152960:	1880231e 	bne	r3,r2,1529f0 <plot_trace+0x3c8>
		saved_axis_y[j + X_TICK_CNT][y / 8] |= (0x80 >> (y % 8));
  152964:	e0bffd17 	ldw	r2,-12(fp)
  152968:	11800144 	addi	r6,r2,5
  15296c:	e0bffe17 	ldw	r2,-8(fp)
  152970:	1000010e 	bge	r2,zero,152978 <plot_trace+0x350>
  152974:	108001c4 	addi	r2,r2,7
  152978:	1005d0fa 	srai	r2,r2,3
  15297c:	1007883a 	mov	r3,r2
  152980:	e0bffd17 	ldw	r2,-12(fp)
  152984:	10800144 	addi	r2,r2,5
  152988:	010005b4 	movhi	r4,22
  15298c:	21213604 	addi	r4,r4,-31528
  152990:	1004913a 	slli	r2,r2,4
  152994:	10c5883a 	add	r2,r2,r3
  152998:	2085883a 	add	r2,r4,r2
  15299c:	10800003 	ldbu	r2,0(r2)
  1529a0:	1009883a 	mov	r4,r2
  1529a4:	e17ffe17 	ldw	r5,-8(fp)
  1529a8:	00a00034 	movhi	r2,32768
  1529ac:	108001c4 	addi	r2,r2,7
  1529b0:	2884703a 	and	r2,r5,r2
  1529b4:	1000040e 	bge	r2,zero,1529c8 <plot_trace+0x3a0>
  1529b8:	10bfffc4 	addi	r2,r2,-1
  1529bc:	017ffe04 	movi	r5,-8
  1529c0:	1144b03a 	or	r2,r2,r5
  1529c4:	10800044 	addi	r2,r2,1
  1529c8:	01402004 	movi	r5,128
  1529cc:	2885d83a 	sra	r2,r5,r2
  1529d0:	2084b03a 	or	r2,r4,r2
  1529d4:	1009883a 	mov	r4,r2
  1529d8:	014005b4 	movhi	r5,22
  1529dc:	29613604 	addi	r5,r5,-31528
  1529e0:	3004913a 	slli	r2,r6,4
  1529e4:	10c5883a 	add	r2,r2,r3
  1529e8:	2885883a 	add	r2,r5,r2
  1529ec:	11000005 	stb	r4,0(r2)
	    if (y == p)
		saved_axis_x[j + Y_TICK_CNT][x / 8] |= (0x80 >> (x % 8));
	}

	/* go through all the vertical lines */
	for (j = -X_TICK_CNT; j <= X_TICK_CNT; j++)  {
  1529f0:	e0bffd17 	ldw	r2,-12(fp)
  1529f4:	10800044 	addi	r2,r2,1
  1529f8:	e0bffd15 	stw	r2,-12(fp)
  1529fc:	e0bffd17 	ldw	r2,-12(fp)
  152a00:	10800190 	cmplti	r2,r2,6
  152a04:	103fc81e 	bne	r2,zero,152928 <plot_trace+0x300>
		saved_axis_y[j + X_TICK_CNT][y / 8] |= (0x80 >> (y % 8));
	}


	/* update x position */
	x_pos += PLOT_SIZE_X;
  152a08:	e0bffa17 	ldw	r2,-24(fp)
  152a0c:	10807804 	addi	r2,r2,480
  152a10:	e0bffa15 	stw	r2,-24(fp)
	/* check if at next horizontal position */
	if (x_pos >= sample_size)  {
  152a14:	d0a5a717 	ldw	r2,-26980(gp)
  152a18:	e0fffa17 	ldw	r3,-24(fp)
  152a1c:	18800716 	blt	r3,r2,152a3c <plot_trace+0x414>
	    /* at next position - update positions */
	    x++;
  152a20:	e0bff917 	ldw	r2,-28(fp)
  152a24:	10800044 	addi	r2,r2,1
  152a28:	e0bff915 	stw	r2,-28(fp)
	    x_pos -= sample_size;
  152a2c:	d0a5a717 	ldw	r2,-26980(gp)
  152a30:	e0fffa17 	ldw	r3,-24(fp)
  152a34:	1885c83a 	sub	r2,r3,r2
  152a38:	e0bffa15 	stw	r2,-24(fp)
    /* re-display the menu (if it was on) */
    refresh_menu();


    /* plot the sample */
    for (i = 0; i < sample_size; i++)  {
  152a3c:	e0bffc17 	ldw	r2,-16(fp)
  152a40:	10800044 	addi	r2,r2,1
  152a44:	e0bffc15 	stw	r2,-16(fp)
  152a48:	d0a5a717 	ldw	r2,-26980(gp)
  152a4c:	e0fffc17 	ldw	r3,-16(fp)
  152a50:	18bf0216 	blt	r3,r2,15265c <plot_trace+0x34>
	}
    }


    /* finally, output the scale if need be */
    set_display_scale(cur_scale);
  152a54:	d0a5a817 	ldw	r2,-26976(gp)
  152a58:	1009883a 	mov	r4,r2
  152a5c:	0151da00 	call	151da0 <set_display_scale>


    /* done with plot, return */
    return;
  152a60:	0001883a 	nop

}
  152a64:	e037883a 	mov	sp,fp
  152a68:	dfc00117 	ldw	ra,4(sp)
  152a6c:	df000017 	ldw	fp,0(sp)
  152a70:	dec00204 	addi	sp,sp,8
  152a74:	f800283a 	ret

00152a78 <keys_init>:
    .section .text

/* keys_init */
    .global keys_init
keys_init:
    ADDI    sp, sp, NEG_WORD_SIZE  /* push return address */
  152a78:	deffff04 	addi	sp,sp,-4
    STW     ra, 0(sp)
  152a7c:	dfc00015 	stw	ra,0(sp)
  152a80:	02400574 	movhi	r9,21

    MOVIA   r9, curr_key           /* no key (r0) available at start */
  152a84:	4a55d204 	addi	r9,r9,22344
    STB     r0, 0(r9)              /* so store it into variable curr_key */
  152a88:	48000005 	stb	zero,0(r9)

    MOV     r4, r0                 /* argument ic_id is ignored */
  152a8c:	0009883a 	mov	r4,zero
    MOVI    r5, PIO_0_IRQ          /* second arg is IRQ num */
  152a90:	01400044 	movi	r5,1
  152a94:	01800574 	movhi	r6,21
    MOVIA   r6, keys_handler       /* third arg is int handler */
  152a98:	318ab304 	addi	r6,r6,10956
    MOV     r7, r0                 /* fourth arg is data struct (null) */
  152a9c:	000f883a 	mov	r7,zero
    ADDI    sp, sp, NEG_WORD_SIZE  /* fifth arg goes on stack */
  152aa0:	deffff04 	addi	sp,sp,-4
    STW     r0, 0(sp)              /*  and is ignored (so 0) */
  152aa4:	d8000015 	stw	zero,0(sp)
    CALL    alt_ic_isr_register    /* finally, call setup function */
  152aa8:	0152cb80 	call	152cb8 <alt_ic_isr_register>
    ADDI    sp, sp, WORD_SIZE      /* clean up stack after call */
  152aac:	dec00104 	addi	sp,sp,4

    MOVHI   r8, %hi(PIO_0_BASE)    /* write to the PIO int mask register */
  152ab0:	020005b4 	movhi	r8,22
    ORI 	r8, r8, %lo(PIO_0_BASE)
  152ab4:	42040814 	ori	r8,r8,4128
    MOVI    r9, ENABLE_ALL         /*  the ALL_ENABLE value */
  152ab8:	02400fc4 	movi	r9,63
    STB     r9, INTMASK_OF(r8)     /* enabling (unmasking) interrupts */
  152abc:	42400085 	stb	r9,2(r8)

    LDW     ra, 0(sp)              /* pop return address */
  152ac0:	dfc00017 	ldw	ra,0(sp)
    ADDI    sp, sp, WORD_SIZE
  152ac4:	dec00104 	addi	sp,sp,4

    RET                            /* and finally return */
  152ac8:	f800283a 	ret

00152acc <keys_handler>:


/* keys_handler */
    .global keys_handler
keys_handler:
    ADDI    sp, sp, NEG_WORD_SIZE   /* push r8 */
  152acc:	deffff04 	addi	sp,sp,-4
    STW     r8, 0(sp)
  152ad0:	da000015 	stw	r8,0(sp)

    MOVHI   et, %hi(PIO_0_BASE)  /* fetch PIO edge capture register */
  152ad4:	060005b4 	movhi	et,22
    ORI 	et, et, %lo(PIO_0_BASE)
  152ad8:	c6040814 	ori	et,et,4128
    LDB     r8, EDGE_CAP_OF(et)  
  152adc:	c20000c7 	ldb	r8,3(et)
                                 /* figure out what interrupt fired */
    MOVI    et, PUSH1_MASK       /* check if it was pushbutton 1 */
  152ae0:	06000004 	movi	et,0
    BEQ     r8, et, keys_handler_push1
  152ae4:	46000926 	beq	r8,et,152b0c <keys_handler_push1>
    MOVI    et, PUSH2_MASK       /* check if it was pushbutton 2 */
  152ae8:	06000004 	movi	et,0
    BEQ     r8, et, keys_handler_push2
  152aec:	46000926 	beq	r8,et,152b14 <keys_handler_push2>
    MOVI    et, ROT1R_MASK       /* check if it was rotary enc 1 right */
  152af0:	06000004 	movi	et,0
    BEQ     r8, et, keys_handler_rot1r
  152af4:	46000926 	beq	r8,et,152b1c <keys_handler_rot1r>
    MOVI    et, ROT1L_MASK       /* check if it was rotary enc 1 left */
  152af8:	06000004 	movi	et,0
    BEQ     r8, et, keys_handler_rot1l
  152afc:	46000926 	beq	r8,et,152b24 <keys_handler_rot1l>
    MOVI    et, ROT2R_MASK       /* check if it was rotary enc 2 right */
  152b00:	06000004 	movi	et,0
    BEQ     r8, et, keys_handler_rot2r
  152b04:	46000926 	beq	r8,et,152b2c <keys_handler_rot2r>
    JMPI    keys_handler_rot2l    /* else it must be rotary enc 2 left */
  152b08:	0152b341 	jmpi	152b34 <keys_handler_rot2l>

00152b0c <keys_handler_push1>:

keys_handler_push1:               /* handle pushbutton 1 ints */
    MOVI    et, KEY_MENU          /*  translates into menu key */
  152b0c:	06000044 	movi	et,1
    JMPI    keys_handler_done
  152b10:	0152b3c1 	jmpi	152b3c <keys_handler_done>

00152b14 <keys_handler_push2>:

keys_handler_push2:               /* handle pushbutton 2 ints */
    MOVI    et, KEY_MENU          /*  translates into menu key */
  152b14:	06000044 	movi	et,1
    JMPI    keys_handler_done
  152b18:	0152b3c1 	jmpi	152b3c <keys_handler_done>

00152b1c <keys_handler_rot1r>:

keys_handler_rot1r:               /* handle rotary enc 1 right ints */
    MOVI    et, KEY_DOWN          /*  translates into  up key */
  152b1c:	060000c4 	movi	et,3
    JMPI    keys_handler_done
  152b20:	0152b3c1 	jmpi	152b3c <keys_handler_done>

00152b24 <keys_handler_rot1l>:

keys_handler_rot1l:               /* handle rotary enc 2 left ints */
    MOVI    et, KEY_UP            /*  translates into down key */
  152b24:	06000084 	movi	et,2
    JMPI    keys_handler_done
  152b28:	0152b3c1 	jmpi	152b3c <keys_handler_done>

00152b2c <keys_handler_rot2r>:

keys_handler_rot2r:               /* handle rotary enc 2 right ints */
    MOVI    et, KEY_RIGHT         /*  translates into right key */
  152b2c:	06000144 	movi	et,5
    JMPI    keys_handler_done
  152b30:	0152b3c1 	jmpi	152b3c <keys_handler_done>

00152b34 <keys_handler_rot2l>:

keys_handler_rot2l:               /* handle rotary enc 2 left ints */
    MOVI    et, KEY_LEFT           /*  translates into left key */
  152b34:	06000104 	movi	et,4
    JMPI    keys_handler_done
  152b38:	0152b3c1 	jmpi	152b3c <keys_handler_done>

00152b3c <keys_handler_done>:

keys_handler_done:                /* handling completed */
    MOVHI   r8, %hi(PIO_0_BASE)   /* write back to edge capture register */
  152b3c:	020005b4 	movhi	r8,22
    ORI 	r8, r8, %lo(PIO_0_BASE)
  152b40:	42040814 	ori	r8,r8,4128
    STB     et, EDGE_CAP_OF(r8)   /*  to send EOI */
  152b44:	460000c5 	stb	et,3(r8)
  152b48:	02000574 	movhi	r8,21

    MOVIA   r8, curr_key          /* save to curr_key */
  152b4c:	4215d204 	addi	r8,r8,22344
    STB     et, 0(r8)             /*  the processed key */
  152b50:	46000005 	stb	et,0(r8)

    LDW     r8, 0(sp)             /* pop r8 */
  152b54:	da000017 	ldw	r8,0(sp)
    ADDI    sp, sp, WORD_SIZE
  152b58:	dec00104 	addi	sp,sp,4
    ADDI    ea, ea, NEG_WORD_SIZE /* correct address for hardware interrupts */
  152b5c:	ef7fff04 	addi	ea,ea,-4
    ERET                          /* use eret to return from int handler */
  152b60:	ef80083a 	eret

00152b64 <getkey>:
  152b64:	02000574 	movhi	r8,21


/* getKey */
    .global getkey
getkey:
    MOVIA   r8, curr_key      /* return current pending key */
  152b68:	4215d204 	addi	r8,r8,22344
    LDB     r2, 0(r8)
  152b6c:	40800007 	ldb	r2,0(r8)
    BEQ     r0, r2, getkey    /* if there is no key (curr_key == r0), block */
  152b70:	00bffc26 	beq	zero,r2,152b64 <getkey>

    RET                       /* return with current pending key in r2 */
  152b74:	f800283a 	ret

00152b78 <key_available>:
  152b78:	02000574 	movhi	r8,21

/* key_available */
    .globl key_available
key_available:
    MOVIA   r8, curr_key       /* return cu
  152b7c:	4215d204 	addi	r8,r8,22344
    rrent pending key */
    LDB     r2, 0(r8)          /* will be zero (FALSE) if no key is pending */
  152b80:	40800007 	ldb	r2,0(r8)

    RET                        /* return with boolean in r2 */
  152b84:	f800283a 	ret

00152b88 <udivmodsi4>:
  152b88:	2005883a 	mov	r2,r4
  152b8c:	2900182e 	bgeu	r5,r4,152bf0 <udivmodsi4+0x68>
  152b90:	28001716 	blt	r5,zero,152bf0 <udivmodsi4+0x68>
  152b94:	01000804 	movi	r4,32
  152b98:	00c00044 	movi	r3,1
  152b9c:	00000206 	br	152ba8 <udivmodsi4+0x20>
  152ba0:	20001126 	beq	r4,zero,152be8 <udivmodsi4+0x60>
  152ba4:	28000516 	blt	r5,zero,152bbc <udivmodsi4+0x34>
  152ba8:	294b883a 	add	r5,r5,r5
  152bac:	213fffc4 	addi	r4,r4,-1
  152bb0:	18c7883a 	add	r3,r3,r3
  152bb4:	28bffa36 	bltu	r5,r2,152ba0 <udivmodsi4+0x18>
  152bb8:	18000b26 	beq	r3,zero,152be8 <udivmodsi4+0x60>
  152bbc:	0009883a 	mov	r4,zero
  152bc0:	11400236 	bltu	r2,r5,152bcc <udivmodsi4+0x44>
  152bc4:	1145c83a 	sub	r2,r2,r5
  152bc8:	20c8b03a 	or	r4,r4,r3
  152bcc:	1806d07a 	srli	r3,r3,1
  152bd0:	280ad07a 	srli	r5,r5,1
  152bd4:	183ffa1e 	bne	r3,zero,152bc0 <udivmodsi4+0x38>
  152bd8:	3000021e 	bne	r6,zero,152be4 <udivmodsi4+0x5c>
  152bdc:	2005883a 	mov	r2,r4
  152be0:	f800283a 	ret
  152be4:	f800283a 	ret
  152be8:	0009883a 	mov	r4,zero
  152bec:	003ffa06 	br	152bd8 <udivmodsi4+0x50>
  152bf0:	00c00044 	movi	r3,1
  152bf4:	0009883a 	mov	r4,zero
  152bf8:	003ff106 	br	152bc0 <udivmodsi4+0x38>

00152bfc <__divsi3>:
  152bfc:	defffe04 	addi	sp,sp,-8
  152c00:	dfc00115 	stw	ra,4(sp)
  152c04:	dc000015 	stw	r16,0(sp)
  152c08:	20000a16 	blt	r4,zero,152c34 <__divsi3+0x38>
  152c0c:	0021883a 	mov	r16,zero
  152c10:	28000b16 	blt	r5,zero,152c40 <__divsi3+0x44>
  152c14:	000d883a 	mov	r6,zero
  152c18:	0152b880 	call	152b88 <udivmodsi4>
  152c1c:	80000126 	beq	r16,zero,152c24 <__divsi3+0x28>
  152c20:	0085c83a 	sub	r2,zero,r2
  152c24:	dfc00117 	ldw	ra,4(sp)
  152c28:	dc000017 	ldw	r16,0(sp)
  152c2c:	dec00204 	addi	sp,sp,8
  152c30:	f800283a 	ret
  152c34:	0109c83a 	sub	r4,zero,r4
  152c38:	04000044 	movi	r16,1
  152c3c:	283ff50e 	bge	r5,zero,152c14 <__divsi3+0x18>
  152c40:	014bc83a 	sub	r5,zero,r5
  152c44:	8400005c 	xori	r16,r16,1
  152c48:	003ff206 	br	152c14 <__divsi3+0x18>

00152c4c <__modsi3>:
  152c4c:	deffff04 	addi	sp,sp,-4
  152c50:	dfc00015 	stw	ra,0(sp)
  152c54:	20000516 	blt	r4,zero,152c6c <__modsi3+0x20>
  152c58:	28000c16 	blt	r5,zero,152c8c <__modsi3+0x40>
  152c5c:	01800044 	movi	r6,1
  152c60:	dfc00017 	ldw	ra,0(sp)
  152c64:	dec00104 	addi	sp,sp,4
  152c68:	0152b881 	jmpi	152b88 <udivmodsi4>
  152c6c:	0109c83a 	sub	r4,zero,r4
  152c70:	28000b16 	blt	r5,zero,152ca0 <__modsi3+0x54>
  152c74:	01800044 	movi	r6,1
  152c78:	0152b880 	call	152b88 <udivmodsi4>
  152c7c:	0085c83a 	sub	r2,zero,r2
  152c80:	dfc00017 	ldw	ra,0(sp)
  152c84:	dec00104 	addi	sp,sp,4
  152c88:	f800283a 	ret
  152c8c:	014bc83a 	sub	r5,zero,r5
  152c90:	01800044 	movi	r6,1
  152c94:	dfc00017 	ldw	ra,0(sp)
  152c98:	dec00104 	addi	sp,sp,4
  152c9c:	0152b881 	jmpi	152b88 <udivmodsi4>
  152ca0:	014bc83a 	sub	r5,zero,r5
  152ca4:	003ff306 	br	152c74 <__modsi3+0x28>

00152ca8 <__udivsi3>:
  152ca8:	000d883a 	mov	r6,zero
  152cac:	0152b881 	jmpi	152b88 <udivmodsi4>

00152cb0 <__umodsi3>:
  152cb0:	01800044 	movi	r6,1
  152cb4:	0152b881 	jmpi	152b88 <udivmodsi4>

00152cb8 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  152cb8:	defff904 	addi	sp,sp,-28
  152cbc:	dfc00615 	stw	ra,24(sp)
  152cc0:	df000515 	stw	fp,20(sp)
  152cc4:	df000504 	addi	fp,sp,20
  152cc8:	e13ffc15 	stw	r4,-16(fp)
  152ccc:	e17ffd15 	stw	r5,-12(fp)
  152cd0:	e1bffe15 	stw	r6,-8(fp)
  152cd4:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  152cd8:	e0800217 	ldw	r2,8(fp)
  152cdc:	d8800015 	stw	r2,0(sp)
  152ce0:	e13ffc17 	ldw	r4,-16(fp)
  152ce4:	e17ffd17 	ldw	r5,-12(fp)
  152ce8:	e1bffe17 	ldw	r6,-8(fp)
  152cec:	e1ffff17 	ldw	r7,-4(fp)
  152cf0:	0152e900 	call	152e90 <alt_iic_isr_register>
}  
  152cf4:	e037883a 	mov	sp,fp
  152cf8:	dfc00117 	ldw	ra,4(sp)
  152cfc:	df000017 	ldw	fp,0(sp)
  152d00:	dec00204 	addi	sp,sp,8
  152d04:	f800283a 	ret

00152d08 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  152d08:	defff904 	addi	sp,sp,-28
  152d0c:	df000615 	stw	fp,24(sp)
  152d10:	df000604 	addi	fp,sp,24
  152d14:	e13ffe15 	stw	r4,-8(fp)
  152d18:	e17fff15 	stw	r5,-4(fp)
  152d1c:	e0bfff17 	ldw	r2,-4(fp)
  152d20:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  152d24:	0005303a 	rdctl	r2,status
  152d28:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  152d2c:	e0fffb17 	ldw	r3,-20(fp)
  152d30:	00bfff84 	movi	r2,-2
  152d34:	1884703a 	and	r2,r3,r2
  152d38:	1001703a 	wrctl	status,r2
  
  return context;
  152d3c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  152d40:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  152d44:	e0bffa17 	ldw	r2,-24(fp)
  152d48:	00c00044 	movi	r3,1
  152d4c:	1884983a 	sll	r2,r3,r2
  152d50:	1007883a 	mov	r3,r2
  152d54:	008005b4 	movhi	r2,22
  152d58:	10a10204 	addi	r2,r2,-31736
  152d5c:	10800017 	ldw	r2,0(r2)
  152d60:	1886b03a 	or	r3,r3,r2
  152d64:	008005b4 	movhi	r2,22
  152d68:	10a10204 	addi	r2,r2,-31736
  152d6c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  152d70:	008005b4 	movhi	r2,22
  152d74:	10a10204 	addi	r2,r2,-31736
  152d78:	10800017 	ldw	r2,0(r2)
  152d7c:	100170fa 	wrctl	ienable,r2
  152d80:	e0bffc17 	ldw	r2,-16(fp)
  152d84:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  152d88:	e0bffd17 	ldw	r2,-12(fp)
  152d8c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  152d90:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
  152d94:	e037883a 	mov	sp,fp
  152d98:	df000017 	ldw	fp,0(sp)
  152d9c:	dec00104 	addi	sp,sp,4
  152da0:	f800283a 	ret

00152da4 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  152da4:	defff904 	addi	sp,sp,-28
  152da8:	df000615 	stw	fp,24(sp)
  152dac:	df000604 	addi	fp,sp,24
  152db0:	e13ffe15 	stw	r4,-8(fp)
  152db4:	e17fff15 	stw	r5,-4(fp)
  152db8:	e0bfff17 	ldw	r2,-4(fp)
  152dbc:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  152dc0:	0005303a 	rdctl	r2,status
  152dc4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  152dc8:	e0fffb17 	ldw	r3,-20(fp)
  152dcc:	00bfff84 	movi	r2,-2
  152dd0:	1884703a 	and	r2,r3,r2
  152dd4:	1001703a 	wrctl	status,r2
  
  return context;
  152dd8:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  152ddc:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  152de0:	e0bffa17 	ldw	r2,-24(fp)
  152de4:	00c00044 	movi	r3,1
  152de8:	1884983a 	sll	r2,r3,r2
  152dec:	0084303a 	nor	r2,zero,r2
  152df0:	1007883a 	mov	r3,r2
  152df4:	008005b4 	movhi	r2,22
  152df8:	10a10204 	addi	r2,r2,-31736
  152dfc:	10800017 	ldw	r2,0(r2)
  152e00:	1886703a 	and	r3,r3,r2
  152e04:	008005b4 	movhi	r2,22
  152e08:	10a10204 	addi	r2,r2,-31736
  152e0c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  152e10:	008005b4 	movhi	r2,22
  152e14:	10a10204 	addi	r2,r2,-31736
  152e18:	10800017 	ldw	r2,0(r2)
  152e1c:	100170fa 	wrctl	ienable,r2
  152e20:	e0bffc17 	ldw	r2,-16(fp)
  152e24:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  152e28:	e0bffd17 	ldw	r2,-12(fp)
  152e2c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  152e30:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
  152e34:	e037883a 	mov	sp,fp
  152e38:	df000017 	ldw	fp,0(sp)
  152e3c:	dec00104 	addi	sp,sp,4
  152e40:	f800283a 	ret

00152e44 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  152e44:	defffc04 	addi	sp,sp,-16
  152e48:	df000315 	stw	fp,12(sp)
  152e4c:	df000304 	addi	fp,sp,12
  152e50:	e13ffe15 	stw	r4,-8(fp)
  152e54:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  152e58:	000530fa 	rdctl	r2,ienable
  152e5c:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  152e60:	e0bfff17 	ldw	r2,-4(fp)
  152e64:	00c00044 	movi	r3,1
  152e68:	1884983a 	sll	r2,r3,r2
  152e6c:	1007883a 	mov	r3,r2
  152e70:	e0bffd17 	ldw	r2,-12(fp)
  152e74:	1884703a 	and	r2,r3,r2
  152e78:	1004c03a 	cmpne	r2,r2,zero
  152e7c:	10803fcc 	andi	r2,r2,255
}
  152e80:	e037883a 	mov	sp,fp
  152e84:	df000017 	ldw	fp,0(sp)
  152e88:	dec00104 	addi	sp,sp,4
  152e8c:	f800283a 	ret

00152e90 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  152e90:	defff504 	addi	sp,sp,-44
  152e94:	dfc00a15 	stw	ra,40(sp)
  152e98:	df000915 	stw	fp,36(sp)
  152e9c:	df000904 	addi	fp,sp,36
  152ea0:	e13ffc15 	stw	r4,-16(fp)
  152ea4:	e17ffd15 	stw	r5,-12(fp)
  152ea8:	e1bffe15 	stw	r6,-8(fp)
  152eac:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  152eb0:	00bffa84 	movi	r2,-22
  152eb4:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  152eb8:	e0bffd17 	ldw	r2,-12(fp)
  152ebc:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  152ec0:	e0bff817 	ldw	r2,-32(fp)
  152ec4:	10800808 	cmpgei	r2,r2,32
  152ec8:	1000271e 	bne	r2,zero,152f68 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  152ecc:	0005303a 	rdctl	r2,status
  152ed0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  152ed4:	e0fffa17 	ldw	r3,-24(fp)
  152ed8:	00bfff84 	movi	r2,-2
  152edc:	1884703a 	and	r2,r3,r2
  152ee0:	1001703a 	wrctl	status,r2
  
  return context;
  152ee4:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  152ee8:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
  152eec:	00c005b4 	movhi	r3,22
  152ef0:	18e24604 	addi	r3,r3,-30440
  152ef4:	e0bff817 	ldw	r2,-32(fp)
  152ef8:	100490fa 	slli	r2,r2,3
  152efc:	1885883a 	add	r2,r3,r2
  152f00:	e0fffe17 	ldw	r3,-8(fp)
  152f04:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  152f08:	00c005b4 	movhi	r3,22
  152f0c:	18e24604 	addi	r3,r3,-30440
  152f10:	e0bff817 	ldw	r2,-32(fp)
  152f14:	100490fa 	slli	r2,r2,3
  152f18:	1885883a 	add	r2,r3,r2
  152f1c:	10800104 	addi	r2,r2,4
  152f20:	e0ffff17 	ldw	r3,-4(fp)
  152f24:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  152f28:	e0bffe17 	ldw	r2,-8(fp)
  152f2c:	10000526 	beq	r2,zero,152f44 <alt_iic_isr_register+0xb4>
  152f30:	e0bff817 	ldw	r2,-32(fp)
  152f34:	e13ffc17 	ldw	r4,-16(fp)
  152f38:	100b883a 	mov	r5,r2
  152f3c:	0152d080 	call	152d08 <alt_ic_irq_enable>
  152f40:	00000406 	br	152f54 <alt_iic_isr_register+0xc4>
  152f44:	e0bff817 	ldw	r2,-32(fp)
  152f48:	e13ffc17 	ldw	r4,-16(fp)
  152f4c:	100b883a 	mov	r5,r2
  152f50:	0152da40 	call	152da4 <alt_ic_irq_disable>
  152f54:	e0bff715 	stw	r2,-36(fp)
  152f58:	e0bff917 	ldw	r2,-28(fp)
  152f5c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  152f60:	e0bffb17 	ldw	r2,-20(fp)
  152f64:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  152f68:	e0bff717 	ldw	r2,-36(fp)
}
  152f6c:	e037883a 	mov	sp,fp
  152f70:	dfc00117 	ldw	ra,4(sp)
  152f74:	df000017 	ldw	fp,0(sp)
  152f78:	dec00204 	addi	sp,sp,8
  152f7c:	f800283a 	ret

00152f80 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  152f80:	defffc04 	addi	sp,sp,-16
  152f84:	df000315 	stw	fp,12(sp)
  152f88:	df000304 	addi	fp,sp,12
  152f8c:	e13ffd15 	stw	r4,-12(fp)
  152f90:	e17ffe15 	stw	r5,-8(fp)
  152f94:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  152f98:	e0fffe17 	ldw	r3,-8(fp)
  152f9c:	e0bffd17 	ldw	r2,-12(fp)
  152fa0:	18800e26 	beq	r3,r2,152fdc <alt_load_section+0x5c>
  {
    while( to != end )
  152fa4:	00000a06 	br	152fd0 <alt_load_section+0x50>
    {
      *to++ = *from++;
  152fa8:	e0bffd17 	ldw	r2,-12(fp)
  152fac:	10c00017 	ldw	r3,0(r2)
  152fb0:	e0bffe17 	ldw	r2,-8(fp)
  152fb4:	10c00015 	stw	r3,0(r2)
  152fb8:	e0bffe17 	ldw	r2,-8(fp)
  152fbc:	10800104 	addi	r2,r2,4
  152fc0:	e0bffe15 	stw	r2,-8(fp)
  152fc4:	e0bffd17 	ldw	r2,-12(fp)
  152fc8:	10800104 	addi	r2,r2,4
  152fcc:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  152fd0:	e0fffe17 	ldw	r3,-8(fp)
  152fd4:	e0bfff17 	ldw	r2,-4(fp)
  152fd8:	18bff31e 	bne	r3,r2,152fa8 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
  152fdc:	e037883a 	mov	sp,fp
  152fe0:	df000017 	ldw	fp,0(sp)
  152fe4:	dec00104 	addi	sp,sp,4
  152fe8:	f800283a 	ret

00152fec <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  152fec:	defffe04 	addi	sp,sp,-8
  152ff0:	dfc00115 	stw	ra,4(sp)
  152ff4:	df000015 	stw	fp,0(sp)
  152ff8:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  152ffc:	01000574 	movhi	r4,21
  153000:	211b6204 	addi	r4,r4,28040
  153004:	01400574 	movhi	r5,21
  153008:	2955d204 	addi	r5,r5,22344
  15300c:	01800574 	movhi	r6,21
  153010:	319b6204 	addi	r6,r6,28040
  153014:	0152f800 	call	152f80 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  153018:	01000574 	movhi	r4,21
  15301c:	21000804 	addi	r4,r4,32
  153020:	01400574 	movhi	r5,21
  153024:	29400804 	addi	r5,r5,32
  153028:	01800574 	movhi	r6,21
  15302c:	31806e04 	addi	r6,r6,440
  153030:	0152f800 	call	152f80 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  153034:	01000574 	movhi	r4,21
  153038:	2113a604 	addi	r4,r4,20120
  15303c:	01400574 	movhi	r5,21
  153040:	2953a604 	addi	r5,r5,20120
  153044:	01800574 	movhi	r6,21
  153048:	3195d204 	addi	r6,r6,22344
  15304c:	0152f800 	call	152f80 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  153050:	0153e500 	call	153e50 <alt_dcache_flush_all>
  alt_icache_flush_all();
  153054:	01540680 	call	154068 <alt_icache_flush_all>
}
  153058:	e037883a 	mov	sp,fp
  15305c:	dfc00117 	ldw	ra,4(sp)
  153060:	df000017 	ldw	fp,0(sp)
  153064:	dec00204 	addi	sp,sp,8
  153068:	f800283a 	ret

0015306c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  15306c:	defffd04 	addi	sp,sp,-12
  153070:	dfc00215 	stw	ra,8(sp)
  153074:	df000115 	stw	fp,4(sp)
  153078:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  15307c:	0009883a 	mov	r4,zero
  153080:	015311c0 	call	15311c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  153084:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  153088:	01531500 	call	153150 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  15308c:	01000574 	movhi	r4,21
  153090:	2115c804 	addi	r4,r4,22304
  153094:	01400574 	movhi	r5,21
  153098:	2955c804 	addi	r5,r5,22304
  15309c:	01800574 	movhi	r6,21
  1530a0:	3195c804 	addi	r6,r6,22304
  1530a4:	01541580 	call	154158 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  1530a8:	0153fb00 	call	153fb0 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  1530ac:	01000574 	movhi	r4,21
  1530b0:	21100304 	addi	r4,r4,16396
  1530b4:	01549400 	call	154940 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  1530b8:	d125ae17 	ldw	r4,-26952(gp)
  1530bc:	d0e5af17 	ldw	r3,-26948(gp)
  1530c0:	d0a5b017 	ldw	r2,-26944(gp)
  1530c4:	180b883a 	mov	r5,r3
  1530c8:	100d883a 	mov	r6,r2
  1530cc:	01507380 	call	150738 <main>
  1530d0:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  1530d4:	01000044 	movi	r4,1
  1530d8:	0153d880 	call	153d88 <close>
  exit (result);
  1530dc:	e13fff17 	ldw	r4,-4(fp)
  1530e0:	01549540 	call	154954 <exit>

001530e4 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  1530e4:	defffd04 	addi	sp,sp,-12
  1530e8:	dfc00215 	stw	ra,8(sp)
  1530ec:	df000115 	stw	fp,4(sp)
  1530f0:	df000104 	addi	fp,sp,4
  1530f4:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  1530f8:	e13fff17 	ldw	r4,-4(fp)
  1530fc:	01400574 	movhi	r5,21
  153100:	295b5a04 	addi	r5,r5,28008
  153104:	0153f100 	call	153f10 <alt_dev_llist_insert>
}
  153108:	e037883a 	mov	sp,fp
  15310c:	dfc00117 	ldw	ra,4(sp)
  153110:	df000017 	ldw	fp,0(sp)
  153114:	dec00204 	addi	sp,sp,8
  153118:	f800283a 	ret

0015311c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  15311c:	defffd04 	addi	sp,sp,-12
  153120:	dfc00215 	stw	ra,8(sp)
  153124:	df000115 	stw	fp,4(sp)
  153128:	df000104 	addi	fp,sp,4
  15312c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS, nios);
  153130:	015463c0 	call	15463c <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  153134:	00800044 	movi	r2,1
  153138:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  15313c:	e037883a 	mov	sp,fp
  153140:	dfc00117 	ldw	ra,4(sp)
  153144:	df000017 	ldw	fp,0(sp)
  153148:	dec00204 	addi	sp,sp,8
  15314c:	f800283a 	ret

00153150 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  153150:	defffe04 	addi	sp,sp,-8
  153154:	dfc00115 	stw	ra,4(sp)
  153158:	df000015 	stw	fp,0(sp)
  15315c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG, jtag);
  153160:	01000574 	movhi	r4,21
  153164:	2115dd04 	addi	r4,r4,22388
  153168:	000b883a 	mov	r5,zero
  15316c:	000d883a 	mov	r6,zero
  153170:	01532f80 	call	1532f8 <altera_avalon_jtag_uart_init>
  153174:	01000574 	movhi	r4,21
  153178:	2115d304 	addi	r4,r4,22348
  15317c:	01530e40 	call	1530e4 <alt_dev_reg>
}
  153180:	e037883a 	mov	sp,fp
  153184:	dfc00117 	ldw	ra,4(sp)
  153188:	df000017 	ldw	fp,0(sp)
  15318c:	dec00204 	addi	sp,sp,8
  153190:	f800283a 	ret

00153194 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  153194:	defffa04 	addi	sp,sp,-24
  153198:	dfc00515 	stw	ra,20(sp)
  15319c:	df000415 	stw	fp,16(sp)
  1531a0:	df000404 	addi	fp,sp,16
  1531a4:	e13ffd15 	stw	r4,-12(fp)
  1531a8:	e17ffe15 	stw	r5,-8(fp)
  1531ac:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  1531b0:	e0bffd17 	ldw	r2,-12(fp)
  1531b4:	10800017 	ldw	r2,0(r2)
  1531b8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  1531bc:	e0bffc17 	ldw	r2,-16(fp)
  1531c0:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
  1531c4:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  1531c8:	10800217 	ldw	r2,8(r2)
  1531cc:	1809883a 	mov	r4,r3
  1531d0:	e17ffe17 	ldw	r5,-8(fp)
  1531d4:	e1bfff17 	ldw	r6,-4(fp)
  1531d8:	100f883a 	mov	r7,r2
  1531dc:	01537bc0 	call	1537bc <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  1531e0:	e037883a 	mov	sp,fp
  1531e4:	dfc00117 	ldw	ra,4(sp)
  1531e8:	df000017 	ldw	fp,0(sp)
  1531ec:	dec00204 	addi	sp,sp,8
  1531f0:	f800283a 	ret

001531f4 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  1531f4:	defffa04 	addi	sp,sp,-24
  1531f8:	dfc00515 	stw	ra,20(sp)
  1531fc:	df000415 	stw	fp,16(sp)
  153200:	df000404 	addi	fp,sp,16
  153204:	e13ffd15 	stw	r4,-12(fp)
  153208:	e17ffe15 	stw	r5,-8(fp)
  15320c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  153210:	e0bffd17 	ldw	r2,-12(fp)
  153214:	10800017 	ldw	r2,0(r2)
  153218:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  15321c:	e0bffc17 	ldw	r2,-16(fp)
  153220:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
  153224:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  153228:	10800217 	ldw	r2,8(r2)
  15322c:	1809883a 	mov	r4,r3
  153230:	e17ffe17 	ldw	r5,-8(fp)
  153234:	e1bfff17 	ldw	r6,-4(fp)
  153238:	100f883a 	mov	r7,r2
  15323c:	01539d40 	call	1539d4 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  153240:	e037883a 	mov	sp,fp
  153244:	dfc00117 	ldw	ra,4(sp)
  153248:	df000017 	ldw	fp,0(sp)
  15324c:	dec00204 	addi	sp,sp,8
  153250:	f800283a 	ret

00153254 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  153254:	defffc04 	addi	sp,sp,-16
  153258:	dfc00315 	stw	ra,12(sp)
  15325c:	df000215 	stw	fp,8(sp)
  153260:	df000204 	addi	fp,sp,8
  153264:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  153268:	e0bfff17 	ldw	r2,-4(fp)
  15326c:	10800017 	ldw	r2,0(r2)
  153270:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  153274:	e0bffe17 	ldw	r2,-8(fp)
  153278:	10c00a04 	addi	r3,r2,40
  15327c:	e0bfff17 	ldw	r2,-4(fp)
  153280:	10800217 	ldw	r2,8(r2)
  153284:	1809883a 	mov	r4,r3
  153288:	100b883a 	mov	r5,r2
  15328c:	01536600 	call	153660 <altera_avalon_jtag_uart_close>
}
  153290:	e037883a 	mov	sp,fp
  153294:	dfc00117 	ldw	ra,4(sp)
  153298:	df000017 	ldw	fp,0(sp)
  15329c:	dec00204 	addi	sp,sp,8
  1532a0:	f800283a 	ret

001532a4 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  1532a4:	defffa04 	addi	sp,sp,-24
  1532a8:	dfc00515 	stw	ra,20(sp)
  1532ac:	df000415 	stw	fp,16(sp)
  1532b0:	df000404 	addi	fp,sp,16
  1532b4:	e13ffd15 	stw	r4,-12(fp)
  1532b8:	e17ffe15 	stw	r5,-8(fp)
  1532bc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  1532c0:	e0bffd17 	ldw	r2,-12(fp)
  1532c4:	10800017 	ldw	r2,0(r2)
  1532c8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  1532cc:	e0bffc17 	ldw	r2,-16(fp)
  1532d0:	10800a04 	addi	r2,r2,40
  1532d4:	1009883a 	mov	r4,r2
  1532d8:	e17ffe17 	ldw	r5,-8(fp)
  1532dc:	e1bfff17 	ldw	r6,-4(fp)
  1532e0:	01536c80 	call	1536c8 <altera_avalon_jtag_uart_ioctl>
}
  1532e4:	e037883a 	mov	sp,fp
  1532e8:	dfc00117 	ldw	ra,4(sp)
  1532ec:	df000017 	ldw	fp,0(sp)
  1532f0:	dec00204 	addi	sp,sp,8
  1532f4:	f800283a 	ret

001532f8 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  1532f8:	defffa04 	addi	sp,sp,-24
  1532fc:	dfc00515 	stw	ra,20(sp)
  153300:	df000415 	stw	fp,16(sp)
  153304:	df000404 	addi	fp,sp,16
  153308:	e13ffd15 	stw	r4,-12(fp)
  15330c:	e17ffe15 	stw	r5,-8(fp)
  153310:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  153314:	e0bffd17 	ldw	r2,-12(fp)
  153318:	00c00044 	movi	r3,1
  15331c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  153320:	e0bffd17 	ldw	r2,-12(fp)
  153324:	10800017 	ldw	r2,0(r2)
  153328:	10800104 	addi	r2,r2,4
  15332c:	e0fffd17 	ldw	r3,-12(fp)
  153330:	18c00817 	ldw	r3,32(r3)
  153334:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
  153338:	e0fffe17 	ldw	r3,-8(fp)
  15333c:	e0bfff17 	ldw	r2,-4(fp)
  153340:	d8000015 	stw	zero,0(sp)
  153344:	1809883a 	mov	r4,r3
  153348:	100b883a 	mov	r5,r2
  15334c:	01800574 	movhi	r6,21
  153350:	318cee04 	addi	r6,r6,13240
  153354:	e1fffd17 	ldw	r7,-12(fp)
  153358:	0152cb80 	call	152cb8 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  15335c:	e0bffd17 	ldw	r2,-12(fp)
  153360:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  153364:	e0bffd17 	ldw	r2,-12(fp)
  153368:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  15336c:	008005b4 	movhi	r2,22
  153370:	10a10604 	addi	r2,r2,-31720
  153374:	10800017 	ldw	r2,0(r2)
  153378:	1809883a 	mov	r4,r3
  15337c:	100b883a 	mov	r5,r2
  153380:	01800574 	movhi	r6,21
  153384:	318d6f04 	addi	r6,r6,13756
  153388:	e1fffd17 	ldw	r7,-12(fp)
  15338c:	0153bf80 	call	153bf8 <alt_alarm_start>
  153390:	1000040e 	bge	r2,zero,1533a4 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  153394:	e0bffd17 	ldw	r2,-12(fp)
  153398:	00e00034 	movhi	r3,32768
  15339c:	18ffffc4 	addi	r3,r3,-1
  1533a0:	10c00115 	stw	r3,4(r2)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  1533a4:	e037883a 	mov	sp,fp
  1533a8:	dfc00117 	ldw	ra,4(sp)
  1533ac:	df000017 	ldw	fp,0(sp)
  1533b0:	dec00204 	addi	sp,sp,8
  1533b4:	f800283a 	ret

001533b8 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  1533b8:	defff804 	addi	sp,sp,-32
  1533bc:	df000715 	stw	fp,28(sp)
  1533c0:	df000704 	addi	fp,sp,28
  1533c4:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  1533c8:	e0bfff17 	ldw	r2,-4(fp)
  1533cc:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
  1533d0:	e0bffb17 	ldw	r2,-20(fp)
  1533d4:	10800017 	ldw	r2,0(r2)
  1533d8:	e0bffc15 	stw	r2,-16(fp)
  1533dc:	00000106 	br	1533e4 <altera_avalon_jtag_uart_irq+0x2c>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
  1533e0:	0001883a 	nop
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  1533e4:	e0bffc17 	ldw	r2,-16(fp)
  1533e8:	10800104 	addi	r2,r2,4
  1533ec:	10800037 	ldwio	r2,0(r2)
  1533f0:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  1533f4:	e0bffd17 	ldw	r2,-12(fp)
  1533f8:	1080c00c 	andi	r2,r2,768
  1533fc:	10006a26 	beq	r2,zero,1535a8 <altera_avalon_jtag_uart_irq+0x1f0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  153400:	e0bffd17 	ldw	r2,-12(fp)
  153404:	1080400c 	andi	r2,r2,256
  153408:	10003326 	beq	r2,zero,1534d8 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  15340c:	00800074 	movhi	r2,1
  153410:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  153414:	e0bffb17 	ldw	r2,-20(fp)
  153418:	10800a17 	ldw	r2,40(r2)
  15341c:	10800044 	addi	r2,r2,1
  153420:	1081ffcc 	andi	r2,r2,2047
  153424:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
  153428:	e0bffb17 	ldw	r2,-20(fp)
  15342c:	10c00b17 	ldw	r3,44(r2)
  153430:	e0bffe17 	ldw	r2,-8(fp)
  153434:	18801426 	beq	r3,r2,153488 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  153438:	e0bffc17 	ldw	r2,-16(fp)
  15343c:	10800037 	ldwio	r2,0(r2)
  153440:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  153444:	e0bff917 	ldw	r2,-28(fp)
  153448:	10a0000c 	andi	r2,r2,32768
  15344c:	10001026 	beq	r2,zero,153490 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  153450:	e0bffb17 	ldw	r2,-20(fp)
  153454:	10800a17 	ldw	r2,40(r2)
  153458:	e0fff917 	ldw	r3,-28(fp)
  15345c:	e13ffb17 	ldw	r4,-20(fp)
  153460:	2085883a 	add	r2,r4,r2
  153464:	10800e04 	addi	r2,r2,56
  153468:	10c00005 	stb	r3,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  15346c:	e0bffb17 	ldw	r2,-20(fp)
  153470:	10800a17 	ldw	r2,40(r2)
  153474:	10800044 	addi	r2,r2,1
  153478:	10c1ffcc 	andi	r3,r2,2047
  15347c:	e0bffb17 	ldw	r2,-20(fp)
  153480:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
  153484:	003fe306 	br	153414 <altera_avalon_jtag_uart_irq+0x5c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
  153488:	0001883a 	nop
  15348c:	00000106 	br	153494 <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
  153490:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  153494:	e0bff917 	ldw	r2,-28(fp)
  153498:	10bfffec 	andhi	r2,r2,65535
  15349c:	10000e26 	beq	r2,zero,1534d8 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  1534a0:	e0bffb17 	ldw	r2,-20(fp)
  1534a4:	10c00817 	ldw	r3,32(r2)
  1534a8:	00bfff84 	movi	r2,-2
  1534ac:	1886703a 	and	r3,r3,r2
  1534b0:	e0bffb17 	ldw	r2,-20(fp)
  1534b4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  1534b8:	e0bffc17 	ldw	r2,-16(fp)
  1534bc:	10800104 	addi	r2,r2,4
  1534c0:	e0fffb17 	ldw	r3,-20(fp)
  1534c4:	18c00817 	ldw	r3,32(r3)
  1534c8:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  1534cc:	e0bffc17 	ldw	r2,-16(fp)
  1534d0:	10800104 	addi	r2,r2,4
  1534d4:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  1534d8:	e0bffd17 	ldw	r2,-12(fp)
  1534dc:	1080800c 	andi	r2,r2,512
  1534e0:	103fbf26 	beq	r2,zero,1533e0 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  1534e4:	e0bffd17 	ldw	r2,-12(fp)
  1534e8:	1004d43a 	srli	r2,r2,16
  1534ec:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  1534f0:	00001406 	br	153544 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  1534f4:	e0bffc17 	ldw	r2,-16(fp)
  1534f8:	e0fffb17 	ldw	r3,-20(fp)
  1534fc:	18c00d17 	ldw	r3,52(r3)
  153500:	e13ffb17 	ldw	r4,-20(fp)
  153504:	20c7883a 	add	r3,r4,r3
  153508:	18c20e04 	addi	r3,r3,2104
  15350c:	18c00003 	ldbu	r3,0(r3)
  153510:	18c03fcc 	andi	r3,r3,255
  153514:	18c0201c 	xori	r3,r3,128
  153518:	18ffe004 	addi	r3,r3,-128
  15351c:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  153520:	e0bffb17 	ldw	r2,-20(fp)
  153524:	10800d17 	ldw	r2,52(r2)
  153528:	10800044 	addi	r2,r2,1
  15352c:	10c1ffcc 	andi	r3,r2,2047
  153530:	e0bffb17 	ldw	r2,-20(fp)
  153534:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
  153538:	e0bffa17 	ldw	r2,-24(fp)
  15353c:	10bfffc4 	addi	r2,r2,-1
  153540:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
  153544:	e0bffa17 	ldw	r2,-24(fp)
  153548:	10000526 	beq	r2,zero,153560 <altera_avalon_jtag_uart_irq+0x1a8>
  15354c:	e0bffb17 	ldw	r2,-20(fp)
  153550:	10c00d17 	ldw	r3,52(r2)
  153554:	e0bffb17 	ldw	r2,-20(fp)
  153558:	10800c17 	ldw	r2,48(r2)
  15355c:	18bfe51e 	bne	r3,r2,1534f4 <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
  153560:	e0bffa17 	ldw	r2,-24(fp)
  153564:	103f9e26 	beq	r2,zero,1533e0 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  153568:	e0bffb17 	ldw	r2,-20(fp)
  15356c:	10c00817 	ldw	r3,32(r2)
  153570:	00bfff44 	movi	r2,-3
  153574:	1886703a 	and	r3,r3,r2
  153578:	e0bffb17 	ldw	r2,-20(fp)
  15357c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  153580:	e0bffb17 	ldw	r2,-20(fp)
  153584:	10800017 	ldw	r2,0(r2)
  153588:	10800104 	addi	r2,r2,4
  15358c:	e0fffb17 	ldw	r3,-20(fp)
  153590:	18c00817 	ldw	r3,32(r3)
  153594:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  153598:	e0bffc17 	ldw	r2,-16(fp)
  15359c:	10800104 	addi	r2,r2,4
  1535a0:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
  1535a4:	003f8e06 	br	1533e0 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
  1535a8:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
  1535ac:	e037883a 	mov	sp,fp
  1535b0:	df000017 	ldw	fp,0(sp)
  1535b4:	dec00104 	addi	sp,sp,4
  1535b8:	f800283a 	ret

001535bc <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  1535bc:	defffc04 	addi	sp,sp,-16
  1535c0:	df000315 	stw	fp,12(sp)
  1535c4:	df000304 	addi	fp,sp,12
  1535c8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  1535cc:	e0bfff17 	ldw	r2,-4(fp)
  1535d0:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  1535d4:	e0bffd17 	ldw	r2,-12(fp)
  1535d8:	10800017 	ldw	r2,0(r2)
  1535dc:	10800104 	addi	r2,r2,4
  1535e0:	10800037 	ldwio	r2,0(r2)
  1535e4:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  1535e8:	e0bffe17 	ldw	r2,-8(fp)
  1535ec:	1081000c 	andi	r2,r2,1024
  1535f0:	10000a26 	beq	r2,zero,15361c <altera_avalon_jtag_uart_timeout+0x60>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  1535f4:	e0bffd17 	ldw	r2,-12(fp)
  1535f8:	10800017 	ldw	r2,0(r2)
  1535fc:	10800104 	addi	r2,r2,4
  153600:	e0fffd17 	ldw	r3,-12(fp)
  153604:	18c00817 	ldw	r3,32(r3)
  153608:	18c10014 	ori	r3,r3,1024
  15360c:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
  153610:	e0bffd17 	ldw	r2,-12(fp)
  153614:	10000915 	stw	zero,36(r2)
  153618:	00000a06 	br	153644 <altera_avalon_jtag_uart_timeout+0x88>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  15361c:	e0bffd17 	ldw	r2,-12(fp)
  153620:	10800917 	ldw	r2,36(r2)
  153624:	00e00034 	movhi	r3,32768
  153628:	18ffff04 	addi	r3,r3,-4
  15362c:	18800536 	bltu	r3,r2,153644 <altera_avalon_jtag_uart_timeout+0x88>
    sp->host_inactive++;
  153630:	e0bffd17 	ldw	r2,-12(fp)
  153634:	10800917 	ldw	r2,36(r2)
  153638:	10c00044 	addi	r3,r2,1
  15363c:	e0bffd17 	ldw	r2,-12(fp)
  153640:	10c00915 	stw	r3,36(r2)
  153644:	008005b4 	movhi	r2,22
  153648:	10a10604 	addi	r2,r2,-31720
  15364c:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  153650:	e037883a 	mov	sp,fp
  153654:	df000017 	ldw	fp,0(sp)
  153658:	dec00104 	addi	sp,sp,4
  15365c:	f800283a 	ret

00153660 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  153660:	defffd04 	addi	sp,sp,-12
  153664:	df000215 	stw	fp,8(sp)
  153668:	df000204 	addi	fp,sp,8
  15366c:	e13ffe15 	stw	r4,-8(fp)
  153670:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  153674:	00000506 	br	15368c <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  153678:	e0bfff17 	ldw	r2,-4(fp)
  15367c:	1090000c 	andi	r2,r2,16384
  153680:	10000226 	beq	r2,zero,15368c <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  153684:	00bffd44 	movi	r2,-11
  153688:	00000b06 	br	1536b8 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  15368c:	e0bffe17 	ldw	r2,-8(fp)
  153690:	10c00d17 	ldw	r3,52(r2)
  153694:	e0bffe17 	ldw	r2,-8(fp)
  153698:	10800c17 	ldw	r2,48(r2)
  15369c:	18800526 	beq	r3,r2,1536b4 <altera_avalon_jtag_uart_close+0x54>
  1536a0:	e0bffe17 	ldw	r2,-8(fp)
  1536a4:	10c00917 	ldw	r3,36(r2)
  1536a8:	e0bffe17 	ldw	r2,-8(fp)
  1536ac:	10800117 	ldw	r2,4(r2)
  1536b0:	18bff136 	bltu	r3,r2,153678 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  1536b4:	0005883a 	mov	r2,zero
}
  1536b8:	e037883a 	mov	sp,fp
  1536bc:	df000017 	ldw	fp,0(sp)
  1536c0:	dec00104 	addi	sp,sp,4
  1536c4:	f800283a 	ret

001536c8 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  1536c8:	defffa04 	addi	sp,sp,-24
  1536cc:	df000515 	stw	fp,20(sp)
  1536d0:	df000504 	addi	fp,sp,20
  1536d4:	e13ffd15 	stw	r4,-12(fp)
  1536d8:	e17ffe15 	stw	r5,-8(fp)
  1536dc:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
  1536e0:	00bff9c4 	movi	r2,-25
  1536e4:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
  1536e8:	e0bffe17 	ldw	r2,-8(fp)
  1536ec:	10da8060 	cmpeqi	r3,r2,27137
  1536f0:	1800031e 	bne	r3,zero,153700 <altera_avalon_jtag_uart_ioctl+0x38>
  1536f4:	109a80a0 	cmpeqi	r2,r2,27138
  1536f8:	1000181e 	bne	r2,zero,15375c <altera_avalon_jtag_uart_ioctl+0x94>
  1536fc:	00002606 	br	153798 <altera_avalon_jtag_uart_ioctl+0xd0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
  153700:	e0bffd17 	ldw	r2,-12(fp)
  153704:	10c00117 	ldw	r3,4(r2)
  153708:	00a00034 	movhi	r2,32768
  15370c:	10bfffc4 	addi	r2,r2,-1
  153710:	18802226 	beq	r3,r2,15379c <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      int timeout = *((int *)arg);
  153714:	e0bfff17 	ldw	r2,-4(fp)
  153718:	10800017 	ldw	r2,0(r2)
  15371c:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  153720:	e0bffc17 	ldw	r2,-16(fp)
  153724:	10800090 	cmplti	r2,r2,2
  153728:	1000061e 	bne	r2,zero,153744 <altera_avalon_jtag_uart_ioctl+0x7c>
  15372c:	e0fffc17 	ldw	r3,-16(fp)
  153730:	00a00034 	movhi	r2,32768
  153734:	10bfffc4 	addi	r2,r2,-1
  153738:	18800226 	beq	r3,r2,153744 <altera_avalon_jtag_uart_ioctl+0x7c>
  15373c:	e0bffc17 	ldw	r2,-16(fp)
  153740:	00000206 	br	15374c <altera_avalon_jtag_uart_ioctl+0x84>
  153744:	00a00034 	movhi	r2,32768
  153748:	10bfff84 	addi	r2,r2,-2
  15374c:	e0fffd17 	ldw	r3,-12(fp)
  153750:	18800115 	stw	r2,4(r3)
      rc = 0;
  153754:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  153758:	00001006 	br	15379c <altera_avalon_jtag_uart_ioctl+0xd4>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
  15375c:	e0bffd17 	ldw	r2,-12(fp)
  153760:	10c00117 	ldw	r3,4(r2)
  153764:	00a00034 	movhi	r2,32768
  153768:	10bfffc4 	addi	r2,r2,-1
  15376c:	18800d26 	beq	r3,r2,1537a4 <altera_avalon_jtag_uart_ioctl+0xdc>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  153770:	e0bffd17 	ldw	r2,-12(fp)
  153774:	10c00917 	ldw	r3,36(r2)
  153778:	e0bffd17 	ldw	r2,-12(fp)
  15377c:	10800117 	ldw	r2,4(r2)
  153780:	1885803a 	cmpltu	r2,r3,r2
  153784:	10c03fcc 	andi	r3,r2,255
  153788:	e0bfff17 	ldw	r2,-4(fp)
  15378c:	10c00015 	stw	r3,0(r2)
      rc = 0;
  153790:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  153794:	00000306 	br	1537a4 <altera_avalon_jtag_uart_ioctl+0xdc>

  default:
    break;
  153798:	00000306 	br	1537a8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
  15379c:	0001883a 	nop
  1537a0:	00000106 	br	1537a8 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
  1537a4:	0001883a 	nop

  default:
    break;
  }

  return rc;
  1537a8:	e0bffb17 	ldw	r2,-20(fp)
}
  1537ac:	e037883a 	mov	sp,fp
  1537b0:	df000017 	ldw	fp,0(sp)
  1537b4:	dec00104 	addi	sp,sp,4
  1537b8:	f800283a 	ret

001537bc <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  1537bc:	defff304 	addi	sp,sp,-52
  1537c0:	dfc00c15 	stw	ra,48(sp)
  1537c4:	df000b15 	stw	fp,44(sp)
  1537c8:	df000b04 	addi	fp,sp,44
  1537cc:	e13ffc15 	stw	r4,-16(fp)
  1537d0:	e17ffd15 	stw	r5,-12(fp)
  1537d4:	e1bffe15 	stw	r6,-8(fp)
  1537d8:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
  1537dc:	e0bffd17 	ldw	r2,-12(fp)
  1537e0:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  1537e4:	00004706 	br	153904 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  1537e8:	e0bffc17 	ldw	r2,-16(fp)
  1537ec:	10800a17 	ldw	r2,40(r2)
  1537f0:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
  1537f4:	e0bffc17 	ldw	r2,-16(fp)
  1537f8:	10800b17 	ldw	r2,44(r2)
  1537fc:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
  153800:	e0fff717 	ldw	r3,-36(fp)
  153804:	e0bff817 	ldw	r2,-32(fp)
  153808:	18800536 	bltu	r3,r2,153820 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  15380c:	e0fff717 	ldw	r3,-36(fp)
  153810:	e0bff817 	ldw	r2,-32(fp)
  153814:	1885c83a 	sub	r2,r3,r2
  153818:	e0bff615 	stw	r2,-40(fp)
  15381c:	00000406 	br	153830 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  153820:	00c20004 	movi	r3,2048
  153824:	e0bff817 	ldw	r2,-32(fp)
  153828:	1885c83a 	sub	r2,r3,r2
  15382c:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  153830:	e0bff617 	ldw	r2,-40(fp)
  153834:	10001e26 	beq	r2,zero,1538b0 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
  153838:	e0fffe17 	ldw	r3,-8(fp)
  15383c:	e0bff617 	ldw	r2,-40(fp)
  153840:	1880022e 	bgeu	r3,r2,15384c <altera_avalon_jtag_uart_read+0x90>
        n = space;
  153844:	e0bffe17 	ldw	r2,-8(fp)
  153848:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  15384c:	e0bff817 	ldw	r2,-32(fp)
  153850:	10800e04 	addi	r2,r2,56
  153854:	e0fffc17 	ldw	r3,-16(fp)
  153858:	1885883a 	add	r2,r3,r2
  15385c:	e13ff517 	ldw	r4,-44(fp)
  153860:	100b883a 	mov	r5,r2
  153864:	e1bff617 	ldw	r6,-40(fp)
  153868:	0154a080 	call	154a08 <memcpy>
      ptr   += n;
  15386c:	e0fff517 	ldw	r3,-44(fp)
  153870:	e0bff617 	ldw	r2,-40(fp)
  153874:	1885883a 	add	r2,r3,r2
  153878:	e0bff515 	stw	r2,-44(fp)
      space -= n;
  15387c:	e0fffe17 	ldw	r3,-8(fp)
  153880:	e0bff617 	ldw	r2,-40(fp)
  153884:	1885c83a 	sub	r2,r3,r2
  153888:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  15388c:	e0fff817 	ldw	r3,-32(fp)
  153890:	e0bff617 	ldw	r2,-40(fp)
  153894:	1885883a 	add	r2,r3,r2
  153898:	10c1ffcc 	andi	r3,r2,2047
  15389c:	e0bffc17 	ldw	r2,-16(fp)
  1538a0:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  1538a4:	e0bffe17 	ldw	r2,-8(fp)
  1538a8:	00bfcf16 	blt	zero,r2,1537e8 <altera_avalon_jtag_uart_read+0x2c>
  1538ac:	00000106 	br	1538b4 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
  1538b0:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
  1538b4:	e0fff517 	ldw	r3,-44(fp)
  1538b8:	e0bffd17 	ldw	r2,-12(fp)
  1538bc:	1880141e 	bne	r3,r2,153910 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  1538c0:	e0bfff17 	ldw	r2,-4(fp)
  1538c4:	1090000c 	andi	r2,r2,16384
  1538c8:	1000131e 	bne	r2,zero,153918 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  1538cc:	0001883a 	nop
  1538d0:	e0bffc17 	ldw	r2,-16(fp)
  1538d4:	10c00a17 	ldw	r3,40(r2)
  1538d8:	e0bff717 	ldw	r2,-36(fp)
  1538dc:	1880051e 	bne	r3,r2,1538f4 <altera_avalon_jtag_uart_read+0x138>
  1538e0:	e0bffc17 	ldw	r2,-16(fp)
  1538e4:	10c00917 	ldw	r3,36(r2)
  1538e8:	e0bffc17 	ldw	r2,-16(fp)
  1538ec:	10800117 	ldw	r2,4(r2)
  1538f0:	18bff736 	bltu	r3,r2,1538d0 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  1538f4:	e0bffc17 	ldw	r2,-16(fp)
  1538f8:	10c00a17 	ldw	r3,40(r2)
  1538fc:	e0bff717 	ldw	r2,-36(fp)
  153900:	18800726 	beq	r3,r2,153920 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  153904:	e0bffe17 	ldw	r2,-8(fp)
  153908:	00bfb716 	blt	zero,r2,1537e8 <altera_avalon_jtag_uart_read+0x2c>
  15390c:	00000506 	br	153924 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
  153910:	0001883a 	nop
  153914:	00000306 	br	153924 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
  153918:	0001883a 	nop
  15391c:	00000106 	br	153924 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
  153920:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  153924:	e0fff517 	ldw	r3,-44(fp)
  153928:	e0bffd17 	ldw	r2,-12(fp)
  15392c:	18801726 	beq	r3,r2,15398c <altera_avalon_jtag_uart_read+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  153930:	0005303a 	rdctl	r2,status
  153934:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  153938:	e0fffa17 	ldw	r3,-24(fp)
  15393c:	00bfff84 	movi	r2,-2
  153940:	1884703a 	and	r2,r3,r2
  153944:	1001703a 	wrctl	status,r2
  
  return context;
  153948:	e0bffa17 	ldw	r2,-24(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  15394c:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  153950:	e0bffc17 	ldw	r2,-16(fp)
  153954:	10800817 	ldw	r2,32(r2)
  153958:	10c00054 	ori	r3,r2,1
  15395c:	e0bffc17 	ldw	r2,-16(fp)
  153960:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  153964:	e0bffc17 	ldw	r2,-16(fp)
  153968:	10800017 	ldw	r2,0(r2)
  15396c:	10800104 	addi	r2,r2,4
  153970:	e0fffc17 	ldw	r3,-16(fp)
  153974:	18c00817 	ldw	r3,32(r3)
  153978:	10c00035 	stwio	r3,0(r2)
  15397c:	e0bff917 	ldw	r2,-28(fp)
  153980:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  153984:	e0bffb17 	ldw	r2,-20(fp)
  153988:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  15398c:	e0fff517 	ldw	r3,-44(fp)
  153990:	e0bffd17 	ldw	r2,-12(fp)
  153994:	18800426 	beq	r3,r2,1539a8 <altera_avalon_jtag_uart_read+0x1ec>
    return ptr - buffer;
  153998:	e0fff517 	ldw	r3,-44(fp)
  15399c:	e0bffd17 	ldw	r2,-12(fp)
  1539a0:	1885c83a 	sub	r2,r3,r2
  1539a4:	00000606 	br	1539c0 <altera_avalon_jtag_uart_read+0x204>
  else if (flags & O_NONBLOCK)
  1539a8:	e0bfff17 	ldw	r2,-4(fp)
  1539ac:	1090000c 	andi	r2,r2,16384
  1539b0:	10000226 	beq	r2,zero,1539bc <altera_avalon_jtag_uart_read+0x200>
    return -EWOULDBLOCK;
  1539b4:	00bffd44 	movi	r2,-11
  1539b8:	00000106 	br	1539c0 <altera_avalon_jtag_uart_read+0x204>
  else
    return -EIO;
  1539bc:	00bffec4 	movi	r2,-5
}
  1539c0:	e037883a 	mov	sp,fp
  1539c4:	dfc00117 	ldw	ra,4(sp)
  1539c8:	df000017 	ldw	fp,0(sp)
  1539cc:	dec00204 	addi	sp,sp,8
  1539d0:	f800283a 	ret

001539d4 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  1539d4:	defff304 	addi	sp,sp,-52
  1539d8:	dfc00c15 	stw	ra,48(sp)
  1539dc:	df000b15 	stw	fp,44(sp)
  1539e0:	df000b04 	addi	fp,sp,44
  1539e4:	e13ffc15 	stw	r4,-16(fp)
  1539e8:	e17ffd15 	stw	r5,-12(fp)
  1539ec:	e1bffe15 	stw	r6,-8(fp)
  1539f0:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  1539f4:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  1539f8:	e0bffd17 	ldw	r2,-12(fp)
  1539fc:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  153a00:	00003706 	br	153ae0 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  153a04:	e0bffc17 	ldw	r2,-16(fp)
  153a08:	10800c17 	ldw	r2,48(r2)
  153a0c:	e0bff815 	stw	r2,-32(fp)
      out = sp->tx_out;
  153a10:	e0bffc17 	ldw	r2,-16(fp)
  153a14:	10800d17 	ldw	r2,52(r2)
  153a18:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
  153a1c:	e0fff817 	ldw	r3,-32(fp)
  153a20:	e0bff517 	ldw	r2,-44(fp)
  153a24:	1880062e 	bgeu	r3,r2,153a40 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  153a28:	e0fff517 	ldw	r3,-44(fp)
  153a2c:	e0bff817 	ldw	r2,-32(fp)
  153a30:	1885c83a 	sub	r2,r3,r2
  153a34:	10bfffc4 	addi	r2,r2,-1
  153a38:	e0bff615 	stw	r2,-40(fp)
  153a3c:	00000b06 	br	153a6c <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
  153a40:	e0bff517 	ldw	r2,-44(fp)
  153a44:	10000526 	beq	r2,zero,153a5c <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  153a48:	00c20004 	movi	r3,2048
  153a4c:	e0bff817 	ldw	r2,-32(fp)
  153a50:	1885c83a 	sub	r2,r3,r2
  153a54:	e0bff615 	stw	r2,-40(fp)
  153a58:	00000406 	br	153a6c <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  153a5c:	00c1ffc4 	movi	r3,2047
  153a60:	e0bff817 	ldw	r2,-32(fp)
  153a64:	1885c83a 	sub	r2,r3,r2
  153a68:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  153a6c:	e0bff617 	ldw	r2,-40(fp)
  153a70:	10001e26 	beq	r2,zero,153aec <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
  153a74:	e0fffe17 	ldw	r3,-8(fp)
  153a78:	e0bff617 	ldw	r2,-40(fp)
  153a7c:	1880022e 	bgeu	r3,r2,153a88 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
  153a80:	e0bffe17 	ldw	r2,-8(fp)
  153a84:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  153a88:	e0bff817 	ldw	r2,-32(fp)
  153a8c:	10820e04 	addi	r2,r2,2104
  153a90:	e0fffc17 	ldw	r3,-16(fp)
  153a94:	1885883a 	add	r2,r3,r2
  153a98:	1009883a 	mov	r4,r2
  153a9c:	e17ffd17 	ldw	r5,-12(fp)
  153aa0:	e1bff617 	ldw	r6,-40(fp)
  153aa4:	0154a080 	call	154a08 <memcpy>
      ptr   += n;
  153aa8:	e0fffd17 	ldw	r3,-12(fp)
  153aac:	e0bff617 	ldw	r2,-40(fp)
  153ab0:	1885883a 	add	r2,r3,r2
  153ab4:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
  153ab8:	e0fffe17 	ldw	r3,-8(fp)
  153abc:	e0bff617 	ldw	r2,-40(fp)
  153ac0:	1885c83a 	sub	r2,r3,r2
  153ac4:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  153ac8:	e0fff817 	ldw	r3,-32(fp)
  153acc:	e0bff617 	ldw	r2,-40(fp)
  153ad0:	1885883a 	add	r2,r3,r2
  153ad4:	10c1ffcc 	andi	r3,r2,2047
  153ad8:	e0bffc17 	ldw	r2,-16(fp)
  153adc:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  153ae0:	e0bffe17 	ldw	r2,-8(fp)
  153ae4:	00bfc716 	blt	zero,r2,153a04 <altera_avalon_jtag_uart_write+0x30>
  153ae8:	00000106 	br	153af0 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
  153aec:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  153af0:	0005303a 	rdctl	r2,status
  153af4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  153af8:	e0fffa17 	ldw	r3,-24(fp)
  153afc:	00bfff84 	movi	r2,-2
  153b00:	1884703a 	and	r2,r3,r2
  153b04:	1001703a 	wrctl	status,r2
  
  return context;
  153b08:	e0bffa17 	ldw	r2,-24(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  153b0c:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  153b10:	e0bffc17 	ldw	r2,-16(fp)
  153b14:	10800817 	ldw	r2,32(r2)
  153b18:	10c00094 	ori	r3,r2,2
  153b1c:	e0bffc17 	ldw	r2,-16(fp)
  153b20:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  153b24:	e0bffc17 	ldw	r2,-16(fp)
  153b28:	10800017 	ldw	r2,0(r2)
  153b2c:	10800104 	addi	r2,r2,4
  153b30:	e0fffc17 	ldw	r3,-16(fp)
  153b34:	18c00817 	ldw	r3,32(r3)
  153b38:	10c00035 	stwio	r3,0(r2)
  153b3c:	e0bff917 	ldw	r2,-28(fp)
  153b40:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  153b44:	e0bffb17 	ldw	r2,-20(fp)
  153b48:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  153b4c:	e0bffe17 	ldw	r2,-8(fp)
  153b50:	0080110e 	bge	zero,r2,153b98 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
  153b54:	e0bfff17 	ldw	r2,-4(fp)
  153b58:	1090000c 	andi	r2,r2,16384
  153b5c:	1000111e 	bne	r2,zero,153ba4 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  153b60:	0001883a 	nop
  153b64:	e0bffc17 	ldw	r2,-16(fp)
  153b68:	10c00d17 	ldw	r3,52(r2)
  153b6c:	e0bff517 	ldw	r2,-44(fp)
  153b70:	1880051e 	bne	r3,r2,153b88 <altera_avalon_jtag_uart_write+0x1b4>
  153b74:	e0bffc17 	ldw	r2,-16(fp)
  153b78:	10c00917 	ldw	r3,36(r2)
  153b7c:	e0bffc17 	ldw	r2,-16(fp)
  153b80:	10800117 	ldw	r2,4(r2)
  153b84:	18bff736 	bltu	r3,r2,153b64 <altera_avalon_jtag_uart_write+0x190>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
  153b88:	e0bffc17 	ldw	r2,-16(fp)
  153b8c:	10c00d17 	ldw	r3,52(r2)
  153b90:	e0bff517 	ldw	r2,-44(fp)
  153b94:	18800526 	beq	r3,r2,153bac <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
  153b98:	e0bffe17 	ldw	r2,-8(fp)
  153b9c:	00bfd016 	blt	zero,r2,153ae0 <altera_avalon_jtag_uart_write+0x10c>
  153ba0:	00000306 	br	153bb0 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
  153ba4:	0001883a 	nop
  153ba8:	00000106 	br	153bb0 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
         break;
  153bac:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  153bb0:	e0fffd17 	ldw	r3,-12(fp)
  153bb4:	e0bff717 	ldw	r2,-36(fp)
  153bb8:	18800426 	beq	r3,r2,153bcc <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
  153bbc:	e0fffd17 	ldw	r3,-12(fp)
  153bc0:	e0bff717 	ldw	r2,-36(fp)
  153bc4:	1885c83a 	sub	r2,r3,r2
  153bc8:	00000606 	br	153be4 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
  153bcc:	e0bfff17 	ldw	r2,-4(fp)
  153bd0:	1090000c 	andi	r2,r2,16384
  153bd4:	10000226 	beq	r2,zero,153be0 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
  153bd8:	00bffd44 	movi	r2,-11
  153bdc:	00000106 	br	153be4 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  153be0:	00bffec4 	movi	r2,-5
}
  153be4:	e037883a 	mov	sp,fp
  153be8:	dfc00117 	ldw	ra,4(sp)
  153bec:	df000017 	ldw	fp,0(sp)
  153bf0:	dec00204 	addi	sp,sp,8
  153bf4:	f800283a 	ret

00153bf8 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  153bf8:	defff504 	addi	sp,sp,-44
  153bfc:	df000a15 	stw	fp,40(sp)
  153c00:	df000a04 	addi	fp,sp,40
  153c04:	e13ffc15 	stw	r4,-16(fp)
  153c08:	e17ffd15 	stw	r5,-12(fp)
  153c0c:	e1bffe15 	stw	r6,-8(fp)
  153c10:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  153c14:	e03ff615 	stw	zero,-40(fp)
  153c18:	008005b4 	movhi	r2,22
  153c1c:	10a10604 	addi	r2,r2,-31720
  153c20:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
  153c24:	10003f26 	beq	r2,zero,153d24 <alt_alarm_start+0x12c>
  {
    if (alarm)
  153c28:	e0bffc17 	ldw	r2,-16(fp)
  153c2c:	10003b26 	beq	r2,zero,153d1c <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
  153c30:	e0bffc17 	ldw	r2,-16(fp)
  153c34:	e0fffe17 	ldw	r3,-8(fp)
  153c38:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  153c3c:	e0bffc17 	ldw	r2,-16(fp)
  153c40:	e0ffff17 	ldw	r3,-4(fp)
  153c44:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  153c48:	0005303a 	rdctl	r2,status
  153c4c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  153c50:	e0fff817 	ldw	r3,-32(fp)
  153c54:	00bfff84 	movi	r2,-2
  153c58:	1884703a 	and	r2,r3,r2
  153c5c:	1001703a 	wrctl	status,r2
  
  return context;
  153c60:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
  153c64:	e0bff715 	stw	r2,-36(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  153c68:	008005b4 	movhi	r2,22
  153c6c:	10a10704 	addi	r2,r2,-31716
  153c70:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
  153c74:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  153c78:	e0fffd17 	ldw	r3,-12(fp)
  153c7c:	e0bff617 	ldw	r2,-40(fp)
  153c80:	1885883a 	add	r2,r3,r2
  153c84:	10c00044 	addi	r3,r2,1
  153c88:	e0bffc17 	ldw	r2,-16(fp)
  153c8c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  153c90:	e0bffc17 	ldw	r2,-16(fp)
  153c94:	10c00217 	ldw	r3,8(r2)
  153c98:	e0bff617 	ldw	r2,-40(fp)
  153c9c:	1880042e 	bgeu	r3,r2,153cb0 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
  153ca0:	e0bffc17 	ldw	r2,-16(fp)
  153ca4:	00c00044 	movi	r3,1
  153ca8:	10c00405 	stb	r3,16(r2)
  153cac:	00000206 	br	153cb8 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
  153cb0:	e0bffc17 	ldw	r2,-16(fp)
  153cb4:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  153cb8:	e0bffc17 	ldw	r2,-16(fp)
  153cbc:	00c00574 	movhi	r3,21
  153cc0:	18db5e04 	addi	r3,r3,28024
  153cc4:	e0fff915 	stw	r3,-28(fp)
  153cc8:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  153ccc:	e0bffa17 	ldw	r2,-24(fp)
  153cd0:	e0fff917 	ldw	r3,-28(fp)
  153cd4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  153cd8:	e0bff917 	ldw	r2,-28(fp)
  153cdc:	10c00017 	ldw	r3,0(r2)
  153ce0:	e0bffa17 	ldw	r2,-24(fp)
  153ce4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  153ce8:	e0bff917 	ldw	r2,-28(fp)
  153cec:	10800017 	ldw	r2,0(r2)
  153cf0:	e0fffa17 	ldw	r3,-24(fp)
  153cf4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  153cf8:	e0bff917 	ldw	r2,-28(fp)
  153cfc:	e0fffa17 	ldw	r3,-24(fp)
  153d00:	10c00015 	stw	r3,0(r2)
  153d04:	e0bff717 	ldw	r2,-36(fp)
  153d08:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  153d0c:	e0bffb17 	ldw	r2,-20(fp)
  153d10:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  153d14:	0005883a 	mov	r2,zero
  153d18:	00000306 	br	153d28 <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
  153d1c:	00bffa84 	movi	r2,-22
  153d20:	00000106 	br	153d28 <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
  153d24:	00bfde84 	movi	r2,-134
  }
}
  153d28:	e037883a 	mov	sp,fp
  153d2c:	df000017 	ldw	fp,0(sp)
  153d30:	dec00104 	addi	sp,sp,4
  153d34:	f800283a 	ret

00153d38 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  153d38:	defffe04 	addi	sp,sp,-8
  153d3c:	dfc00115 	stw	ra,4(sp)
  153d40:	df000015 	stw	fp,0(sp)
  153d44:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  153d48:	00800574 	movhi	r2,21
  153d4c:	109b5d04 	addi	r2,r2,28020
  153d50:	10800017 	ldw	r2,0(r2)
  153d54:	10000526 	beq	r2,zero,153d6c <alt_get_errno+0x34>
  153d58:	00800574 	movhi	r2,21
  153d5c:	109b5d04 	addi	r2,r2,28020
  153d60:	10800017 	ldw	r2,0(r2)
  153d64:	103ee83a 	callr	r2
  153d68:	00000206 	br	153d74 <alt_get_errno+0x3c>
  153d6c:	008005b4 	movhi	r2,22
  153d70:	10a10804 	addi	r2,r2,-31712
}
  153d74:	e037883a 	mov	sp,fp
  153d78:	dfc00117 	ldw	ra,4(sp)
  153d7c:	df000017 	ldw	fp,0(sp)
  153d80:	dec00204 	addi	sp,sp,8
  153d84:	f800283a 	ret

00153d88 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  153d88:	defffb04 	addi	sp,sp,-20
  153d8c:	dfc00415 	stw	ra,16(sp)
  153d90:	df000315 	stw	fp,12(sp)
  153d94:	df000304 	addi	fp,sp,12
  153d98:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  153d9c:	e0bfff17 	ldw	r2,-4(fp)
  153da0:	10000616 	blt	r2,zero,153dbc <close+0x34>
  153da4:	e0bfff17 	ldw	r2,-4(fp)
  153da8:	10c00324 	muli	r3,r2,12
  153dac:	00800574 	movhi	r2,21
  153db0:	1099f504 	addi	r2,r2,26580
  153db4:	1885883a 	add	r2,r3,r2
  153db8:	00000106 	br	153dc0 <close+0x38>
  153dbc:	0005883a 	mov	r2,zero
  153dc0:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  153dc4:	e0bffd17 	ldw	r2,-12(fp)
  153dc8:	10001826 	beq	r2,zero,153e2c <close+0xa4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  153dcc:	e0bffd17 	ldw	r2,-12(fp)
  153dd0:	10800017 	ldw	r2,0(r2)
  153dd4:	10800417 	ldw	r2,16(r2)
  153dd8:	10000626 	beq	r2,zero,153df4 <close+0x6c>
  153ddc:	e0bffd17 	ldw	r2,-12(fp)
  153de0:	10800017 	ldw	r2,0(r2)
  153de4:	10800417 	ldw	r2,16(r2)
  153de8:	e13ffd17 	ldw	r4,-12(fp)
  153dec:	103ee83a 	callr	r2
  153df0:	00000106 	br	153df8 <close+0x70>
  153df4:	0005883a 	mov	r2,zero
  153df8:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  153dfc:	e13fff17 	ldw	r4,-4(fp)
  153e00:	01544400 	call	154440 <alt_release_fd>
    if (rval < 0)
  153e04:	e0bffe17 	ldw	r2,-8(fp)
  153e08:	1000060e 	bge	r2,zero,153e24 <close+0x9c>
    {
      ALT_ERRNO = -rval;
  153e0c:	0153d380 	call	153d38 <alt_get_errno>
  153e10:	e0fffe17 	ldw	r3,-8(fp)
  153e14:	00c7c83a 	sub	r3,zero,r3
  153e18:	10c00015 	stw	r3,0(r2)
      return -1;
  153e1c:	00bfffc4 	movi	r2,-1
  153e20:	00000606 	br	153e3c <close+0xb4>
    }
    return 0;
  153e24:	0005883a 	mov	r2,zero
  153e28:	00000406 	br	153e3c <close+0xb4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  153e2c:	0153d380 	call	153d38 <alt_get_errno>
  153e30:	00c01444 	movi	r3,81
  153e34:	10c00015 	stw	r3,0(r2)
    return -1;
  153e38:	00bfffc4 	movi	r2,-1
  }
}
  153e3c:	e037883a 	mov	sp,fp
  153e40:	dfc00117 	ldw	ra,4(sp)
  153e44:	df000017 	ldw	fp,0(sp)
  153e48:	dec00204 	addi	sp,sp,8
  153e4c:	f800283a 	ret

00153e50 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  153e50:	defffe04 	addi	sp,sp,-8
  153e54:	df000115 	stw	fp,4(sp)
  153e58:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  153e5c:	e03fff15 	stw	zero,-4(fp)
  153e60:	00000506 	br	153e78 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  153e64:	e0bfff17 	ldw	r2,-4(fp)
  153e68:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  153e6c:	e0bfff17 	ldw	r2,-4(fp)
  153e70:	10800804 	addi	r2,r2,32
  153e74:	e0bfff15 	stw	r2,-4(fp)
  153e78:	e0bfff17 	ldw	r2,-4(fp)
  153e7c:	10820030 	cmpltui	r2,r2,2048
  153e80:	103ff81e 	bne	r2,zero,153e64 <alt_dcache_flush_all+0x14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  153e84:	e037883a 	mov	sp,fp
  153e88:	df000017 	ldw	fp,0(sp)
  153e8c:	dec00104 	addi	sp,sp,4
  153e90:	f800283a 	ret

00153e94 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  153e94:	defffc04 	addi	sp,sp,-16
  153e98:	df000315 	stw	fp,12(sp)
  153e9c:	df000304 	addi	fp,sp,12
  153ea0:	e13ffd15 	stw	r4,-12(fp)
  153ea4:	e17ffe15 	stw	r5,-8(fp)
  153ea8:	e1bfff15 	stw	r6,-4(fp)
  return len;
  153eac:	e0bfff17 	ldw	r2,-4(fp)
}
  153eb0:	e037883a 	mov	sp,fp
  153eb4:	df000017 	ldw	fp,0(sp)
  153eb8:	dec00104 	addi	sp,sp,4
  153ebc:	f800283a 	ret

00153ec0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  153ec0:	defffe04 	addi	sp,sp,-8
  153ec4:	dfc00115 	stw	ra,4(sp)
  153ec8:	df000015 	stw	fp,0(sp)
  153ecc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  153ed0:	00800574 	movhi	r2,21
  153ed4:	109b5d04 	addi	r2,r2,28020
  153ed8:	10800017 	ldw	r2,0(r2)
  153edc:	10000526 	beq	r2,zero,153ef4 <alt_get_errno+0x34>
  153ee0:	00800574 	movhi	r2,21
  153ee4:	109b5d04 	addi	r2,r2,28020
  153ee8:	10800017 	ldw	r2,0(r2)
  153eec:	103ee83a 	callr	r2
  153ef0:	00000206 	br	153efc <alt_get_errno+0x3c>
  153ef4:	008005b4 	movhi	r2,22
  153ef8:	10a10804 	addi	r2,r2,-31712
}
  153efc:	e037883a 	mov	sp,fp
  153f00:	dfc00117 	ldw	ra,4(sp)
  153f04:	df000017 	ldw	fp,0(sp)
  153f08:	dec00204 	addi	sp,sp,8
  153f0c:	f800283a 	ret

00153f10 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  153f10:	defffa04 	addi	sp,sp,-24
  153f14:	dfc00515 	stw	ra,20(sp)
  153f18:	df000415 	stw	fp,16(sp)
  153f1c:	df000404 	addi	fp,sp,16
  153f20:	e13ffe15 	stw	r4,-8(fp)
  153f24:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  153f28:	e0bffe17 	ldw	r2,-8(fp)
  153f2c:	10000326 	beq	r2,zero,153f3c <alt_dev_llist_insert+0x2c>
  153f30:	e0bffe17 	ldw	r2,-8(fp)
  153f34:	10800217 	ldw	r2,8(r2)
  153f38:	1000051e 	bne	r2,zero,153f50 <alt_dev_llist_insert+0x40>
  {
    ALT_ERRNO = EINVAL;
  153f3c:	0153ec00 	call	153ec0 <alt_get_errno>
  153f40:	00c00584 	movi	r3,22
  153f44:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
  153f48:	00bffa84 	movi	r2,-22
  153f4c:	00001306 	br	153f9c <alt_dev_llist_insert+0x8c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  153f50:	e0bffe17 	ldw	r2,-8(fp)
  153f54:	e0ffff17 	ldw	r3,-4(fp)
  153f58:	e0fffc15 	stw	r3,-16(fp)
  153f5c:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  153f60:	e0bffd17 	ldw	r2,-12(fp)
  153f64:	e0fffc17 	ldw	r3,-16(fp)
  153f68:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  153f6c:	e0bffc17 	ldw	r2,-16(fp)
  153f70:	10c00017 	ldw	r3,0(r2)
  153f74:	e0bffd17 	ldw	r2,-12(fp)
  153f78:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  153f7c:	e0bffc17 	ldw	r2,-16(fp)
  153f80:	10800017 	ldw	r2,0(r2)
  153f84:	e0fffd17 	ldw	r3,-12(fp)
  153f88:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  153f8c:	e0bffc17 	ldw	r2,-16(fp)
  153f90:	e0fffd17 	ldw	r3,-12(fp)
  153f94:	10c00015 	stw	r3,0(r2)

  return 0;  
  153f98:	0005883a 	mov	r2,zero
}
  153f9c:	e037883a 	mov	sp,fp
  153fa0:	dfc00117 	ldw	ra,4(sp)
  153fa4:	df000017 	ldw	fp,0(sp)
  153fa8:	dec00204 	addi	sp,sp,8
  153fac:	f800283a 	ret

00153fb0 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  153fb0:	defffd04 	addi	sp,sp,-12
  153fb4:	dfc00215 	stw	ra,8(sp)
  153fb8:	df000115 	stw	fp,4(sp)
  153fbc:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  153fc0:	00800574 	movhi	r2,21
  153fc4:	1093a504 	addi	r2,r2,20116
  153fc8:	e0bfff15 	stw	r2,-4(fp)
  153fcc:	00000606 	br	153fe8 <_do_ctors+0x38>
        (*ctor) (); 
  153fd0:	e0bfff17 	ldw	r2,-4(fp)
  153fd4:	10800017 	ldw	r2,0(r2)
  153fd8:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  153fdc:	e0bfff17 	ldw	r2,-4(fp)
  153fe0:	10bfff04 	addi	r2,r2,-4
  153fe4:	e0bfff15 	stw	r2,-4(fp)
  153fe8:	e0ffff17 	ldw	r3,-4(fp)
  153fec:	00800574 	movhi	r2,21
  153ff0:	1093a604 	addi	r2,r2,20120
  153ff4:	18bff62e 	bgeu	r3,r2,153fd0 <_do_ctors+0x20>
        (*ctor) (); 
}
  153ff8:	e037883a 	mov	sp,fp
  153ffc:	dfc00117 	ldw	ra,4(sp)
  154000:	df000017 	ldw	fp,0(sp)
  154004:	dec00204 	addi	sp,sp,8
  154008:	f800283a 	ret

0015400c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  15400c:	defffd04 	addi	sp,sp,-12
  154010:	dfc00215 	stw	ra,8(sp)
  154014:	df000115 	stw	fp,4(sp)
  154018:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  15401c:	00800574 	movhi	r2,21
  154020:	1093a504 	addi	r2,r2,20116
  154024:	e0bfff15 	stw	r2,-4(fp)
  154028:	00000606 	br	154044 <_do_dtors+0x38>
        (*dtor) (); 
  15402c:	e0bfff17 	ldw	r2,-4(fp)
  154030:	10800017 	ldw	r2,0(r2)
  154034:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  154038:	e0bfff17 	ldw	r2,-4(fp)
  15403c:	10bfff04 	addi	r2,r2,-4
  154040:	e0bfff15 	stw	r2,-4(fp)
  154044:	e0ffff17 	ldw	r3,-4(fp)
  154048:	00800574 	movhi	r2,21
  15404c:	1093a604 	addi	r2,r2,20120
  154050:	18bff62e 	bgeu	r3,r2,15402c <_do_dtors+0x20>
        (*dtor) (); 
}
  154054:	e037883a 	mov	sp,fp
  154058:	dfc00117 	ldw	ra,4(sp)
  15405c:	df000017 	ldw	fp,0(sp)
  154060:	dec00204 	addi	sp,sp,8
  154064:	f800283a 	ret

00154068 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  154068:	defffe04 	addi	sp,sp,-8
  15406c:	dfc00115 	stw	ra,4(sp)
  154070:	df000015 	stw	fp,0(sp)
  154074:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
  154078:	0009883a 	mov	r4,zero
  15407c:	01440004 	movi	r5,4096
  154080:	01548b40 	call	1548b4 <alt_icache_flush>
#endif
}
  154084:	e037883a 	mov	sp,fp
  154088:	dfc00117 	ldw	ra,4(sp)
  15408c:	df000017 	ldw	fp,0(sp)
  154090:	dec00204 	addi	sp,sp,8
  154094:	f800283a 	ret

00154098 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  154098:	defff904 	addi	sp,sp,-28
  15409c:	dfc00615 	stw	ra,24(sp)
  1540a0:	df000515 	stw	fp,20(sp)
  1540a4:	df000504 	addi	fp,sp,20
  1540a8:	e13ffc15 	stw	r4,-16(fp)
  1540ac:	e17ffd15 	stw	r5,-12(fp)
  1540b0:	e1bffe15 	stw	r6,-8(fp)
  1540b4:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
  1540b8:	e13ffd17 	ldw	r4,-12(fp)
  1540bc:	e17ffe17 	ldw	r5,-8(fp)
  1540c0:	e1bfff17 	ldw	r6,-4(fp)
  1540c4:	01542ec0 	call	1542ec <open>
  1540c8:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
  1540cc:	e0bffb17 	ldw	r2,-20(fp)
  1540d0:	10001c16 	blt	r2,zero,154144 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
  1540d4:	00c00574 	movhi	r3,21
  1540d8:	18d9f504 	addi	r3,r3,26580
  1540dc:	e0bffb17 	ldw	r2,-20(fp)
  1540e0:	10800324 	muli	r2,r2,12
  1540e4:	1885883a 	add	r2,r3,r2
  1540e8:	10c00017 	ldw	r3,0(r2)
  1540ec:	e0bffc17 	ldw	r2,-16(fp)
  1540f0:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  1540f4:	00c00574 	movhi	r3,21
  1540f8:	18d9f504 	addi	r3,r3,26580
  1540fc:	e0bffb17 	ldw	r2,-20(fp)
  154100:	10800324 	muli	r2,r2,12
  154104:	1885883a 	add	r2,r3,r2
  154108:	10800104 	addi	r2,r2,4
  15410c:	10c00017 	ldw	r3,0(r2)
  154110:	e0bffc17 	ldw	r2,-16(fp)
  154114:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  154118:	00c00574 	movhi	r3,21
  15411c:	18d9f504 	addi	r3,r3,26580
  154120:	e0bffb17 	ldw	r2,-20(fp)
  154124:	10800324 	muli	r2,r2,12
  154128:	1885883a 	add	r2,r3,r2
  15412c:	10800204 	addi	r2,r2,8
  154130:	10c00017 	ldw	r3,0(r2)
  154134:	e0bffc17 	ldw	r2,-16(fp)
  154138:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  15413c:	e13ffb17 	ldw	r4,-20(fp)
  154140:	01544400 	call	154440 <alt_release_fd>
  }
} 
  154144:	e037883a 	mov	sp,fp
  154148:	dfc00117 	ldw	ra,4(sp)
  15414c:	df000017 	ldw	fp,0(sp)
  154150:	dec00204 	addi	sp,sp,8
  154154:	f800283a 	ret

00154158 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  154158:	defffb04 	addi	sp,sp,-20
  15415c:	dfc00415 	stw	ra,16(sp)
  154160:	df000315 	stw	fp,12(sp)
  154164:	df000304 	addi	fp,sp,12
  154168:	e13ffd15 	stw	r4,-12(fp)
  15416c:	e17ffe15 	stw	r5,-8(fp)
  154170:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  154174:	01000574 	movhi	r4,21
  154178:	2119f804 	addi	r4,r4,26592
  15417c:	e17ffd17 	ldw	r5,-12(fp)
  154180:	01800044 	movi	r6,1
  154184:	01c07fc4 	movi	r7,511
  154188:	01540980 	call	154098 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  15418c:	01000574 	movhi	r4,21
  154190:	2119f504 	addi	r4,r4,26580
  154194:	e17ffe17 	ldw	r5,-8(fp)
  154198:	000d883a 	mov	r6,zero
  15419c:	01c07fc4 	movi	r7,511
  1541a0:	01540980 	call	154098 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  1541a4:	01000574 	movhi	r4,21
  1541a8:	2119fb04 	addi	r4,r4,26604
  1541ac:	e17fff17 	ldw	r5,-4(fp)
  1541b0:	01800044 	movi	r6,1
  1541b4:	01c07fc4 	movi	r7,511
  1541b8:	01540980 	call	154098 <alt_open_fd>
}  
  1541bc:	e037883a 	mov	sp,fp
  1541c0:	dfc00117 	ldw	ra,4(sp)
  1541c4:	df000017 	ldw	fp,0(sp)
  1541c8:	dec00204 	addi	sp,sp,8
  1541cc:	f800283a 	ret

001541d0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  1541d0:	defffe04 	addi	sp,sp,-8
  1541d4:	dfc00115 	stw	ra,4(sp)
  1541d8:	df000015 	stw	fp,0(sp)
  1541dc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  1541e0:	00800574 	movhi	r2,21
  1541e4:	109b5d04 	addi	r2,r2,28020
  1541e8:	10800017 	ldw	r2,0(r2)
  1541ec:	10000526 	beq	r2,zero,154204 <alt_get_errno+0x34>
  1541f0:	00800574 	movhi	r2,21
  1541f4:	109b5d04 	addi	r2,r2,28020
  1541f8:	10800017 	ldw	r2,0(r2)
  1541fc:	103ee83a 	callr	r2
  154200:	00000206 	br	15420c <alt_get_errno+0x3c>
  154204:	008005b4 	movhi	r2,22
  154208:	10a10804 	addi	r2,r2,-31712
}
  15420c:	e037883a 	mov	sp,fp
  154210:	dfc00117 	ldw	ra,4(sp)
  154214:	df000017 	ldw	fp,0(sp)
  154218:	dec00204 	addi	sp,sp,8
  15421c:	f800283a 	ret

00154220 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  154220:	defffd04 	addi	sp,sp,-12
  154224:	df000215 	stw	fp,8(sp)
  154228:	df000204 	addi	fp,sp,8
  15422c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  154230:	e0bfff17 	ldw	r2,-4(fp)
  154234:	10800217 	ldw	r2,8(r2)
  154238:	10d00034 	orhi	r3,r2,16384
  15423c:	e0bfff17 	ldw	r2,-4(fp)
  154240:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  154244:	e03ffe15 	stw	zero,-8(fp)
  154248:	00001d06 	br	1542c0 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  15424c:	00c00574 	movhi	r3,21
  154250:	18d9f504 	addi	r3,r3,26580
  154254:	e0bffe17 	ldw	r2,-8(fp)
  154258:	10800324 	muli	r2,r2,12
  15425c:	1885883a 	add	r2,r3,r2
  154260:	10c00017 	ldw	r3,0(r2)
  154264:	e0bfff17 	ldw	r2,-4(fp)
  154268:	10800017 	ldw	r2,0(r2)
  15426c:	1880111e 	bne	r3,r2,1542b4 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  154270:	00c00574 	movhi	r3,21
  154274:	18d9f504 	addi	r3,r3,26580
  154278:	e0bffe17 	ldw	r2,-8(fp)
  15427c:	10800324 	muli	r2,r2,12
  154280:	1885883a 	add	r2,r3,r2
  154284:	10800204 	addi	r2,r2,8
  154288:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  15428c:	1000090e 	bge	r2,zero,1542b4 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  154290:	e0bffe17 	ldw	r2,-8(fp)
  154294:	10c00324 	muli	r3,r2,12
  154298:	00800574 	movhi	r2,21
  15429c:	1099f504 	addi	r2,r2,26580
  1542a0:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  1542a4:	e0bfff17 	ldw	r2,-4(fp)
  1542a8:	18800226 	beq	r3,r2,1542b4 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  1542ac:	00bffcc4 	movi	r2,-13
  1542b0:	00000a06 	br	1542dc <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  1542b4:	e0bffe17 	ldw	r2,-8(fp)
  1542b8:	10800044 	addi	r2,r2,1
  1542bc:	e0bffe15 	stw	r2,-8(fp)
  1542c0:	00800574 	movhi	r2,21
  1542c4:	109b5c04 	addi	r2,r2,28016
  1542c8:	10800017 	ldw	r2,0(r2)
  1542cc:	1007883a 	mov	r3,r2
  1542d0:	e0bffe17 	ldw	r2,-8(fp)
  1542d4:	18bfdd2e 	bgeu	r3,r2,15424c <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  1542d8:	0005883a 	mov	r2,zero
}
  1542dc:	e037883a 	mov	sp,fp
  1542e0:	df000017 	ldw	fp,0(sp)
  1542e4:	dec00104 	addi	sp,sp,4
  1542e8:	f800283a 	ret

001542ec <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  1542ec:	defff604 	addi	sp,sp,-40
  1542f0:	dfc00915 	stw	ra,36(sp)
  1542f4:	df000815 	stw	fp,32(sp)
  1542f8:	df000804 	addi	fp,sp,32
  1542fc:	e13ffd15 	stw	r4,-12(fp)
  154300:	e17ffe15 	stw	r5,-8(fp)
  154304:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  154308:	00bfffc4 	movi	r2,-1
  15430c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  154310:	00bffb44 	movi	r2,-19
  154314:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  154318:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  15431c:	e13ffd17 	ldw	r4,-12(fp)
  154320:	01400574 	movhi	r5,21
  154324:	295b5a04 	addi	r5,r5,28008
  154328:	015465c0 	call	15465c <alt_find_dev>
  15432c:	e0bff815 	stw	r2,-32(fp)
  154330:	e0bff817 	ldw	r2,-32(fp)
  154334:	1000051e 	bne	r2,zero,15434c <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  154338:	e13ffd17 	ldw	r4,-12(fp)
  15433c:	01546ec0 	call	1546ec <alt_find_file>
  154340:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  154344:	00800044 	movi	r2,1
  154348:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  15434c:	e0bff817 	ldw	r2,-32(fp)
  154350:	10002926 	beq	r2,zero,1543f8 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
  154354:	e13ff817 	ldw	r4,-32(fp)
  154358:	01548000 	call	154800 <alt_get_fd>
  15435c:	e0bff915 	stw	r2,-28(fp)
  154360:	e0bff917 	ldw	r2,-28(fp)
  154364:	1000030e 	bge	r2,zero,154374 <open+0x88>
    {
      status = index;
  154368:	e0bff917 	ldw	r2,-28(fp)
  15436c:	e0bffa15 	stw	r2,-24(fp)
  154370:	00002306 	br	154400 <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
  154374:	e0bff917 	ldw	r2,-28(fp)
  154378:	10c00324 	muli	r3,r2,12
  15437c:	00800574 	movhi	r2,21
  154380:	1099f504 	addi	r2,r2,26580
  154384:	1885883a 	add	r2,r3,r2
  154388:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  15438c:	e0fffe17 	ldw	r3,-8(fp)
  154390:	00900034 	movhi	r2,16384
  154394:	10bfffc4 	addi	r2,r2,-1
  154398:	1886703a 	and	r3,r3,r2
  15439c:	e0bffc17 	ldw	r2,-16(fp)
  1543a0:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  1543a4:	e0bffb17 	ldw	r2,-20(fp)
  1543a8:	1000051e 	bne	r2,zero,1543c0 <open+0xd4>
  1543ac:	e13ffc17 	ldw	r4,-16(fp)
  1543b0:	01542200 	call	154220 <alt_file_locked>
  1543b4:	e0bffa15 	stw	r2,-24(fp)
  1543b8:	e0bffa17 	ldw	r2,-24(fp)
  1543bc:	10001016 	blt	r2,zero,154400 <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  1543c0:	e0bff817 	ldw	r2,-32(fp)
  1543c4:	10800317 	ldw	r2,12(r2)
  1543c8:	10000826 	beq	r2,zero,1543ec <open+0x100>
  1543cc:	e0bff817 	ldw	r2,-32(fp)
  1543d0:	10800317 	ldw	r2,12(r2)
  1543d4:	e13ffc17 	ldw	r4,-16(fp)
  1543d8:	e17ffd17 	ldw	r5,-12(fp)
  1543dc:	e1bffe17 	ldw	r6,-8(fp)
  1543e0:	e1ffff17 	ldw	r7,-4(fp)
  1543e4:	103ee83a 	callr	r2
  1543e8:	00000106 	br	1543f0 <open+0x104>
  1543ec:	0005883a 	mov	r2,zero
  1543f0:	e0bffa15 	stw	r2,-24(fp)
  1543f4:	00000206 	br	154400 <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
  1543f8:	00bffb44 	movi	r2,-19
  1543fc:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  154400:	e0bffa17 	ldw	r2,-24(fp)
  154404:	1000080e 	bge	r2,zero,154428 <open+0x13c>
  {
    alt_release_fd (index);  
  154408:	e13ff917 	ldw	r4,-28(fp)
  15440c:	01544400 	call	154440 <alt_release_fd>
    ALT_ERRNO = -status;
  154410:	01541d00 	call	1541d0 <alt_get_errno>
  154414:	e0fffa17 	ldw	r3,-24(fp)
  154418:	00c7c83a 	sub	r3,zero,r3
  15441c:	10c00015 	stw	r3,0(r2)
    return -1;
  154420:	00bfffc4 	movi	r2,-1
  154424:	00000106 	br	15442c <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
  154428:	e0bff917 	ldw	r2,-28(fp)
}
  15442c:	e037883a 	mov	sp,fp
  154430:	dfc00117 	ldw	ra,4(sp)
  154434:	df000017 	ldw	fp,0(sp)
  154438:	dec00204 	addi	sp,sp,8
  15443c:	f800283a 	ret

00154440 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  154440:	defffe04 	addi	sp,sp,-8
  154444:	df000115 	stw	fp,4(sp)
  154448:	df000104 	addi	fp,sp,4
  15444c:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  154450:	e0bfff17 	ldw	r2,-4(fp)
  154454:	108000d0 	cmplti	r2,r2,3
  154458:	10000d1e 	bne	r2,zero,154490 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
  15445c:	00c00574 	movhi	r3,21
  154460:	18d9f504 	addi	r3,r3,26580
  154464:	e0bfff17 	ldw	r2,-4(fp)
  154468:	10800324 	muli	r2,r2,12
  15446c:	1885883a 	add	r2,r3,r2
  154470:	10800204 	addi	r2,r2,8
  154474:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  154478:	00c00574 	movhi	r3,21
  15447c:	18d9f504 	addi	r3,r3,26580
  154480:	e0bfff17 	ldw	r2,-4(fp)
  154484:	10800324 	muli	r2,r2,12
  154488:	1885883a 	add	r2,r3,r2
  15448c:	10000015 	stw	zero,0(r2)
  }
}
  154490:	e037883a 	mov	sp,fp
  154494:	df000017 	ldw	fp,0(sp)
  154498:	dec00104 	addi	sp,sp,4
  15449c:	f800283a 	ret

001544a0 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  1544a0:	defffa04 	addi	sp,sp,-24
  1544a4:	df000515 	stw	fp,20(sp)
  1544a8:	df000504 	addi	fp,sp,20
  1544ac:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1544b0:	0005303a 	rdctl	r2,status
  1544b4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1544b8:	e0fffc17 	ldw	r3,-16(fp)
  1544bc:	00bfff84 	movi	r2,-2
  1544c0:	1884703a 	and	r2,r3,r2
  1544c4:	1001703a 	wrctl	status,r2
  
  return context;
  1544c8:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  1544cc:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  1544d0:	e0bfff17 	ldw	r2,-4(fp)
  1544d4:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  1544d8:	e0bffd17 	ldw	r2,-12(fp)
  1544dc:	10800017 	ldw	r2,0(r2)
  1544e0:	e0fffd17 	ldw	r3,-12(fp)
  1544e4:	18c00117 	ldw	r3,4(r3)
  1544e8:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  1544ec:	e0bffd17 	ldw	r2,-12(fp)
  1544f0:	10800117 	ldw	r2,4(r2)
  1544f4:	e0fffd17 	ldw	r3,-12(fp)
  1544f8:	18c00017 	ldw	r3,0(r3)
  1544fc:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  154500:	e0bffd17 	ldw	r2,-12(fp)
  154504:	e0fffd17 	ldw	r3,-12(fp)
  154508:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  15450c:	e0bffd17 	ldw	r2,-12(fp)
  154510:	e0fffd17 	ldw	r3,-12(fp)
  154514:	10c00015 	stw	r3,0(r2)
  154518:	e0bffb17 	ldw	r2,-20(fp)
  15451c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  154520:	e0bffe17 	ldw	r2,-8(fp)
  154524:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  154528:	e037883a 	mov	sp,fp
  15452c:	df000017 	ldw	fp,0(sp)
  154530:	dec00104 	addi	sp,sp,4
  154534:	f800283a 	ret

00154538 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  154538:	defffb04 	addi	sp,sp,-20
  15453c:	dfc00415 	stw	ra,16(sp)
  154540:	df000315 	stw	fp,12(sp)
  154544:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  154548:	d0a00917 	ldw	r2,-32732(gp)
  15454c:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  154550:	d0a5b217 	ldw	r2,-26936(gp)
  154554:	10800044 	addi	r2,r2,1
  154558:	d0a5b215 	stw	r2,-26936(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  15455c:	00002e06 	br	154618 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  154560:	e0bffd17 	ldw	r2,-12(fp)
  154564:	10800017 	ldw	r2,0(r2)
  154568:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  15456c:	e0bffd17 	ldw	r2,-12(fp)
  154570:	10800403 	ldbu	r2,16(r2)
  154574:	10803fcc 	andi	r2,r2,255
  154578:	10000426 	beq	r2,zero,15458c <alt_tick+0x54>
  15457c:	d0a5b217 	ldw	r2,-26936(gp)
  154580:	1000021e 	bne	r2,zero,15458c <alt_tick+0x54>
    {
      alarm->rollover = 0;
  154584:	e0bffd17 	ldw	r2,-12(fp)
  154588:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  15458c:	e0bffd17 	ldw	r2,-12(fp)
  154590:	10800217 	ldw	r2,8(r2)
  154594:	d0e5b217 	ldw	r3,-26936(gp)
  154598:	18801d36 	bltu	r3,r2,154610 <alt_tick+0xd8>
  15459c:	e0bffd17 	ldw	r2,-12(fp)
  1545a0:	10800403 	ldbu	r2,16(r2)
  1545a4:	10803fcc 	andi	r2,r2,255
  1545a8:	1000191e 	bne	r2,zero,154610 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  1545ac:	e0bffd17 	ldw	r2,-12(fp)
  1545b0:	10c00317 	ldw	r3,12(r2)
  1545b4:	e0bffd17 	ldw	r2,-12(fp)
  1545b8:	10800517 	ldw	r2,20(r2)
  1545bc:	1009883a 	mov	r4,r2
  1545c0:	183ee83a 	callr	r3
  1545c4:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  1545c8:	e0bfff17 	ldw	r2,-4(fp)
  1545cc:	1000031e 	bne	r2,zero,1545dc <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  1545d0:	e13ffd17 	ldw	r4,-12(fp)
  1545d4:	01544a00 	call	1544a0 <alt_alarm_stop>
  1545d8:	00000d06 	br	154610 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  1545dc:	e0bffd17 	ldw	r2,-12(fp)
  1545e0:	10c00217 	ldw	r3,8(r2)
  1545e4:	e0bfff17 	ldw	r2,-4(fp)
  1545e8:	1887883a 	add	r3,r3,r2
  1545ec:	e0bffd17 	ldw	r2,-12(fp)
  1545f0:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  1545f4:	e0bffd17 	ldw	r2,-12(fp)
  1545f8:	10c00217 	ldw	r3,8(r2)
  1545fc:	d0a5b217 	ldw	r2,-26936(gp)
  154600:	1880032e 	bgeu	r3,r2,154610 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  154604:	e0bffd17 	ldw	r2,-12(fp)
  154608:	00c00044 	movi	r3,1
  15460c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  154610:	e0bffe17 	ldw	r2,-8(fp)
  154614:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  154618:	e0fffd17 	ldw	r3,-12(fp)
  15461c:	d0a00904 	addi	r2,gp,-32732
  154620:	18bfcf1e 	bne	r3,r2,154560 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  154624:	0001883a 	nop
}
  154628:	e037883a 	mov	sp,fp
  15462c:	dfc00117 	ldw	ra,4(sp)
  154630:	df000017 	ldw	fp,0(sp)
  154634:	dec00204 	addi	sp,sp,8
  154638:	f800283a 	ret

0015463c <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
  15463c:	deffff04 	addi	sp,sp,-4
  154640:	df000015 	stw	fp,0(sp)
  154644:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  154648:	000170fa 	wrctl	ienable,zero
}
  15464c:	e037883a 	mov	sp,fp
  154650:	df000017 	ldw	fp,0(sp)
  154654:	dec00104 	addi	sp,sp,4
  154658:	f800283a 	ret

0015465c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  15465c:	defffa04 	addi	sp,sp,-24
  154660:	dfc00515 	stw	ra,20(sp)
  154664:	df000415 	stw	fp,16(sp)
  154668:	df000404 	addi	fp,sp,16
  15466c:	e13ffe15 	stw	r4,-8(fp)
  154670:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  154674:	e0bfff17 	ldw	r2,-4(fp)
  154678:	10800017 	ldw	r2,0(r2)
  15467c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  154680:	e13ffe17 	ldw	r4,-8(fp)
  154684:	0154b000 	call	154b00 <strlen>
  154688:	10800044 	addi	r2,r2,1
  15468c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  154690:	00000d06 	br	1546c8 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  154694:	e0bffc17 	ldw	r2,-16(fp)
  154698:	10c00217 	ldw	r3,8(r2)
  15469c:	e0bffd17 	ldw	r2,-12(fp)
  1546a0:	1809883a 	mov	r4,r3
  1546a4:	e17ffe17 	ldw	r5,-8(fp)
  1546a8:	100d883a 	mov	r6,r2
  1546ac:	015498c0 	call	15498c <memcmp>
  1546b0:	1000021e 	bne	r2,zero,1546bc <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  1546b4:	e0bffc17 	ldw	r2,-16(fp)
  1546b8:	00000706 	br	1546d8 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  1546bc:	e0bffc17 	ldw	r2,-16(fp)
  1546c0:	10800017 	ldw	r2,0(r2)
  1546c4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  1546c8:	e0fffc17 	ldw	r3,-16(fp)
  1546cc:	e0bfff17 	ldw	r2,-4(fp)
  1546d0:	18bff01e 	bne	r3,r2,154694 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  1546d4:	0005883a 	mov	r2,zero
}
  1546d8:	e037883a 	mov	sp,fp
  1546dc:	dfc00117 	ldw	ra,4(sp)
  1546e0:	df000017 	ldw	fp,0(sp)
  1546e4:	dec00204 	addi	sp,sp,8
  1546e8:	f800283a 	ret

001546ec <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  1546ec:	defffb04 	addi	sp,sp,-20
  1546f0:	dfc00415 	stw	ra,16(sp)
  1546f4:	df000315 	stw	fp,12(sp)
  1546f8:	df000304 	addi	fp,sp,12
  1546fc:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  154700:	00800574 	movhi	r2,21
  154704:	109b5804 	addi	r2,r2,28000
  154708:	10800017 	ldw	r2,0(r2)
  15470c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  154710:	00003106 	br	1547d8 <alt_find_file+0xec>
  {
    len = strlen(next->name);
  154714:	e0bffd17 	ldw	r2,-12(fp)
  154718:	10800217 	ldw	r2,8(r2)
  15471c:	1009883a 	mov	r4,r2
  154720:	0154b000 	call	154b00 <strlen>
  154724:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  154728:	e0bffd17 	ldw	r2,-12(fp)
  15472c:	10c00217 	ldw	r3,8(r2)
  154730:	e0bffe17 	ldw	r2,-8(fp)
  154734:	10bfffc4 	addi	r2,r2,-1
  154738:	1885883a 	add	r2,r3,r2
  15473c:	10800003 	ldbu	r2,0(r2)
  154740:	10803fcc 	andi	r2,r2,255
  154744:	1080201c 	xori	r2,r2,128
  154748:	10bfe004 	addi	r2,r2,-128
  15474c:	10800bd8 	cmpnei	r2,r2,47
  154750:	1000031e 	bne	r2,zero,154760 <alt_find_file+0x74>
    {
      len -= 1;
  154754:	e0bffe17 	ldw	r2,-8(fp)
  154758:	10bfffc4 	addi	r2,r2,-1
  15475c:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  154760:	e0bffe17 	ldw	r2,-8(fp)
  154764:	e0ffff17 	ldw	r3,-4(fp)
  154768:	1885883a 	add	r2,r3,r2
  15476c:	10800003 	ldbu	r2,0(r2)
  154770:	10803fcc 	andi	r2,r2,255
  154774:	1080201c 	xori	r2,r2,128
  154778:	10bfe004 	addi	r2,r2,-128
  15477c:	10800be0 	cmpeqi	r2,r2,47
  154780:	1000081e 	bne	r2,zero,1547a4 <alt_find_file+0xb8>
  154784:	e0bffe17 	ldw	r2,-8(fp)
  154788:	e0ffff17 	ldw	r3,-4(fp)
  15478c:	1885883a 	add	r2,r3,r2
  154790:	10800003 	ldbu	r2,0(r2)
  154794:	10803fcc 	andi	r2,r2,255
  154798:	1080201c 	xori	r2,r2,128
  15479c:	10bfe004 	addi	r2,r2,-128
  1547a0:	10000a1e 	bne	r2,zero,1547cc <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
  1547a4:	e0bffd17 	ldw	r2,-12(fp)
  1547a8:	10c00217 	ldw	r3,8(r2)
  1547ac:	e0bffe17 	ldw	r2,-8(fp)
  1547b0:	1809883a 	mov	r4,r3
  1547b4:	e17fff17 	ldw	r5,-4(fp)
  1547b8:	100d883a 	mov	r6,r2
  1547bc:	015498c0 	call	15498c <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  1547c0:	1000021e 	bne	r2,zero,1547cc <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  1547c4:	e0bffd17 	ldw	r2,-12(fp)
  1547c8:	00000806 	br	1547ec <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
  1547cc:	e0bffd17 	ldw	r2,-12(fp)
  1547d0:	10800017 	ldw	r2,0(r2)
  1547d4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  1547d8:	e0fffd17 	ldw	r3,-12(fp)
  1547dc:	00800574 	movhi	r2,21
  1547e0:	109b5804 	addi	r2,r2,28000
  1547e4:	18bfcb1e 	bne	r3,r2,154714 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  1547e8:	0005883a 	mov	r2,zero
}
  1547ec:	e037883a 	mov	sp,fp
  1547f0:	dfc00117 	ldw	ra,4(sp)
  1547f4:	df000017 	ldw	fp,0(sp)
  1547f8:	dec00204 	addi	sp,sp,8
  1547fc:	f800283a 	ret

00154800 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  154800:	defffc04 	addi	sp,sp,-16
  154804:	df000315 	stw	fp,12(sp)
  154808:	df000304 	addi	fp,sp,12
  15480c:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
  154810:	00bffa04 	movi	r2,-24
  154814:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  154818:	e03ffd15 	stw	zero,-12(fp)
  15481c:	00001d06 	br	154894 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
  154820:	00c00574 	movhi	r3,21
  154824:	18d9f504 	addi	r3,r3,26580
  154828:	e0bffd17 	ldw	r2,-12(fp)
  15482c:	10800324 	muli	r2,r2,12
  154830:	1885883a 	add	r2,r3,r2
  154834:	10800017 	ldw	r2,0(r2)
  154838:	1000131e 	bne	r2,zero,154888 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
  15483c:	00c00574 	movhi	r3,21
  154840:	18d9f504 	addi	r3,r3,26580
  154844:	e0bffd17 	ldw	r2,-12(fp)
  154848:	10800324 	muli	r2,r2,12
  15484c:	1885883a 	add	r2,r3,r2
  154850:	e0ffff17 	ldw	r3,-4(fp)
  154854:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  154858:	00800574 	movhi	r2,21
  15485c:	109b5c04 	addi	r2,r2,28016
  154860:	10c00017 	ldw	r3,0(r2)
  154864:	e0bffd17 	ldw	r2,-12(fp)
  154868:	1880040e 	bge	r3,r2,15487c <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
  15486c:	00800574 	movhi	r2,21
  154870:	109b5c04 	addi	r2,r2,28016
  154874:	e0fffd17 	ldw	r3,-12(fp)
  154878:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
  15487c:	e0bffd17 	ldw	r2,-12(fp)
  154880:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
  154884:	00000606 	br	1548a0 <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  154888:	e0bffd17 	ldw	r2,-12(fp)
  15488c:	10800044 	addi	r2,r2,1
  154890:	e0bffd15 	stw	r2,-12(fp)
  154894:	e0bffd17 	ldw	r2,-12(fp)
  154898:	10800810 	cmplti	r2,r2,32
  15489c:	103fe01e 	bne	r2,zero,154820 <alt_get_fd+0x20>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  1548a0:	e0bffe17 	ldw	r2,-8(fp)
}
  1548a4:	e037883a 	mov	sp,fp
  1548a8:	df000017 	ldw	fp,0(sp)
  1548ac:	dec00104 	addi	sp,sp,4
  1548b0:	f800283a 	ret

001548b4 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
  1548b4:	defffb04 	addi	sp,sp,-20
  1548b8:	df000415 	stw	fp,16(sp)
  1548bc:	df000404 	addi	fp,sp,16
  1548c0:	e13ffe15 	stw	r4,-8(fp)
  1548c4:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
  1548c8:	e0bfff17 	ldw	r2,-4(fp)
  1548cc:	10840070 	cmpltui	r2,r2,4097
  1548d0:	1000021e 	bne	r2,zero,1548dc <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
  1548d4:	00840004 	movi	r2,4096
  1548d8:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
  1548dc:	e0fffe17 	ldw	r3,-8(fp)
  1548e0:	e0bfff17 	ldw	r2,-4(fp)
  1548e4:	1885883a 	add	r2,r3,r2
  1548e8:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  1548ec:	e0bffe17 	ldw	r2,-8(fp)
  1548f0:	e0bffc15 	stw	r2,-16(fp)
  1548f4:	00000506 	br	15490c <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
  1548f8:	e0bffc17 	ldw	r2,-16(fp)
  1548fc:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  154900:	e0bffc17 	ldw	r2,-16(fp)
  154904:	10800804 	addi	r2,r2,32
  154908:	e0bffc15 	stw	r2,-16(fp)
  15490c:	e0fffc17 	ldw	r3,-16(fp)
  154910:	e0bffd17 	ldw	r2,-12(fp)
  154914:	18bff836 	bltu	r3,r2,1548f8 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
  154918:	e0bffe17 	ldw	r2,-8(fp)
  15491c:	108007cc 	andi	r2,r2,31
  154920:	10000226 	beq	r2,zero,15492c <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
  154924:	e0bffc17 	ldw	r2,-16(fp)
  154928:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
  15492c:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
  154930:	e037883a 	mov	sp,fp
  154934:	df000017 	ldw	fp,0(sp)
  154938:	dec00104 	addi	sp,sp,4
  15493c:	f800283a 	ret

00154940 <atexit>:
  154940:	200b883a 	mov	r5,r4
  154944:	000d883a 	mov	r6,zero
  154948:	0009883a 	mov	r4,zero
  15494c:	000f883a 	mov	r7,zero
  154950:	0154b8c1 	jmpi	154b8c <__register_exitproc>

00154954 <exit>:
  154954:	defffe04 	addi	sp,sp,-8
  154958:	000b883a 	mov	r5,zero
  15495c:	dc000015 	stw	r16,0(sp)
  154960:	dfc00115 	stw	ra,4(sp)
  154964:	2021883a 	mov	r16,r4
  154968:	0154cbc0 	call	154cbc <__call_exitprocs>
  15496c:	00800574 	movhi	r2,21
  154970:	109b6004 	addi	r2,r2,28032
  154974:	11000017 	ldw	r4,0(r2)
  154978:	20800f17 	ldw	r2,60(r4)
  15497c:	10000126 	beq	r2,zero,154984 <exit+0x30>
  154980:	103ee83a 	callr	r2
  154984:	8009883a 	mov	r4,r16
  154988:	0154e5c0 	call	154e5c <_exit>

0015498c <memcmp>:
  15498c:	01c000c4 	movi	r7,3
  154990:	3980192e 	bgeu	r7,r6,1549f8 <memcmp+0x6c>
  154994:	2904b03a 	or	r2,r5,r4
  154998:	11c4703a 	and	r2,r2,r7
  15499c:	10000f26 	beq	r2,zero,1549dc <memcmp+0x50>
  1549a0:	20c00003 	ldbu	r3,0(r4)
  1549a4:	28800003 	ldbu	r2,0(r5)
  1549a8:	1880151e 	bne	r3,r2,154a00 <memcmp+0x74>
  1549ac:	31bfff84 	addi	r6,r6,-2
  1549b0:	01ffffc4 	movi	r7,-1
  1549b4:	00000406 	br	1549c8 <memcmp+0x3c>
  1549b8:	20c00003 	ldbu	r3,0(r4)
  1549bc:	28800003 	ldbu	r2,0(r5)
  1549c0:	31bfffc4 	addi	r6,r6,-1
  1549c4:	18800e1e 	bne	r3,r2,154a00 <memcmp+0x74>
  1549c8:	21000044 	addi	r4,r4,1
  1549cc:	29400044 	addi	r5,r5,1
  1549d0:	31fff91e 	bne	r6,r7,1549b8 <memcmp+0x2c>
  1549d4:	0005883a 	mov	r2,zero
  1549d8:	f800283a 	ret
  1549dc:	20c00017 	ldw	r3,0(r4)
  1549e0:	28800017 	ldw	r2,0(r5)
  1549e4:	1880041e 	bne	r3,r2,1549f8 <memcmp+0x6c>
  1549e8:	31bfff04 	addi	r6,r6,-4
  1549ec:	21000104 	addi	r4,r4,4
  1549f0:	29400104 	addi	r5,r5,4
  1549f4:	39bff936 	bltu	r7,r6,1549dc <memcmp+0x50>
  1549f8:	303fe91e 	bne	r6,zero,1549a0 <memcmp+0x14>
  1549fc:	003ff506 	br	1549d4 <memcmp+0x48>
  154a00:	1885c83a 	sub	r2,r3,r2
  154a04:	f800283a 	ret

00154a08 <memcpy>:
  154a08:	00c003c4 	movi	r3,15
  154a0c:	2005883a 	mov	r2,r4
  154a10:	3009883a 	mov	r4,r6
  154a14:	1980032e 	bgeu	r3,r6,154a24 <memcpy+0x1c>
  154a18:	2886b03a 	or	r3,r5,r2
  154a1c:	18c000cc 	andi	r3,r3,3
  154a20:	18000926 	beq	r3,zero,154a48 <memcpy+0x40>
  154a24:	1007883a 	mov	r3,r2
  154a28:	290f883a 	add	r7,r5,r4
  154a2c:	20000526 	beq	r4,zero,154a44 <memcpy+0x3c>
  154a30:	29800003 	ldbu	r6,0(r5)
  154a34:	18c00044 	addi	r3,r3,1
  154a38:	29400044 	addi	r5,r5,1
  154a3c:	19bfffc5 	stb	r6,-1(r3)
  154a40:	29fffb1e 	bne	r5,r7,154a30 <memcpy+0x28>
  154a44:	f800283a 	ret
  154a48:	327ffc04 	addi	r9,r6,-16
  154a4c:	4812d13a 	srli	r9,r9,4
  154a50:	11000404 	addi	r4,r2,16
  154a54:	1007883a 	mov	r3,r2
  154a58:	4810913a 	slli	r8,r9,4
  154a5c:	280f883a 	mov	r7,r5
  154a60:	2209883a 	add	r4,r4,r8
  154a64:	3a000017 	ldw	r8,0(r7)
  154a68:	18c00404 	addi	r3,r3,16
  154a6c:	39c00404 	addi	r7,r7,16
  154a70:	1a3ffc15 	stw	r8,-16(r3)
  154a74:	3a3ffd17 	ldw	r8,-12(r7)
  154a78:	1a3ffd15 	stw	r8,-12(r3)
  154a7c:	3a3ffe17 	ldw	r8,-8(r7)
  154a80:	1a3ffe15 	stw	r8,-8(r3)
  154a84:	3a3fff17 	ldw	r8,-4(r7)
  154a88:	1a3fff15 	stw	r8,-4(r3)
  154a8c:	193ff51e 	bne	r3,r4,154a64 <memcpy+0x5c>
  154a90:	49c00044 	addi	r7,r9,1
  154a94:	380e913a 	slli	r7,r7,4
  154a98:	310003cc 	andi	r4,r6,15
  154a9c:	018000c4 	movi	r6,3
  154aa0:	11c7883a 	add	r3,r2,r7
  154aa4:	29cb883a 	add	r5,r5,r7
  154aa8:	313fdf2e 	bgeu	r6,r4,154a28 <memcpy+0x20>
  154aac:	213fff04 	addi	r4,r4,-4
  154ab0:	2014d0ba 	srli	r10,r4,2
  154ab4:	1a400104 	addi	r9,r3,4
  154ab8:	180d883a 	mov	r6,r3
  154abc:	528f883a 	add	r7,r10,r10
  154ac0:	39cf883a 	add	r7,r7,r7
  154ac4:	49d3883a 	add	r9,r9,r7
  154ac8:	280f883a 	mov	r7,r5
  154acc:	3a000017 	ldw	r8,0(r7)
  154ad0:	31800104 	addi	r6,r6,4
  154ad4:	39c00104 	addi	r7,r7,4
  154ad8:	323fff15 	stw	r8,-4(r6)
  154adc:	327ffb1e 	bne	r6,r9,154acc <memcpy+0xc4>
  154ae0:	51800044 	addi	r6,r10,1
  154ae4:	52bfff24 	muli	r10,r10,-4
  154ae8:	318d883a 	add	r6,r6,r6
  154aec:	318d883a 	add	r6,r6,r6
  154af0:	5109883a 	add	r4,r10,r4
  154af4:	298b883a 	add	r5,r5,r6
  154af8:	1987883a 	add	r3,r3,r6
  154afc:	003fca06 	br	154a28 <memcpy+0x20>

00154b00 <strlen>:
  154b00:	208000cc 	andi	r2,r4,3
  154b04:	10001f1e 	bne	r2,zero,154b84 <strlen+0x84>
  154b08:	20800017 	ldw	r2,0(r4)
  154b0c:	01ffbff4 	movhi	r7,65279
  154b10:	39ffbfc4 	addi	r7,r7,-257
  154b14:	01a02074 	movhi	r6,32897
  154b18:	31a02004 	addi	r6,r6,-32640
  154b1c:	11c7883a 	add	r3,r2,r7
  154b20:	0084303a 	nor	r2,zero,r2
  154b24:	1886703a 	and	r3,r3,r2
  154b28:	1986703a 	and	r3,r3,r6
  154b2c:	2005883a 	mov	r2,r4
  154b30:	1800101e 	bne	r3,zero,154b74 <strlen+0x74>
  154b34:	10800104 	addi	r2,r2,4
  154b38:	10c00017 	ldw	r3,0(r2)
  154b3c:	19cb883a 	add	r5,r3,r7
  154b40:	00c6303a 	nor	r3,zero,r3
  154b44:	28c6703a 	and	r3,r5,r3
  154b48:	1986703a 	and	r3,r3,r6
  154b4c:	1800091e 	bne	r3,zero,154b74 <strlen+0x74>
  154b50:	10800104 	addi	r2,r2,4
  154b54:	10c00017 	ldw	r3,0(r2)
  154b58:	19cb883a 	add	r5,r3,r7
  154b5c:	00c6303a 	nor	r3,zero,r3
  154b60:	28c6703a 	and	r3,r5,r3
  154b64:	1986703a 	and	r3,r3,r6
  154b68:	183ff226 	beq	r3,zero,154b34 <strlen+0x34>
  154b6c:	00000106 	br	154b74 <strlen+0x74>
  154b70:	10800044 	addi	r2,r2,1
  154b74:	10c00007 	ldb	r3,0(r2)
  154b78:	183ffd1e 	bne	r3,zero,154b70 <strlen+0x70>
  154b7c:	1105c83a 	sub	r2,r2,r4
  154b80:	f800283a 	ret
  154b84:	2005883a 	mov	r2,r4
  154b88:	003ffa06 	br	154b74 <strlen+0x74>

00154b8c <__register_exitproc>:
  154b8c:	defffa04 	addi	sp,sp,-24
  154b90:	00800574 	movhi	r2,21
  154b94:	109b6004 	addi	r2,r2,28032
  154b98:	dc000315 	stw	r16,12(sp)
  154b9c:	14000017 	ldw	r16,0(r2)
  154ba0:	dc400415 	stw	r17,16(sp)
  154ba4:	dfc00515 	stw	ra,20(sp)
  154ba8:	80805217 	ldw	r2,328(r16)
  154bac:	2023883a 	mov	r17,r4
  154bb0:	10003e26 	beq	r2,zero,154cac <__register_exitproc+0x120>
  154bb4:	10c00117 	ldw	r3,4(r2)
  154bb8:	020007c4 	movi	r8,31
  154bbc:	40c0180e 	bge	r8,r3,154c20 <__register_exitproc+0x94>
  154bc0:	00800034 	movhi	r2,0
  154bc4:	10800004 	addi	r2,r2,0
  154bc8:	1000061e 	bne	r2,zero,154be4 <__register_exitproc+0x58>
  154bcc:	00bfffc4 	movi	r2,-1
  154bd0:	dfc00517 	ldw	ra,20(sp)
  154bd4:	dc400417 	ldw	r17,16(sp)
  154bd8:	dc000317 	ldw	r16,12(sp)
  154bdc:	dec00604 	addi	sp,sp,24
  154be0:	f800283a 	ret
  154be4:	01006404 	movi	r4,400
  154be8:	d9400015 	stw	r5,0(sp)
  154bec:	d9800115 	stw	r6,4(sp)
  154bf0:	d9c00215 	stw	r7,8(sp)
  154bf4:	00000000 	call	0 <__alt_mem_rom-0x80000>
  154bf8:	d9400017 	ldw	r5,0(sp)
  154bfc:	d9800117 	ldw	r6,4(sp)
  154c00:	d9c00217 	ldw	r7,8(sp)
  154c04:	103ff126 	beq	r2,zero,154bcc <__register_exitproc+0x40>
  154c08:	80c05217 	ldw	r3,328(r16)
  154c0c:	10000115 	stw	zero,4(r2)
  154c10:	10c00015 	stw	r3,0(r2)
  154c14:	80805215 	stw	r2,328(r16)
  154c18:	10006215 	stw	zero,392(r2)
  154c1c:	10006315 	stw	zero,396(r2)
  154c20:	10c00117 	ldw	r3,4(r2)
  154c24:	88000d1e 	bne	r17,zero,154c5c <__register_exitproc+0xd0>
  154c28:	19000084 	addi	r4,r3,2
  154c2c:	2109883a 	add	r4,r4,r4
  154c30:	18c00044 	addi	r3,r3,1
  154c34:	2109883a 	add	r4,r4,r4
  154c38:	1109883a 	add	r4,r2,r4
  154c3c:	10c00115 	stw	r3,4(r2)
  154c40:	0005883a 	mov	r2,zero
  154c44:	21400015 	stw	r5,0(r4)
  154c48:	dfc00517 	ldw	ra,20(sp)
  154c4c:	dc400417 	ldw	r17,16(sp)
  154c50:	dc000317 	ldw	r16,12(sp)
  154c54:	dec00604 	addi	sp,sp,24
  154c58:	f800283a 	ret
  154c5c:	02400044 	movi	r9,1
  154c60:	12806217 	ldw	r10,392(r2)
  154c64:	48d2983a 	sll	r9,r9,r3
  154c68:	19000804 	addi	r4,r3,32
  154c6c:	18d1883a 	add	r8,r3,r3
  154c70:	2109883a 	add	r4,r4,r4
  154c74:	4211883a 	add	r8,r8,r8
  154c78:	2109883a 	add	r4,r4,r4
  154c7c:	1109883a 	add	r4,r2,r4
  154c80:	1211883a 	add	r8,r2,r8
  154c84:	5254b03a 	or	r10,r10,r9
  154c88:	21c02215 	stw	r7,136(r4)
  154c8c:	41802215 	stw	r6,136(r8)
  154c90:	12806215 	stw	r10,392(r2)
  154c94:	01000084 	movi	r4,2
  154c98:	893fe31e 	bne	r17,r4,154c28 <__register_exitproc+0x9c>
  154c9c:	11006317 	ldw	r4,396(r2)
  154ca0:	2252b03a 	or	r9,r4,r9
  154ca4:	12406315 	stw	r9,396(r2)
  154ca8:	003fdf06 	br	154c28 <__register_exitproc+0x9c>
  154cac:	008005b4 	movhi	r2,22
  154cb0:	10a28604 	addi	r2,r2,-30184
  154cb4:	80805215 	stw	r2,328(r16)
  154cb8:	003fbe06 	br	154bb4 <__register_exitproc+0x28>

00154cbc <__call_exitprocs>:
  154cbc:	00800574 	movhi	r2,21
  154cc0:	109b6004 	addi	r2,r2,28032
  154cc4:	10800017 	ldw	r2,0(r2)
  154cc8:	defff304 	addi	sp,sp,-52
  154ccc:	df000b15 	stw	fp,44(sp)
  154cd0:	d8800015 	stw	r2,0(sp)
  154cd4:	10805204 	addi	r2,r2,328
  154cd8:	dd400815 	stw	r21,32(sp)
  154cdc:	dfc00c15 	stw	ra,48(sp)
  154ce0:	ddc00a15 	stw	r23,40(sp)
  154ce4:	dd800915 	stw	r22,36(sp)
  154ce8:	dd000715 	stw	r20,28(sp)
  154cec:	dcc00615 	stw	r19,24(sp)
  154cf0:	dc800515 	stw	r18,20(sp)
  154cf4:	dc400415 	stw	r17,16(sp)
  154cf8:	dc000315 	stw	r16,12(sp)
  154cfc:	d9000115 	stw	r4,4(sp)
  154d00:	2839883a 	mov	fp,r5
  154d04:	d8800215 	stw	r2,8(sp)
  154d08:	057fffc4 	movi	r21,-1
  154d0c:	d8800017 	ldw	r2,0(sp)
  154d10:	ddc00217 	ldw	r23,8(sp)
  154d14:	14805217 	ldw	r18,328(r2)
  154d18:	90001726 	beq	r18,zero,154d78 <__call_exitprocs+0xbc>
  154d1c:	94400117 	ldw	r17,4(r18)
  154d20:	8c3fffc4 	addi	r16,r17,-1
  154d24:	80001116 	blt	r16,zero,154d6c <__call_exitprocs+0xb0>
  154d28:	8c400044 	addi	r17,r17,1
  154d2c:	8427883a 	add	r19,r16,r16
  154d30:	8c63883a 	add	r17,r17,r17
  154d34:	95802204 	addi	r22,r18,136
  154d38:	9ce7883a 	add	r19,r19,r19
  154d3c:	8c63883a 	add	r17,r17,r17
  154d40:	b4e7883a 	add	r19,r22,r19
  154d44:	9463883a 	add	r17,r18,r17
  154d48:	e0001726 	beq	fp,zero,154da8 <__call_exitprocs+0xec>
  154d4c:	8c87c83a 	sub	r3,r17,r18
  154d50:	b0c7883a 	add	r3,r22,r3
  154d54:	18c01e17 	ldw	r3,120(r3)
  154d58:	1f001326 	beq	r3,fp,154da8 <__call_exitprocs+0xec>
  154d5c:	843fffc4 	addi	r16,r16,-1
  154d60:	9cffff04 	addi	r19,r19,-4
  154d64:	8c7fff04 	addi	r17,r17,-4
  154d68:	857ff71e 	bne	r16,r21,154d48 <__call_exitprocs+0x8c>
  154d6c:	00800034 	movhi	r2,0
  154d70:	10800004 	addi	r2,r2,0
  154d74:	10002a1e 	bne	r2,zero,154e20 <__call_exitprocs+0x164>
  154d78:	dfc00c17 	ldw	ra,48(sp)
  154d7c:	df000b17 	ldw	fp,44(sp)
  154d80:	ddc00a17 	ldw	r23,40(sp)
  154d84:	dd800917 	ldw	r22,36(sp)
  154d88:	dd400817 	ldw	r21,32(sp)
  154d8c:	dd000717 	ldw	r20,28(sp)
  154d90:	dcc00617 	ldw	r19,24(sp)
  154d94:	dc800517 	ldw	r18,20(sp)
  154d98:	dc400417 	ldw	r17,16(sp)
  154d9c:	dc000317 	ldw	r16,12(sp)
  154da0:	dec00d04 	addi	sp,sp,52
  154da4:	f800283a 	ret
  154da8:	91000117 	ldw	r4,4(r18)
  154dac:	88c00017 	ldw	r3,0(r17)
  154db0:	213fffc4 	addi	r4,r4,-1
  154db4:	24001526 	beq	r4,r16,154e0c <__call_exitprocs+0x150>
  154db8:	88000015 	stw	zero,0(r17)
  154dbc:	183fe726 	beq	r3,zero,154d5c <__call_exitprocs+0xa0>
  154dc0:	00800044 	movi	r2,1
  154dc4:	1408983a 	sll	r4,r2,r16
  154dc8:	91406217 	ldw	r5,392(r18)
  154dcc:	95000117 	ldw	r20,4(r18)
  154dd0:	214a703a 	and	r5,r4,r5
  154dd4:	28000b26 	beq	r5,zero,154e04 <__call_exitprocs+0x148>
  154dd8:	91406317 	ldw	r5,396(r18)
  154ddc:	2148703a 	and	r4,r4,r5
  154de0:	20000c1e 	bne	r4,zero,154e14 <__call_exitprocs+0x158>
  154de4:	99400017 	ldw	r5,0(r19)
  154de8:	d9000117 	ldw	r4,4(sp)
  154dec:	183ee83a 	callr	r3
  154df0:	90c00117 	ldw	r3,4(r18)
  154df4:	1d3fc51e 	bne	r3,r20,154d0c <__call_exitprocs+0x50>
  154df8:	b8c00017 	ldw	r3,0(r23)
  154dfc:	1cbfd726 	beq	r3,r18,154d5c <__call_exitprocs+0xa0>
  154e00:	003fc206 	br	154d0c <__call_exitprocs+0x50>
  154e04:	183ee83a 	callr	r3
  154e08:	003ff906 	br	154df0 <__call_exitprocs+0x134>
  154e0c:	94000115 	stw	r16,4(r18)
  154e10:	003fea06 	br	154dbc <__call_exitprocs+0x100>
  154e14:	99000017 	ldw	r4,0(r19)
  154e18:	183ee83a 	callr	r3
  154e1c:	003ff406 	br	154df0 <__call_exitprocs+0x134>
  154e20:	90c00117 	ldw	r3,4(r18)
  154e24:	1800071e 	bne	r3,zero,154e44 <__call_exitprocs+0x188>
  154e28:	90c00017 	ldw	r3,0(r18)
  154e2c:	18000926 	beq	r3,zero,154e54 <__call_exitprocs+0x198>
  154e30:	9009883a 	mov	r4,r18
  154e34:	b8c00015 	stw	r3,0(r23)
  154e38:	00000000 	call	0 <__alt_mem_rom-0x80000>
  154e3c:	bc800017 	ldw	r18,0(r23)
  154e40:	003fb506 	br	154d18 <__call_exitprocs+0x5c>
  154e44:	90c00017 	ldw	r3,0(r18)
  154e48:	902f883a 	mov	r23,r18
  154e4c:	1825883a 	mov	r18,r3
  154e50:	003fb106 	br	154d18 <__call_exitprocs+0x5c>
  154e54:	0007883a 	mov	r3,zero
  154e58:	003ffb06 	br	154e48 <__call_exitprocs+0x18c>

00154e5c <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  154e5c:	defffc04 	addi	sp,sp,-16
  154e60:	df000315 	stw	fp,12(sp)
  154e64:	df000304 	addi	fp,sp,12
  154e68:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  154e6c:	0001883a 	nop
  154e70:	e0bfff17 	ldw	r2,-4(fp)
  154e74:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
  154e78:	e0bffd17 	ldw	r2,-12(fp)
  154e7c:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  154e80:	e0bffe17 	ldw	r2,-8(fp)
  154e84:	10000226 	beq	r2,zero,154e90 <_exit+0x34>
    ALT_SIM_FAIL();
  154e88:	002af070 	cmpltui	zero,zero,43969
  154e8c:	00000106 	br	154e94 <_exit+0x38>
  } else {
    ALT_SIM_PASS();
  154e90:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  154e94:	003fff06 	br	154e94 <_exit+0x38>
